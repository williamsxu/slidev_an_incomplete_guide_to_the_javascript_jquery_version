import {
  __commonJS
} from "./chunk-A2XPJTG4.js";

// node_modules/prettier/standalone.js
var require_standalone = __commonJS({
  "node_modules/prettier/standalone.js"(exports, module) {
    !function(e, t) {
      typeof exports == "object" && typeof module != "undefined" ? module.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis != "undefined" ? globalThis : e || self).prettier = t();
    }(exports, function() {
      "use strict";
      var e = { version: "2.4.1" }, t = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
      function n(e2) {
        return e2 && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
      }
      function r(e2) {
        var t2 = { exports: {} };
        return e2(t2, t2.exports), t2.exports;
      }
      var i = r(function(e2, t2) {
        function n2() {
        }
        function r2(e3, t3, n3, r3, i3) {
          for (var u2 = 0, o2 = t3.length, s2 = 0, a2 = 0; u2 < o2; u2++) {
            var c2 = t3[u2];
            if (c2.removed) {
              if (c2.value = e3.join(r3.slice(a2, a2 + c2.count)), a2 += c2.count, u2 && t3[u2 - 1].added) {
                var l2 = t3[u2 - 1];
                t3[u2 - 1] = t3[u2], t3[u2] = l2;
              }
            } else {
              if (!c2.added && i3) {
                var p2 = n3.slice(s2, s2 + c2.count);
                p2 = p2.map(function(e4, t4) {
                  var n4 = r3[a2 + t4];
                  return n4.length > e4.length ? n4 : e4;
                }), c2.value = e3.join(p2);
              } else
                c2.value = e3.join(n3.slice(s2, s2 + c2.count));
              s2 += c2.count, c2.added || (a2 += c2.count);
            }
          }
          var f2 = t3[o2 - 1];
          return o2 > 1 && typeof f2.value == "string" && (f2.added || f2.removed) && e3.equals("", f2.value) && (t3[o2 - 2].value += f2.value, t3.pop()), t3;
        }
        function i2(e3) {
          return { newPos: e3.newPos, components: e3.components.slice(0) };
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = n2, n2.prototype = { diff: function(e3, t3) {
          var n3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u2 = n3.callback;
          typeof n3 == "function" && (u2 = n3, n3 = {}), this.options = n3;
          var o2 = this;
          function s2(e4) {
            return u2 ? (setTimeout(function() {
              u2(void 0, e4);
            }, 0), true) : e4;
          }
          e3 = this.castInput(e3), t3 = this.castInput(t3), e3 = this.removeEmpty(this.tokenize(e3));
          var a2 = (t3 = this.removeEmpty(this.tokenize(t3))).length, c2 = e3.length, l2 = 1, p2 = a2 + c2, f2 = [{ newPos: -1, components: [] }], d2 = this.extractCommon(f2[0], t3, e3, 0);
          if (f2[0].newPos + 1 >= a2 && d2 + 1 >= c2)
            return s2([{ value: this.join(t3), count: t3.length }]);
          function h2() {
            for (var n4 = -1 * l2; n4 <= l2; n4 += 2) {
              var u3 = void 0, p3 = f2[n4 - 1], d3 = f2[n4 + 1], h3 = (d3 ? d3.newPos : 0) - n4;
              p3 && (f2[n4 - 1] = void 0);
              var g3 = p3 && p3.newPos + 1 < a2, m2 = d3 && 0 <= h3 && h3 < c2;
              if (g3 || m2) {
                if (!g3 || m2 && p3.newPos < d3.newPos ? (u3 = i2(d3), o2.pushComponent(u3.components, void 0, true)) : ((u3 = p3).newPos++, o2.pushComponent(u3.components, true, void 0)), h3 = o2.extractCommon(u3, t3, e3, n4), u3.newPos + 1 >= a2 && h3 + 1 >= c2)
                  return s2(r2(o2, u3.components, t3, e3, o2.useLongestToken));
                f2[n4] = u3;
              } else
                f2[n4] = void 0;
            }
            l2++;
          }
          if (u2)
            !function e4() {
              setTimeout(function() {
                if (l2 > p2)
                  return u2();
                h2() || e4();
              }, 0);
            }();
          else
            for (; l2 <= p2; ) {
              var g2 = h2();
              if (g2)
                return g2;
            }
        }, pushComponent: function(e3, t3, n3) {
          var r3 = e3[e3.length - 1];
          r3 && r3.added === t3 && r3.removed === n3 ? e3[e3.length - 1] = { count: r3.count + 1, added: t3, removed: n3 } : e3.push({ count: 1, added: t3, removed: n3 });
        }, extractCommon: function(e3, t3, n3, r3) {
          for (var i3 = t3.length, u2 = n3.length, o2 = e3.newPos, s2 = o2 - r3, a2 = 0; o2 + 1 < i3 && s2 + 1 < u2 && this.equals(t3[o2 + 1], n3[s2 + 1]); )
            o2++, s2++, a2++;
          return a2 && e3.components.push({ count: a2 }), e3.newPos = o2, s2;
        }, equals: function(e3, t3) {
          return this.options.comparator ? this.options.comparator(e3, t3) : e3 === t3 || this.options.ignoreCase && e3.toLowerCase() === t3.toLowerCase();
        }, removeEmpty: function(e3) {
          for (var t3 = [], n3 = 0; n3 < e3.length; n3++)
            e3[n3] && t3.push(e3[n3]);
          return t3;
        }, castInput: function(e3) {
          return e3;
        }, tokenize: function(e3) {
          return e3.split("");
        }, join: function(e3) {
          return e3.join("");
        } };
      }), u = r(function(e2, t2) {
        var n2;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.diffChars = function(e3, t3, n3) {
          return r2.diff(e3, t3, n3);
        }, t2.characterDiff = void 0;
        var r2 = new ((n2 = i) && n2.__esModule ? n2 : { default: n2 }).default();
        t2.characterDiff = r2;
      }), o = function(e2, t2) {
        if (typeof e2 == "function")
          t2.callback = e2;
        else if (e2)
          for (var n2 in e2)
            e2.hasOwnProperty(n2) && (t2[n2] = e2[n2]);
        return t2;
      };
      var s, a, c = Object.defineProperty({ generateOptions: o }, "__esModule", { value: true }), l = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.diffWords = function(e3, t3, n3) {
          return n3 = (0, c.generateOptions)(n3, { ignoreWhitespace: true }), s2.diff(e3, t3, n3);
        }, t2.diffWordsWithSpace = function(e3, t3, n3) {
          return s2.diff(e3, t3, n3);
        }, t2.wordDiff = void 0;
        var n2, r2 = (n2 = i) && n2.__esModule ? n2 : { default: n2 };
        var u2 = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/, o2 = /\S/, s2 = new r2.default();
        t2.wordDiff = s2, s2.equals = function(e3, t3) {
          return this.options.ignoreCase && (e3 = e3.toLowerCase(), t3 = t3.toLowerCase()), e3 === t3 || this.options.ignoreWhitespace && !o2.test(e3) && !o2.test(t3);
        }, s2.tokenize = function(e3) {
          for (var t3 = e3.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), n3 = 0; n3 < t3.length - 1; n3++)
            !t3[n3 + 1] && t3[n3 + 2] && u2.test(t3[n3]) && u2.test(t3[n3 + 2]) && (t3[n3] += t3[n3 + 2], t3.splice(n3 + 1, 2), n3--);
          return t3;
        };
      }), p = r(function(e2, t2) {
        var n2;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.diffLines = function(e3, t3, n3) {
          return r2.diff(e3, t3, n3);
        }, t2.diffTrimmedLines = function(e3, t3, n3) {
          var i2 = (0, c.generateOptions)(n3, { ignoreWhitespace: true });
          return r2.diff(e3, t3, i2);
        }, t2.lineDiff = void 0;
        var r2 = new ((n2 = i) && n2.__esModule ? n2 : { default: n2 }).default();
        t2.lineDiff = r2, r2.tokenize = function(e3) {
          var t3 = [], n3 = e3.split(/(\n|\r\n)/);
          n3[n3.length - 1] || n3.pop();
          for (var r3 = 0; r3 < n3.length; r3++) {
            var i2 = n3[r3];
            r3 % 2 && !this.options.newlineIsToken ? t3[t3.length - 1] += i2 : (this.options.ignoreWhitespace && (i2 = i2.trim()), t3.push(i2));
          }
          return t3;
        };
      }), f = r(function(e2, t2) {
        var n2;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.diffSentences = function(e3, t3, n3) {
          return r2.diff(e3, t3, n3);
        }, t2.sentenceDiff = void 0;
        var r2 = new ((n2 = i) && n2.__esModule ? n2 : { default: n2 }).default();
        t2.sentenceDiff = r2, r2.tokenize = function(e3) {
          return e3.split(/(\S.+?[.!?])(?=\s+|$)/);
        };
      }), d = r(function(e2, t2) {
        var n2;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.diffCss = function(e3, t3, n3) {
          return r2.diff(e3, t3, n3);
        }, t2.cssDiff = void 0;
        var r2 = new ((n2 = i) && n2.__esModule ? n2 : { default: n2 }).default();
        t2.cssDiff = r2, r2.tokenize = function(e3) {
          return e3.split(/([{}:;,]|\s+)/);
        };
      }), h = function(e2) {
        return e2 && e2.Math == Math && e2;
      }, g = h(typeof globalThis == "object" && globalThis) || h(typeof window == "object" && window) || h(typeof self == "object" && self) || h(typeof t == "object" && t) || function() {
        return this;
      }() || Function("return this")(), m = function(e2) {
        try {
          return !!e2();
        } catch (e3) {
          return true;
        }
      }, y = !m(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] != 7;
      }), D = {}.propertyIsEnumerable, E = Object.getOwnPropertyDescriptor, C = { f: E && !D.call({ 1: 2 }, 1) ? function(e2) {
        var t2 = E(this, e2);
        return !!t2 && t2.enumerable;
      } : D }, b = function(e2, t2) {
        return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
      }, A = {}.toString, v = function(e2) {
        return A.call(e2).slice(8, -1);
      }, F = "".split, x = m(function() {
        return !Object("z").propertyIsEnumerable(0);
      }) ? function(e2) {
        return v(e2) == "String" ? F.call(e2, "") : Object(e2);
      } : Object, S = function(e2) {
        if (e2 == null)
          throw TypeError("Can't call method on " + e2);
        return e2;
      }, w = function(e2) {
        return x(S(e2));
      }, T = function(e2) {
        return typeof e2 == "object" ? e2 !== null : typeof e2 == "function";
      }, B = function(e2) {
        return typeof e2 == "function" ? e2 : void 0;
      }, N = function(e2, t2) {
        return arguments.length < 2 ? B(g[e2]) : g[e2] && g[e2][t2];
      }, k = N("navigator", "userAgent") || "", P = g.process, O = g.Deno, I = P && P.versions || O && O.version, L = I && I.v8;
      L ? a = (s = L.split("."))[0] < 4 ? 1 : s[0] + s[1] : k && (!(s = k.match(/Edge\/(\d+)/)) || s[1] >= 74) && (s = k.match(/Chrome\/(\d+)/)) && (a = s[1]);
      var j = a && +a, _ = !!Object.getOwnPropertySymbols && !m(function() {
        var e2 = Symbol();
        return !String(e2) || !(Object(e2) instanceof Symbol) || !Symbol.sham && j && j < 41;
      }), M = _ && !Symbol.sham && typeof Symbol.iterator == "symbol", R = M ? function(e2) {
        return typeof e2 == "symbol";
      } : function(e2) {
        var t2 = N("Symbol");
        return typeof t2 == "function" && Object(e2) instanceof t2;
      }, $ = function(e2, t2) {
        try {
          Object.defineProperty(g, e2, { value: t2, configurable: true, writable: true });
        } catch (n2) {
          g[e2] = t2;
        }
        return t2;
      }, V = "__core-js_shared__", W = g[V] || $(V, {}), q = r(function(e2) {
        (e2.exports = function(e3, t2) {
          return W[e3] || (W[e3] = t2 !== void 0 ? t2 : {});
        })("versions", []).push({ version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
      }), U = function(e2) {
        return Object(S(e2));
      }, z = {}.hasOwnProperty, G = Object.hasOwn || function(e2, t2) {
        return z.call(U(e2), t2);
      }, H = 0, J = Math.random(), X = function(e2) {
        return "Symbol(" + String(e2 === void 0 ? "" : e2) + ")_" + (++H + J).toString(36);
      }, Y = q("wks"), K = g.Symbol, Q = M ? K : K && K.withoutSetter || X, Z = function(e2) {
        return G(Y, e2) && (_ || typeof Y[e2] == "string") || (_ && G(K, e2) ? Y[e2] = K[e2] : Y[e2] = Q("Symbol." + e2)), Y[e2];
      }, ee = Z("toPrimitive"), te = function(e2, t2) {
        if (!T(e2) || R(e2))
          return e2;
        var n2, r2 = e2[ee];
        if (r2 !== void 0) {
          if (t2 === void 0 && (t2 = "default"), n2 = r2.call(e2, t2), !T(n2) || R(n2))
            return n2;
          throw TypeError("Can't convert object to primitive value");
        }
        return t2 === void 0 && (t2 = "number"), function(e3, t3) {
          var n3, r3;
          if (t3 === "string" && typeof (n3 = e3.toString) == "function" && !T(r3 = n3.call(e3)))
            return r3;
          if (typeof (n3 = e3.valueOf) == "function" && !T(r3 = n3.call(e3)))
            return r3;
          if (t3 !== "string" && typeof (n3 = e3.toString) == "function" && !T(r3 = n3.call(e3)))
            return r3;
          throw TypeError("Can't convert object to primitive value");
        }(e2, t2);
      }, ne = function(e2) {
        var t2 = te(e2, "string");
        return R(t2) ? t2 : String(t2);
      }, re = g.document, ie = T(re) && T(re.createElement), ue = !y && !m(function() {
        return Object.defineProperty((e2 = "div", ie ? re.createElement(e2) : {}), "a", { get: function() {
          return 7;
        } }).a != 7;
        var e2;
      }), oe = Object.getOwnPropertyDescriptor, se = { f: y ? oe : function(e2, t2) {
        if (e2 = w(e2), t2 = ne(t2), ue)
          try {
            return oe(e2, t2);
          } catch (e3) {
          }
        if (G(e2, t2))
          return b(!C.f.call(e2, t2), e2[t2]);
      } }, ae = function(e2) {
        if (!T(e2))
          throw TypeError(String(e2) + " is not an object");
        return e2;
      }, ce = Object.defineProperty, le = { f: y ? ce : function(e2, t2, n2) {
        if (ae(e2), t2 = ne(t2), ae(n2), ue)
          try {
            return ce(e2, t2, n2);
          } catch (e3) {
          }
        if ("get" in n2 || "set" in n2)
          throw TypeError("Accessors not supported");
        return "value" in n2 && (e2[t2] = n2.value), e2;
      } }, pe = y ? function(e2, t2, n2) {
        return le.f(e2, t2, b(1, n2));
      } : function(e2, t2, n2) {
        return e2[t2] = n2, e2;
      }, fe = Function.toString;
      typeof W.inspectSource != "function" && (W.inspectSource = function(e2) {
        return fe.call(e2);
      });
      var de, he, ge, me, ye = W.inspectSource, De = g.WeakMap, Ee = typeof De == "function" && /native code/.test(ye(De)), Ce = q("keys"), be = {}, Ae = "Object already initialized", ve = g.WeakMap;
      if (Ee || W.state) {
        var Fe = W.state || (W.state = new ve()), xe = Fe.get, Se = Fe.has, we = Fe.set;
        de = function(e2, t2) {
          if (Se.call(Fe, e2))
            throw new TypeError(Ae);
          return t2.facade = e2, we.call(Fe, e2, t2), t2;
        }, he = function(e2) {
          return xe.call(Fe, e2) || {};
        }, ge = function(e2) {
          return Se.call(Fe, e2);
        };
      } else {
        var Te = Ce[me = "state"] || (Ce[me] = X(me));
        be[Te] = true, de = function(e2, t2) {
          if (G(e2, Te))
            throw new TypeError(Ae);
          return t2.facade = e2, pe(e2, Te, t2), t2;
        }, he = function(e2) {
          return G(e2, Te) ? e2[Te] : {};
        }, ge = function(e2) {
          return G(e2, Te);
        };
      }
      var Be, Ne, ke = { set: de, get: he, has: ge, enforce: function(e2) {
        return ge(e2) ? he(e2) : de(e2, {});
      }, getterFor: function(e2) {
        return function(t2) {
          var n2;
          if (!T(t2) || (n2 = he(t2)).type !== e2)
            throw TypeError("Incompatible receiver, " + e2 + " required");
          return n2;
        };
      } }, Pe = r(function(e2) {
        var t2 = ke.get, n2 = ke.enforce, r2 = String(String).split("String");
        (e2.exports = function(e3, t3, i2, u2) {
          var o2, s2 = !!u2 && !!u2.unsafe, a2 = !!u2 && !!u2.enumerable, c2 = !!u2 && !!u2.noTargetGet;
          typeof i2 == "function" && (typeof t3 != "string" || G(i2, "name") || pe(i2, "name", t3), (o2 = n2(i2)).source || (o2.source = r2.join(typeof t3 == "string" ? t3 : ""))), e3 !== g ? (s2 ? !c2 && e3[t3] && (a2 = true) : delete e3[t3], a2 ? e3[t3] = i2 : pe(e3, t3, i2)) : a2 ? e3[t3] = i2 : $(t3, i2);
        })(Function.prototype, "toString", function() {
          return typeof this == "function" && t2(this).source || ye(this);
        });
      }), Oe = Math.ceil, Ie = Math.floor, Le = function(e2) {
        return isNaN(e2 = +e2) ? 0 : (e2 > 0 ? Ie : Oe)(e2);
      }, je = Math.min, _e = function(e2) {
        return e2 > 0 ? je(Le(e2), 9007199254740991) : 0;
      }, Me = Math.max, Re = Math.min, $e = function(e2) {
        return function(t2, n2, r2) {
          var i2, u2 = w(t2), o2 = _e(u2.length), s2 = function(e3, t3) {
            var n3 = Le(e3);
            return n3 < 0 ? Me(n3 + t3, 0) : Re(n3, t3);
          }(r2, o2);
          if (e2 && n2 != n2) {
            for (; o2 > s2; )
              if ((i2 = u2[s2++]) != i2)
                return true;
          } else
            for (; o2 > s2; s2++)
              if ((e2 || s2 in u2) && u2[s2] === n2)
                return e2 || s2 || 0;
          return !e2 && -1;
        };
      }, Ve = { includes: $e(true), indexOf: $e(false) }.indexOf, We = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype"), qe = { f: Object.getOwnPropertyNames || function(e2) {
        return function(e3, t2) {
          var n2, r2 = w(e3), i2 = 0, u2 = [];
          for (n2 in r2)
            !G(be, n2) && G(r2, n2) && u2.push(n2);
          for (; t2.length > i2; )
            G(r2, n2 = t2[i2++]) && (~Ve(u2, n2) || u2.push(n2));
          return u2;
        }(e2, We);
      } }, Ue = { f: Object.getOwnPropertySymbols }, ze = N("Reflect", "ownKeys") || function(e2) {
        var t2 = qe.f(ae(e2)), n2 = Ue.f;
        return n2 ? t2.concat(n2(e2)) : t2;
      }, Ge = function(e2, t2) {
        for (var n2 = ze(t2), r2 = le.f, i2 = se.f, u2 = 0; u2 < n2.length; u2++) {
          var o2 = n2[u2];
          G(e2, o2) || r2(e2, o2, i2(t2, o2));
        }
      }, He = /#|\.prototype\./, Je = function(e2, t2) {
        var n2 = Ye[Xe(e2)];
        return n2 == Qe || n2 != Ke && (typeof t2 == "function" ? m(t2) : !!t2);
      }, Xe = Je.normalize = function(e2) {
        return String(e2).replace(He, ".").toLowerCase();
      }, Ye = Je.data = {}, Ke = Je.NATIVE = "N", Qe = Je.POLYFILL = "P", Ze = Je, et = se.f, tt = function(e2, t2) {
        var n2, r2, i2, u2, o2, s2 = e2.target, a2 = e2.global, c2 = e2.stat;
        if (n2 = a2 ? g : c2 ? g[s2] || $(s2, {}) : (g[s2] || {}).prototype)
          for (r2 in t2) {
            if (u2 = t2[r2], i2 = e2.noTargetGet ? (o2 = et(n2, r2)) && o2.value : n2[r2], !Ze(a2 ? r2 : s2 + (c2 ? "." : "#") + r2, e2.forced) && i2 !== void 0) {
              if (typeof u2 == typeof i2)
                continue;
              Ge(u2, i2);
            }
            (e2.sham || i2 && i2.sham) && pe(u2, "sham", true), Pe(n2, r2, u2, e2);
          }
      }, nt = function(e2) {
        if (typeof e2 != "function")
          throw TypeError(String(e2) + " is not a function");
        return e2;
      }, rt = function(e2) {
        if (R(e2))
          throw TypeError("Cannot convert a Symbol value to a string");
        return String(e2);
      }, it = Math.floor, ut = function(e2, t2) {
        var n2 = e2.length, r2 = it(n2 / 2);
        return n2 < 8 ? ot(e2, t2) : st(ut(e2.slice(0, r2), t2), ut(e2.slice(r2), t2), t2);
      }, ot = function(e2, t2) {
        for (var n2, r2, i2 = e2.length, u2 = 1; u2 < i2; ) {
          for (r2 = u2, n2 = e2[u2]; r2 && t2(e2[r2 - 1], n2) > 0; )
            e2[r2] = e2[--r2];
          r2 !== u2++ && (e2[r2] = n2);
        }
        return e2;
      }, st = function(e2, t2, n2) {
        for (var r2 = e2.length, i2 = t2.length, u2 = 0, o2 = 0, s2 = []; u2 < r2 || o2 < i2; )
          u2 < r2 && o2 < i2 ? s2.push(n2(e2[u2], t2[o2]) <= 0 ? e2[u2++] : t2[o2++]) : s2.push(u2 < r2 ? e2[u2++] : t2[o2++]);
        return s2;
      }, at = ut, ct = k.match(/firefox\/(\d+)/i), lt = !!ct && +ct[1], pt = /MSIE|Trident/.test(k), ft = k.match(/AppleWebKit\/(\d+)\./), dt = !!ft && +ft[1], ht = [], gt = ht.sort, mt = m(function() {
        ht.sort(void 0);
      }), yt = m(function() {
        ht.sort(null);
      }), Dt = !!(Ne = []["sort"]) && m(function() {
        Ne.call(null, Be || function() {
          throw 1;
        }, 1);
      }), Et = !m(function() {
        if (j)
          return j < 70;
        if (!(lt && lt > 3)) {
          if (pt)
            return true;
          if (dt)
            return dt < 603;
          var e2, t2, n2, r2, i2 = "";
          for (e2 = 65; e2 < 76; e2++) {
            switch (t2 = String.fromCharCode(e2), e2) {
              case 66:
              case 69:
              case 70:
              case 72:
                n2 = 3;
                break;
              case 68:
              case 71:
                n2 = 4;
                break;
              default:
                n2 = 2;
            }
            for (r2 = 0; r2 < 47; r2++)
              ht.push({ k: t2 + r2, v: n2 });
          }
          for (ht.sort(function(e3, t3) {
            return t3.v - e3.v;
          }), r2 = 0; r2 < ht.length; r2++)
            t2 = ht[r2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
          return i2 !== "DGBEFHACIJK";
        }
      });
      tt({ target: "Array", proto: true, forced: mt || !yt || !Dt || !Et }, { sort: function(e2) {
        e2 !== void 0 && nt(e2);
        var t2 = U(this);
        if (Et)
          return e2 === void 0 ? gt.call(t2) : gt.call(t2, e2);
        var n2, r2, i2 = [], u2 = _e(t2.length);
        for (r2 = 0; r2 < u2; r2++)
          r2 in t2 && i2.push(t2[r2]);
        for (n2 = (i2 = at(i2, function(e3) {
          return function(t3, n3) {
            return n3 === void 0 ? -1 : t3 === void 0 ? 1 : e3 !== void 0 ? +e3(t3, n3) || 0 : rt(t3) > rt(n3) ? 1 : -1;
          };
        }(e2))).length, r2 = 0; r2 < n2; )
          t2[r2] = i2[r2++];
        for (; r2 < u2; )
          delete t2[r2++];
        return t2;
      } });
      var Ct = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.diffJson = function(e3, t3, n3) {
          return s2.diff(e3, t3, n3);
        }, t2.canonicalize = a2, t2.jsonDiff = void 0;
        var n2, r2 = (n2 = i) && n2.__esModule ? n2 : { default: n2 };
        function u2(e3) {
          return (u2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && typeof Symbol == "function" && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          })(e3);
        }
        var o2 = Object.prototype.toString, s2 = new r2.default();
        function a2(e3, t3, n3, r3, i2) {
          var s3, c2;
          for (t3 = t3 || [], n3 = n3 || [], r3 && (e3 = r3(i2, e3)), s3 = 0; s3 < t3.length; s3 += 1)
            if (t3[s3] === e3)
              return n3[s3];
          if (o2.call(e3) === "[object Array]") {
            for (t3.push(e3), c2 = new Array(e3.length), n3.push(c2), s3 = 0; s3 < e3.length; s3 += 1)
              c2[s3] = a2(e3[s3], t3, n3, r3, i2);
            return t3.pop(), n3.pop(), c2;
          }
          if (e3 && e3.toJSON && (e3 = e3.toJSON()), u2(e3) === "object" && e3 !== null) {
            t3.push(e3), c2 = {}, n3.push(c2);
            var l2, p2 = [];
            for (l2 in e3)
              e3.hasOwnProperty(l2) && p2.push(l2);
            for (p2.sort(), s3 = 0; s3 < p2.length; s3 += 1)
              c2[l2 = p2[s3]] = a2(e3[l2], t3, n3, r3, l2);
            t3.pop(), n3.pop();
          } else
            c2 = e3;
          return c2;
        }
        t2.jsonDiff = s2, s2.useLongestToken = true, s2.tokenize = p.lineDiff.tokenize, s2.castInput = function(e3) {
          var t3 = this.options, n3 = t3.undefinedReplacement, r3 = t3.stringifyReplacer, i2 = r3 === void 0 ? function(e4, t4) {
            return t4 === void 0 ? n3 : t4;
          } : r3;
          return typeof e3 == "string" ? e3 : JSON.stringify(a2(e3, null, null, i2), i2, "  ");
        }, s2.equals = function(e3, t3) {
          return r2.default.prototype.equals.call(s2, e3.replace(/,([\r\n])/g, "$1"), t3.replace(/,([\r\n])/g, "$1"));
        };
      }), bt = r(function(e2, t2) {
        var n2;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.diffArrays = function(e3, t3, n3) {
          return r2.diff(e3, t3, n3);
        }, t2.arrayDiff = void 0;
        var r2 = new ((n2 = i) && n2.__esModule ? n2 : { default: n2 }).default();
        t2.arrayDiff = r2, r2.tokenize = function(e3) {
          return e3.slice();
        }, r2.join = r2.removeEmpty = function(e3) {
          return e3;
        };
      }), At = function(e2) {
        var t2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n2 = e2.split(/\r\n|[\n\v\f\r\x85]/), r2 = e2.match(/\r\n|[\n\v\f\r\x85]/g) || [], i2 = [], u2 = 0;
        function o2() {
          var e3 = {};
          for (i2.push(e3); u2 < n2.length; ) {
            var r3 = n2[u2];
            if (/^(\-\-\-|\+\+\+|@@)\s/.test(r3))
              break;
            var o3 = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(r3);
            o3 && (e3.index = o3[1]), u2++;
          }
          for (s2(e3), s2(e3), e3.hunks = []; u2 < n2.length; ) {
            var c2 = n2[u2];
            if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(c2))
              break;
            if (/^@@/.test(c2))
              e3.hunks.push(a2());
            else {
              if (c2 && t2.strict)
                throw new Error("Unknown line " + (u2 + 1) + " " + JSON.stringify(c2));
              u2++;
            }
          }
        }
        function s2(e3) {
          var t3 = /^(---|\+\+\+)\s+(.*)$/.exec(n2[u2]);
          if (t3) {
            var r3 = t3[1] === "---" ? "old" : "new", i3 = t3[2].split("	", 2), o3 = i3[0].replace(/\\\\/g, "\\");
            /^".*"$/.test(o3) && (o3 = o3.substr(1, o3.length - 2)), e3[r3 + "FileName"] = o3, e3[r3 + "Header"] = (i3[1] || "").trim(), u2++;
          }
        }
        function a2() {
          var e3 = u2, i3 = n2[u2++].split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/), o3 = { oldStart: +i3[1], oldLines: i3[2] === void 0 ? 1 : +i3[2], newStart: +i3[3], newLines: i3[4] === void 0 ? 1 : +i3[4], lines: [], linedelimiters: [] };
          o3.oldLines === 0 && (o3.oldStart += 1), o3.newLines === 0 && (o3.newStart += 1);
          for (var s3 = 0, a3 = 0; u2 < n2.length && !(n2[u2].indexOf("--- ") === 0 && u2 + 2 < n2.length && n2[u2 + 1].indexOf("+++ ") === 0 && n2[u2 + 2].indexOf("@@") === 0); u2++) {
            var c2 = n2[u2].length == 0 && u2 != n2.length - 1 ? " " : n2[u2][0];
            if (c2 !== "+" && c2 !== "-" && c2 !== " " && c2 !== "\\")
              break;
            o3.lines.push(n2[u2]), o3.linedelimiters.push(r2[u2] || "\n"), c2 === "+" ? s3++ : c2 === "-" ? a3++ : c2 === " " && (s3++, a3++);
          }
          if (s3 || o3.newLines !== 1 || (o3.newLines = 0), a3 || o3.oldLines !== 1 || (o3.oldLines = 0), t2.strict) {
            if (s3 !== o3.newLines)
              throw new Error("Added line count did not match for hunk at line " + (e3 + 1));
            if (a3 !== o3.oldLines)
              throw new Error("Removed line count did not match for hunk at line " + (e3 + 1));
          }
          return o3;
        }
        for (; u2 < n2.length; )
          o2();
        return i2;
      };
      var vt, Ft = Object.defineProperty({ parsePatch: At }, "__esModule", { value: true }), xt = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, n2) {
          var r2 = true, i2 = false, u2 = false, o2 = 1;
          return function s2() {
            if (r2 && !u2) {
              if (i2 ? o2++ : r2 = false, e3 + o2 <= n2)
                return o2;
              u2 = true;
            }
            if (!i2)
              return u2 || (r2 = true), t3 <= e3 - o2 ? -o2++ : (i2 = true, s2());
          };
        };
      }), St = Bt, wt = function(e2, t2) {
        typeof e2 == "string" && (e2 = (0, Ft.parsePatch)(e2));
        var n2 = 0;
        !function r2() {
          var i2 = e2[n2++];
          if (!i2)
            return t2.complete();
          t2.loadFile(i2, function(e3, n3) {
            if (e3)
              return t2.complete(e3);
            var u2 = Bt(n3, i2, t2);
            t2.patched(i2, u2, function(e4) {
              if (e4)
                return t2.complete(e4);
              r2();
            });
          });
        }();
      }, Tt = (vt = xt) && vt.__esModule ? vt : { default: vt };
      function Bt(e2, t2) {
        var n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (typeof t2 == "string" && (t2 = (0, Ft.parsePatch)(t2)), Array.isArray(t2)) {
          if (t2.length > 1)
            throw new Error("applyPatch only works with a single input.");
          t2 = t2[0];
        }
        var r2, i2, u2 = e2.split(/\r\n|[\n\v\f\r\x85]/), o2 = e2.match(/\r\n|[\n\v\f\r\x85]/g) || [], s2 = t2.hunks, a2 = n2.compareLine || function(e3, t3, n3, r3) {
          return t3 === r3;
        }, c2 = 0, l2 = n2.fuzzFactor || 0, p2 = 0, f2 = 0;
        function d2(e3, t3) {
          for (var n3 = 0; n3 < e3.lines.length; n3++) {
            var r3 = e3.lines[n3], i3 = r3.length > 0 ? r3[0] : " ", o3 = r3.length > 0 ? r3.substr(1) : r3;
            if (i3 === " " || i3 === "-") {
              if (!a2(t3 + 1, u2[t3], i3, o3) && ++c2 > l2)
                return false;
              t3++;
            }
          }
          return true;
        }
        for (var h2 = 0; h2 < s2.length; h2++) {
          for (var g2 = s2[h2], m2 = u2.length - g2.oldLines, y2 = 0, D2 = f2 + g2.oldStart - 1, E2 = (0, Tt.default)(D2, p2, m2); y2 !== void 0; y2 = E2())
            if (d2(g2, D2 + y2)) {
              g2.offset = f2 += y2;
              break;
            }
          if (y2 === void 0)
            return false;
          p2 = g2.offset + g2.oldStart + g2.oldLines;
        }
        for (var C2 = 0, b2 = 0; b2 < s2.length; b2++) {
          var A2 = s2[b2], v2 = A2.oldStart + A2.offset + C2 - 1;
          C2 += A2.newLines - A2.oldLines;
          for (var F2 = 0; F2 < A2.lines.length; F2++) {
            var x2 = A2.lines[F2], S2 = x2.length > 0 ? x2[0] : " ", w2 = x2.length > 0 ? x2.substr(1) : x2, T2 = A2.linedelimiters[F2];
            if (S2 === " ")
              v2++;
            else if (S2 === "-")
              u2.splice(v2, 1), o2.splice(v2, 1);
            else if (S2 === "+")
              u2.splice(v2, 0, w2), o2.splice(v2, 0, T2), v2++;
            else if (S2 === "\\") {
              var B2 = A2.lines[F2 - 1] ? A2.lines[F2 - 1][0] : null;
              B2 === "+" ? r2 = true : B2 === "-" && (i2 = true);
            }
          }
        }
        if (r2)
          for (; !u2[u2.length - 1]; )
            u2.pop(), o2.pop();
        else
          i2 && (u2.push(""), o2.push("\n"));
        for (var N2 = 0; N2 < u2.length - 1; N2++)
          u2[N2] = u2[N2] + o2[N2];
        return u2.join("");
      }
      var Nt = Object.defineProperty({ applyPatch: St, applyPatches: wt }, "__esModule", { value: true }), kt = _t, Pt = Mt, Ot = Rt, It = function(e2, t2, n2, r2, i2, u2) {
        return Rt(e2, e2, t2, n2, r2, i2, u2);
      };
      function Lt(e2) {
        return function(e3) {
          if (Array.isArray(e3))
            return jt(e3);
        }(e2) || function(e3) {
          if (typeof Symbol != "undefined" && Symbol.iterator in Object(e3))
            return Array.from(e3);
        }(e2) || function(e3, t2) {
          if (!e3)
            return;
          if (typeof e3 == "string")
            return jt(e3, t2);
          var n2 = Object.prototype.toString.call(e3).slice(8, -1);
          n2 === "Object" && e3.constructor && (n2 = e3.constructor.name);
          if (n2 === "Map" || n2 === "Set")
            return Array.from(e3);
          if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
            return jt(e3, t2);
        }(e2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function jt(e2, t2) {
        (t2 == null || t2 > e2.length) && (t2 = e2.length);
        for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++)
          r2[n2] = e2[n2];
        return r2;
      }
      function _t(e2, t2, n2, r2, i2, u2, o2) {
        o2 || (o2 = {}), o2.context === void 0 && (o2.context = 4);
        var s2 = (0, p.diffLines)(n2, r2, o2);
        function a2(e3) {
          return e3.map(function(e4) {
            return " " + e4;
          });
        }
        s2.push({ value: "", lines: [] });
        for (var c2 = [], l2 = 0, f2 = 0, d2 = [], h2 = 1, g2 = 1, m2 = function(e3) {
          var t3 = s2[e3], i3 = t3.lines || t3.value.replace(/\n$/, "").split("\n");
          if (t3.lines = i3, t3.added || t3.removed) {
            var u3;
            if (!l2) {
              var p2 = s2[e3 - 1];
              l2 = h2, f2 = g2, p2 && (d2 = o2.context > 0 ? a2(p2.lines.slice(-o2.context)) : [], l2 -= d2.length, f2 -= d2.length);
            }
            (u3 = d2).push.apply(u3, Lt(i3.map(function(e4) {
              return (t3.added ? "+" : "-") + e4;
            }))), t3.added ? g2 += i3.length : h2 += i3.length;
          } else {
            if (l2)
              if (i3.length <= 2 * o2.context && e3 < s2.length - 2) {
                var m3;
                (m3 = d2).push.apply(m3, Lt(a2(i3)));
              } else {
                var y3, D2 = Math.min(i3.length, o2.context);
                (y3 = d2).push.apply(y3, Lt(a2(i3.slice(0, D2))));
                var E2 = { oldStart: l2, oldLines: h2 - l2 + D2, newStart: f2, newLines: g2 - f2 + D2, lines: d2 };
                if (e3 >= s2.length - 2 && i3.length <= o2.context) {
                  var C2 = /\n$/.test(n2), b2 = /\n$/.test(r2), A2 = i3.length == 0 && d2.length > E2.oldLines;
                  !C2 && A2 && n2.length > 0 && d2.splice(E2.oldLines, 0, "\\ No newline at end of file"), (C2 || A2) && b2 || d2.push("\\ No newline at end of file");
                }
                c2.push(E2), l2 = 0, f2 = 0, d2 = [];
              }
            h2 += i3.length, g2 += i3.length;
          }
        }, y2 = 0; y2 < s2.length; y2++)
          m2(y2);
        return { oldFileName: e2, newFileName: t2, oldHeader: i2, newHeader: u2, hunks: c2 };
      }
      function Mt(e2) {
        var t2 = [];
        e2.oldFileName == e2.newFileName && t2.push("Index: " + e2.oldFileName), t2.push("==================================================================="), t2.push("--- " + e2.oldFileName + (e2.oldHeader === void 0 ? "" : "	" + e2.oldHeader)), t2.push("+++ " + e2.newFileName + (e2.newHeader === void 0 ? "" : "	" + e2.newHeader));
        for (var n2 = 0; n2 < e2.hunks.length; n2++) {
          var r2 = e2.hunks[n2];
          r2.oldLines === 0 && (r2.oldStart -= 1), r2.newLines === 0 && (r2.newStart -= 1), t2.push("@@ -" + r2.oldStart + "," + r2.oldLines + " +" + r2.newStart + "," + r2.newLines + " @@"), t2.push.apply(t2, r2.lines);
        }
        return t2.join("\n") + "\n";
      }
      function Rt(e2, t2, n2, r2, i2, u2, o2) {
        return Mt(_t(e2, t2, n2, r2, i2, u2, o2));
      }
      var $t = Object.defineProperty({ structuredPatch: kt, formatPatch: Pt, createTwoFilesPatch: Ot, createPatch: It }, "__esModule", { value: true }), Vt = function(e2, t2) {
        if (e2.length !== t2.length)
          return false;
        return qt(e2, t2);
      }, Wt = qt;
      function qt(e2, t2) {
        if (t2.length > e2.length)
          return false;
        for (var n2 = 0; n2 < t2.length; n2++)
          if (t2[n2] !== e2[n2])
            return false;
        return true;
      }
      var Ut = Object.defineProperty({ arrayEqual: Vt, arrayStartsWith: Wt }, "__esModule", { value: true }), zt = Xt, Gt = function(e2, t2, n2) {
        e2 = Yt(e2, n2), t2 = Yt(t2, n2);
        var r2 = {};
        (e2.index || t2.index) && (r2.index = e2.index || t2.index);
        (e2.newFileName || t2.newFileName) && (Kt(e2) ? Kt(t2) ? (r2.oldFileName = Qt(r2, e2.oldFileName, t2.oldFileName), r2.newFileName = Qt(r2, e2.newFileName, t2.newFileName), r2.oldHeader = Qt(r2, e2.oldHeader, t2.oldHeader), r2.newHeader = Qt(r2, e2.newHeader, t2.newHeader)) : (r2.oldFileName = e2.oldFileName, r2.newFileName = e2.newFileName, r2.oldHeader = e2.oldHeader, r2.newHeader = e2.newHeader) : (r2.oldFileName = t2.oldFileName || e2.oldFileName, r2.newFileName = t2.newFileName || e2.newFileName, r2.oldHeader = t2.oldHeader || e2.oldHeader, r2.newHeader = t2.newHeader || e2.newHeader));
        r2.hunks = [];
        var i2 = 0, u2 = 0, o2 = 0, s2 = 0;
        for (; i2 < e2.hunks.length || u2 < t2.hunks.length; ) {
          var a2 = e2.hunks[i2] || { oldStart: 1 / 0 }, c2 = t2.hunks[u2] || { oldStart: 1 / 0 };
          if (Zt(a2, c2))
            r2.hunks.push(en(a2, o2)), i2++, s2 += a2.newLines - a2.oldLines;
          else if (Zt(c2, a2))
            r2.hunks.push(en(c2, s2)), u2++, o2 += c2.newLines - c2.oldLines;
          else {
            var l2 = { oldStart: Math.min(a2.oldStart, c2.oldStart), oldLines: 0, newStart: Math.min(a2.newStart + o2, c2.oldStart + s2), newLines: 0, lines: [] };
            tn(l2, a2.oldStart, a2.lines, c2.oldStart, c2.lines), u2++, i2++, r2.hunks.push(l2);
          }
        }
        return r2;
      };
      function Ht(e2) {
        return function(e3) {
          if (Array.isArray(e3))
            return Jt(e3);
        }(e2) || function(e3) {
          if (typeof Symbol != "undefined" && Symbol.iterator in Object(e3))
            return Array.from(e3);
        }(e2) || function(e3, t2) {
          if (!e3)
            return;
          if (typeof e3 == "string")
            return Jt(e3, t2);
          var n2 = Object.prototype.toString.call(e3).slice(8, -1);
          n2 === "Object" && e3.constructor && (n2 = e3.constructor.name);
          if (n2 === "Map" || n2 === "Set")
            return Array.from(e3);
          if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
            return Jt(e3, t2);
        }(e2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function Jt(e2, t2) {
        (t2 == null || t2 > e2.length) && (t2 = e2.length);
        for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++)
          r2[n2] = e2[n2];
        return r2;
      }
      function Xt(e2) {
        var t2 = pn(e2.lines), n2 = t2.oldLines, r2 = t2.newLines;
        n2 !== void 0 ? e2.oldLines = n2 : delete e2.oldLines, r2 !== void 0 ? e2.newLines = r2 : delete e2.newLines;
      }
      function Yt(e2, t2) {
        if (typeof e2 == "string") {
          if (/^@@/m.test(e2) || /^Index:/m.test(e2))
            return (0, Ft.parsePatch)(e2)[0];
          if (!t2)
            throw new Error("Must provide a base reference or pass in a patch");
          return (0, $t.structuredPatch)(void 0, void 0, t2, e2);
        }
        return e2;
      }
      function Kt(e2) {
        return e2.newFileName && e2.newFileName !== e2.oldFileName;
      }
      function Qt(e2, t2, n2) {
        return t2 === n2 ? t2 : (e2.conflict = true, { mine: t2, theirs: n2 });
      }
      function Zt(e2, t2) {
        return e2.oldStart < t2.oldStart && e2.oldStart + e2.oldLines < t2.oldStart;
      }
      function en(e2, t2) {
        return { oldStart: e2.oldStart, oldLines: e2.oldLines, newStart: e2.newStart + t2, newLines: e2.newLines, lines: e2.lines };
      }
      function tn(e2, t2, n2, r2, i2) {
        var u2 = { offset: t2, lines: n2, index: 0 }, o2 = { offset: r2, lines: i2, index: 0 };
        for (on(e2, u2, o2), on(e2, o2, u2); u2.index < u2.lines.length && o2.index < o2.lines.length; ) {
          var s2 = u2.lines[u2.index], a2 = o2.lines[o2.index];
          if (s2[0] !== "-" && s2[0] !== "+" || a2[0] !== "-" && a2[0] !== "+")
            if (s2[0] === "+" && a2[0] === " ") {
              var c2;
              (c2 = e2.lines).push.apply(c2, Ht(an(u2)));
            } else if (a2[0] === "+" && s2[0] === " ") {
              var l2;
              (l2 = e2.lines).push.apply(l2, Ht(an(o2)));
            } else
              s2[0] === "-" && a2[0] === " " ? rn(e2, u2, o2) : a2[0] === "-" && s2[0] === " " ? rn(e2, o2, u2, true) : s2 === a2 ? (e2.lines.push(s2), u2.index++, o2.index++) : un(e2, an(u2), an(o2));
          else
            nn(e2, u2, o2);
        }
        sn(e2, u2), sn(e2, o2), Xt(e2);
      }
      function nn(e2, t2, n2) {
        var r2 = an(t2), i2 = an(n2);
        if (cn(r2) && cn(i2)) {
          var u2, o2;
          if ((0, Ut.arrayStartsWith)(r2, i2) && ln(n2, r2, r2.length - i2.length))
            return void (u2 = e2.lines).push.apply(u2, Ht(r2));
          if ((0, Ut.arrayStartsWith)(i2, r2) && ln(t2, i2, i2.length - r2.length))
            return void (o2 = e2.lines).push.apply(o2, Ht(i2));
        } else if ((0, Ut.arrayEqual)(r2, i2)) {
          var s2;
          return void (s2 = e2.lines).push.apply(s2, Ht(r2));
        }
        un(e2, r2, i2);
      }
      function rn(e2, t2, n2, r2) {
        var i2, u2 = an(t2), o2 = function(e3, t3) {
          var n3 = [], r3 = [], i3 = 0, u3 = false, o3 = false;
          for (; i3 < t3.length && e3.index < e3.lines.length; ) {
            var s2 = e3.lines[e3.index], a2 = t3[i3];
            if (a2[0] === "+")
              break;
            if (u3 = u3 || s2[0] !== " ", r3.push(a2), i3++, s2[0] === "+")
              for (o3 = true; s2[0] === "+"; )
                n3.push(s2), s2 = e3.lines[++e3.index];
            a2.substr(1) === s2.substr(1) ? (n3.push(s2), e3.index++) : o3 = true;
          }
          (t3[i3] || "")[0] === "+" && u3 && (o3 = true);
          if (o3)
            return n3;
          for (; i3 < t3.length; )
            r3.push(t3[i3++]);
          return { merged: r3, changes: n3 };
        }(n2, u2);
        o2.merged ? (i2 = e2.lines).push.apply(i2, Ht(o2.merged)) : un(e2, r2 ? o2 : u2, r2 ? u2 : o2);
      }
      function un(e2, t2, n2) {
        e2.conflict = true, e2.lines.push({ conflict: true, mine: t2, theirs: n2 });
      }
      function on(e2, t2, n2) {
        for (; t2.offset < n2.offset && t2.index < t2.lines.length; ) {
          var r2 = t2.lines[t2.index++];
          e2.lines.push(r2), t2.offset++;
        }
      }
      function sn(e2, t2) {
        for (; t2.index < t2.lines.length; ) {
          var n2 = t2.lines[t2.index++];
          e2.lines.push(n2);
        }
      }
      function an(e2) {
        for (var t2 = [], n2 = e2.lines[e2.index][0]; e2.index < e2.lines.length; ) {
          var r2 = e2.lines[e2.index];
          if (n2 === "-" && r2[0] === "+" && (n2 = "+"), n2 !== r2[0])
            break;
          t2.push(r2), e2.index++;
        }
        return t2;
      }
      function cn(e2) {
        return e2.reduce(function(e3, t2) {
          return e3 && t2[0] === "-";
        }, true);
      }
      function ln(e2, t2, n2) {
        for (var r2 = 0; r2 < n2; r2++) {
          var i2 = t2[t2.length - n2 + r2].substr(1);
          if (e2.lines[e2.index + r2] !== " " + i2)
            return false;
        }
        return e2.index += n2, true;
      }
      function pn(e2) {
        var t2 = 0, n2 = 0;
        return e2.forEach(function(e3) {
          if (typeof e3 != "string") {
            var r2 = pn(e3.mine), i2 = pn(e3.theirs);
            t2 !== void 0 && (r2.oldLines === i2.oldLines ? t2 += r2.oldLines : t2 = void 0), n2 !== void 0 && (r2.newLines === i2.newLines ? n2 += r2.newLines : n2 = void 0);
          } else
            n2 === void 0 || e3[0] !== "+" && e3[0] !== " " || n2++, t2 === void 0 || e3[0] !== "-" && e3[0] !== " " || t2++;
        }), { oldLines: t2, newLines: n2 };
      }
      var fn = Object.defineProperty({ calcLineCount: zt, merge: Gt }, "__esModule", { value: true }), dn = function(e2) {
        for (var t2, n2, r2 = [], i2 = 0; i2 < e2.length; i2++)
          t2 = e2[i2], n2 = t2.added ? 1 : t2.removed ? -1 : 0, r2.push([n2, t2.value]);
        return r2;
      };
      var hn = Object.defineProperty({ convertChangesToDMP: dn }, "__esModule", { value: true }), gn = function(e2) {
        for (var t2 = [], n2 = 0; n2 < e2.length; n2++) {
          var r2 = e2[n2];
          r2.added ? t2.push("<ins>") : r2.removed && t2.push("<del>"), t2.push(mn(r2.value)), r2.added ? t2.push("</ins>") : r2.removed && t2.push("</del>");
        }
        return t2.join("");
      };
      function mn(e2) {
        var t2 = e2;
        return t2 = (t2 = (t2 = (t2 = t2.replace(/&/g, "&amp;")).replace(/</g, "&lt;")).replace(/>/g, "&gt;")).replace(/"/g, "&quot;");
      }
      var yn = Object.defineProperty({ convertChangesToXML: gn }, "__esModule", { value: true }), Dn = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "Diff", { enumerable: true, get: function() {
          return n2.default;
        } }), Object.defineProperty(t2, "diffChars", { enumerable: true, get: function() {
          return u.diffChars;
        } }), Object.defineProperty(t2, "diffWords", { enumerable: true, get: function() {
          return l.diffWords;
        } }), Object.defineProperty(t2, "diffWordsWithSpace", { enumerable: true, get: function() {
          return l.diffWordsWithSpace;
        } }), Object.defineProperty(t2, "diffLines", { enumerable: true, get: function() {
          return p.diffLines;
        } }), Object.defineProperty(t2, "diffTrimmedLines", { enumerable: true, get: function() {
          return p.diffTrimmedLines;
        } }), Object.defineProperty(t2, "diffSentences", { enumerable: true, get: function() {
          return f.diffSentences;
        } }), Object.defineProperty(t2, "diffCss", { enumerable: true, get: function() {
          return d.diffCss;
        } }), Object.defineProperty(t2, "diffJson", { enumerable: true, get: function() {
          return Ct.diffJson;
        } }), Object.defineProperty(t2, "canonicalize", { enumerable: true, get: function() {
          return Ct.canonicalize;
        } }), Object.defineProperty(t2, "diffArrays", { enumerable: true, get: function() {
          return bt.diffArrays;
        } }), Object.defineProperty(t2, "applyPatch", { enumerable: true, get: function() {
          return Nt.applyPatch;
        } }), Object.defineProperty(t2, "applyPatches", { enumerable: true, get: function() {
          return Nt.applyPatches;
        } }), Object.defineProperty(t2, "parsePatch", { enumerable: true, get: function() {
          return Ft.parsePatch;
        } }), Object.defineProperty(t2, "merge", { enumerable: true, get: function() {
          return fn.merge;
        } }), Object.defineProperty(t2, "structuredPatch", { enumerable: true, get: function() {
          return $t.structuredPatch;
        } }), Object.defineProperty(t2, "createTwoFilesPatch", { enumerable: true, get: function() {
          return $t.createTwoFilesPatch;
        } }), Object.defineProperty(t2, "createPatch", { enumerable: true, get: function() {
          return $t.createPatch;
        } }), Object.defineProperty(t2, "convertChangesToDMP", { enumerable: true, get: function() {
          return hn.convertChangesToDMP;
        } }), Object.defineProperty(t2, "convertChangesToXML", { enumerable: true, get: function() {
          return yn.convertChangesToXML;
        } });
        var n2 = function(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }(i);
      });
      function En(e2) {
        return { type: "concat", parts: e2 };
      }
      function Cn(e2) {
        return { type: "indent", contents: e2 };
      }
      function bn(e2, t2) {
        return { type: "align", contents: t2, n: e2 };
      }
      function An(e2, t2 = {}) {
        return { type: "group", id: t2.id, contents: e2, break: Boolean(t2.shouldBreak), expandedStates: t2.expandedStates };
      }
      const vn = { type: "break-parent" }, Fn = { type: "line", hard: true }, xn = { type: "line", hard: true, literal: true }, Sn = En([Fn, vn]), wn = En([xn, vn]);
      var Tn = { concat: En, join: function(e2, t2) {
        const n2 = [];
        for (let r2 = 0; r2 < t2.length; r2++)
          r2 !== 0 && n2.push(e2), n2.push(t2[r2]);
        return En(n2);
      }, line: { type: "line" }, softline: { type: "line", soft: true }, hardline: Sn, literalline: wn, group: An, conditionalGroup: function(e2, t2) {
        return An(e2[0], Object.assign(Object.assign({}, t2), {}, { expandedStates: e2 }));
      }, fill: function(e2) {
        return { type: "fill", parts: e2 };
      }, lineSuffix: function(e2) {
        return { type: "line-suffix", contents: e2 };
      }, lineSuffixBoundary: { type: "line-suffix-boundary" }, cursor: { type: "cursor", placeholder: Symbol("cursor") }, breakParent: vn, ifBreak: function(e2, t2, n2 = {}) {
        return { type: "if-break", breakContents: e2, flatContents: t2, groupId: n2.groupId };
      }, trim: { type: "trim" }, indent: Cn, indentIfBreak: function(e2, t2) {
        return { type: "indent-if-break", contents: e2, groupId: t2.groupId, negate: t2.negate };
      }, align: bn, addAlignmentToDoc: function(e2, t2, n2) {
        let r2 = e2;
        if (t2 > 0) {
          for (let e3 = 0; e3 < Math.floor(t2 / n2); ++e3)
            r2 = Cn(r2);
          r2 = bn(t2 % n2, r2), r2 = bn(Number.NEGATIVE_INFINITY, r2);
        }
        return r2;
      }, markAsRoot: function(e2) {
        return bn({ type: "root" }, e2);
      }, dedentToRoot: function(e2) {
        return bn(Number.NEGATIVE_INFINITY, e2);
      }, dedent: function(e2) {
        return bn(-1, e2);
      }, hardlineWithoutBreakParent: Fn, literallineWithoutBreakParent: xn, label: function(e2, t2) {
        return { type: "label", label: e2, contents: t2 };
      } }, Bn = (e2) => typeof e2 == "string" ? e2.replace((({ onlyFirst: e3 = false } = {}) => {
        const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
        return new RegExp(t2, e3 ? void 0 : "g");
      })(), "") : e2;
      const Nn = (e2) => !Number.isNaN(e2) && (e2 >= 4352 && (e2 <= 4447 || e2 === 9001 || e2 === 9002 || 11904 <= e2 && e2 <= 12871 && e2 !== 12351 || 12880 <= e2 && e2 <= 19903 || 19968 <= e2 && e2 <= 42182 || 43360 <= e2 && e2 <= 43388 || 44032 <= e2 && e2 <= 55203 || 63744 <= e2 && e2 <= 64255 || 65040 <= e2 && e2 <= 65049 || 65072 <= e2 && e2 <= 65131 || 65281 <= e2 && e2 <= 65376 || 65504 <= e2 && e2 <= 65510 || 110592 <= e2 && e2 <= 110593 || 127488 <= e2 && e2 <= 127569 || 131072 <= e2 && e2 <= 262141));
      var kn = Nn, Pn = Nn;
      kn.default = Pn;
      const On = (e2) => {
        if (typeof e2 != "string" || e2.length === 0)
          return 0;
        if ((e2 = Bn(e2)).length === 0)
          return 0;
        e2 = e2.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
        let t2 = 0;
        for (let n2 = 0; n2 < e2.length; n2++) {
          const r2 = e2.codePointAt(n2);
          r2 <= 31 || r2 >= 127 && r2 <= 159 || (r2 >= 768 && r2 <= 879 || (r2 > 65535 && n2++, t2 += kn(r2) ? 2 : 1));
        }
        return t2;
      };
      var In = On, Ln = On;
      In.default = Ln;
      var jn = (e2) => {
        if (typeof e2 != "string")
          throw new TypeError("Expected a string");
        return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      };
      var _n = (e2) => e2[e2.length - 1];
      function Mn(e2, t2) {
        if (e2 == null)
          return {};
        var n2, r2, i2 = function(e3, t3) {
          if (e3 == null)
            return {};
          var n3, r3, i3 = {}, u3 = Object.keys(e3);
          for (r3 = 0; r3 < u3.length; r3++)
            n3 = u3[r3], t3.indexOf(n3) >= 0 || (i3[n3] = e3[n3]);
          return i3;
        }(e2, t2);
        if (Object.getOwnPropertySymbols) {
          var u2 = Object.getOwnPropertySymbols(e2);
          for (r2 = 0; r2 < u2.length; r2++)
            n2 = u2[r2], t2.indexOf(n2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, n2) && (i2[n2] = e2[n2]);
        }
        return i2;
      }
      var Rn = Array.isArray || function(e2) {
        return v(e2) == "Array";
      }, $n = function(e2, t2, n2) {
        if (nt(e2), t2 === void 0)
          return e2;
        switch (n2) {
          case 0:
            return function() {
              return e2.call(t2);
            };
          case 1:
            return function(n3) {
              return e2.call(t2, n3);
            };
          case 2:
            return function(n3, r2) {
              return e2.call(t2, n3, r2);
            };
          case 3:
            return function(n3, r2, i2) {
              return e2.call(t2, n3, r2, i2);
            };
        }
        return function() {
          return e2.apply(t2, arguments);
        };
      }, Vn = function(e2, t2, n2, r2, i2, u2, o2, s2) {
        for (var a2, c2 = i2, l2 = 0, p2 = !!o2 && $n(o2, s2, 3); l2 < r2; ) {
          if (l2 in n2) {
            if (a2 = p2 ? p2(n2[l2], l2, t2) : n2[l2], u2 > 0 && Rn(a2))
              c2 = Vn(e2, t2, a2, _e(a2.length), c2, u2 - 1) - 1;
            else {
              if (c2 >= 9007199254740991)
                throw TypeError("Exceed the acceptable array length");
              e2[c2] = a2;
            }
            c2++;
          }
          l2++;
        }
        return c2;
      }, Wn = Vn, qn = Z("species"), Un = function(e2, t2) {
        return new (function(e3) {
          var t3;
          return Rn(e3) && (typeof (t3 = e3.constructor) != "function" || t3 !== Array && !Rn(t3.prototype) ? T(t3) && (t3 = t3[qn]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
        }(e2))(t2 === 0 ? 0 : t2);
      };
      tt({ target: "Array", proto: true }, { flatMap: function(e2) {
        var t2, n2 = U(this), r2 = _e(n2.length);
        return nt(e2), (t2 = Un(n2, 0)).length = Wn(t2, n2, n2, r2, 0, 1, e2, arguments.length > 1 ? arguments[1] : void 0), t2;
      } });
      var zn = {}, Gn = Z("iterator"), Hn = Array.prototype, Jn = {};
      Jn[Z("toStringTag")] = "z";
      var Xn = String(Jn) === "[object z]", Yn = Z("toStringTag"), Kn = v(function() {
        return arguments;
      }()) == "Arguments", Qn = Xn ? v : function(e2) {
        var t2, n2, r2;
        return e2 === void 0 ? "Undefined" : e2 === null ? "Null" : typeof (n2 = function(e3, t3) {
          try {
            return e3[t3];
          } catch (e4) {
          }
        }(t2 = Object(e2), Yn)) == "string" ? n2 : Kn ? v(t2) : (r2 = v(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : r2;
      }, Zn = Z("iterator"), er = function(e2) {
        if (e2 != null)
          return e2[Zn] || e2["@@iterator"] || zn[Qn(e2)];
      }, tr = function(e2, t2, n2) {
        var r2, i2;
        ae(e2);
        try {
          if ((r2 = e2.return) === void 0) {
            if (t2 === "throw")
              throw n2;
            return n2;
          }
          r2 = r2.call(e2);
        } catch (e3) {
          i2 = true, r2 = e3;
        }
        if (t2 === "throw")
          throw n2;
        if (i2)
          throw r2;
        return ae(r2), n2;
      }, nr = function(e2, t2) {
        this.stopped = e2, this.result = t2;
      }, rr = function(e2, t2, n2) {
        var r2, i2, u2, o2, s2, a2, c2, l2, p2 = n2 && n2.that, f2 = !(!n2 || !n2.AS_ENTRIES), d2 = !(!n2 || !n2.IS_ITERATOR), h2 = !(!n2 || !n2.INTERRUPTED), g2 = $n(t2, p2, 1 + f2 + h2), m2 = function(e3) {
          return r2 && tr(r2, "normal", e3), new nr(true, e3);
        }, y2 = function(e3) {
          return f2 ? (ae(e3), h2 ? g2(e3[0], e3[1], m2) : g2(e3[0], e3[1])) : h2 ? g2(e3, m2) : g2(e3);
        };
        if (d2)
          r2 = e2;
        else {
          if (typeof (i2 = er(e2)) != "function")
            throw TypeError("Target is not iterable");
          if ((l2 = i2) !== void 0 && (zn.Array === l2 || Hn[Gn] === l2)) {
            for (u2 = 0, o2 = _e(e2.length); o2 > u2; u2++)
              if ((s2 = y2(e2[u2])) && s2 instanceof nr)
                return s2;
            return new nr(false);
          }
          r2 = function(e3, t3) {
            var n3 = arguments.length < 2 ? er(e3) : t3;
            if (typeof n3 != "function")
              throw TypeError(String(e3) + " is not iterable");
            return ae(n3.call(e3));
          }(e2, i2);
        }
        for (a2 = r2.next; !(c2 = a2.call(r2)).done; ) {
          try {
            s2 = y2(c2.value);
          } catch (e3) {
            tr(r2, "throw", e3);
          }
          if (typeof s2 == "object" && s2 && s2 instanceof nr)
            return s2;
        }
        return new nr(false);
      };
      tt({ target: "Object", stat: true }, { fromEntries: function(e2) {
        var t2 = {};
        return rr(e2, function(e3, n2) {
          !function(e4, t3, n3) {
            var r2 = ne(t3);
            r2 in e4 ? le.f(e4, r2, b(0, n3)) : e4[r2] = n3;
          }(t2, e3, n2);
        }, { AS_ENTRIES: true }), t2;
      } });
      var ir = ir !== void 0 ? ir : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
      function ur() {
        throw new Error("setTimeout has not been defined");
      }
      function or() {
        throw new Error("clearTimeout has not been defined");
      }
      var sr = ur, ar = or;
      function cr(e2) {
        if (sr === setTimeout)
          return setTimeout(e2, 0);
        if ((sr === ur || !sr) && setTimeout)
          return sr = setTimeout, setTimeout(e2, 0);
        try {
          return sr(e2, 0);
        } catch (t2) {
          try {
            return sr.call(null, e2, 0);
          } catch (t3) {
            return sr.call(this, e2, 0);
          }
        }
      }
      typeof ir.setTimeout == "function" && (sr = setTimeout), typeof ir.clearTimeout == "function" && (ar = clearTimeout);
      var lr, pr = [], fr = false, dr = -1;
      function hr() {
        fr && lr && (fr = false, lr.length ? pr = lr.concat(pr) : dr = -1, pr.length && gr());
      }
      function gr() {
        if (!fr) {
          var e2 = cr(hr);
          fr = true;
          for (var t2 = pr.length; t2; ) {
            for (lr = pr, pr = []; ++dr < t2; )
              lr && lr[dr].run();
            dr = -1, t2 = pr.length;
          }
          lr = null, fr = false, function(e3) {
            if (ar === clearTimeout)
              return clearTimeout(e3);
            if ((ar === or || !ar) && clearTimeout)
              return ar = clearTimeout, clearTimeout(e3);
            try {
              ar(e3);
            } catch (t3) {
              try {
                return ar.call(null, e3);
              } catch (t4) {
                return ar.call(this, e3);
              }
            }
          }(e2);
        }
      }
      function mr(e2, t2) {
        this.fun = e2, this.array = t2;
      }
      mr.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      function yr() {
      }
      var Dr = yr, Er = yr, Cr = yr, br = yr, Ar = yr, vr = yr, Fr = yr;
      var xr = ir.performance || {}, Sr = xr.now || xr.mozNow || xr.msNow || xr.oNow || xr.webkitNow || function() {
        return new Date().getTime();
      };
      var wr = new Date();
      var Tr = { nextTick: function(e2) {
        var t2 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n2 = 1; n2 < arguments.length; n2++)
            t2[n2 - 1] = arguments[n2];
        pr.push(new mr(e2, t2)), pr.length !== 1 || fr || cr(gr);
      }, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: Dr, addListener: Er, once: Cr, off: br, removeListener: Ar, removeAllListeners: vr, emit: Fr, binding: function(e2) {
        throw new Error("process.binding is not supported");
      }, cwd: function() {
        return "/";
      }, chdir: function(e2) {
        throw new Error("process.chdir is not supported");
      }, umask: function() {
        return 0;
      }, hrtime: function(e2) {
        var t2 = 1e-3 * Sr.call(xr), n2 = Math.floor(t2), r2 = Math.floor(t2 % 1 * 1e9);
        return e2 && (n2 -= e2[0], (r2 -= e2[1]) < 0 && (n2--, r2 += 1e9)), [n2, r2];
      }, platform: "browser", release: {}, config: {}, uptime: function() {
        return (new Date() - wr) / 1e3;
      } };
      var Br = typeof Tr == "object" && Tr.env && Tr.env.NODE_DEBUG && /\bsemver\b/i.test(Tr.env.NODE_DEBUG) ? (...e2) => console.error("SEMVER", ...e2) : () => {
      };
      var Nr = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 }, kr = r(function(e2, t2) {
        const { MAX_SAFE_COMPONENT_LENGTH: n2 } = Nr, r2 = (t2 = e2.exports = {}).re = [], i2 = t2.src = [], u2 = t2.t = {};
        let o2 = 0;
        const s2 = (e3, t3, n3) => {
          const s3 = o2++;
          Br(s3, t3), u2[e3] = s3, i2[s3] = t3, r2[s3] = new RegExp(t3, n3 ? "g" : void 0);
        };
        s2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), s2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), s2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), s2("MAINVERSION", `(${i2[u2.NUMERICIDENTIFIER]})\\.(${i2[u2.NUMERICIDENTIFIER]})\\.(${i2[u2.NUMERICIDENTIFIER]})`), s2("MAINVERSIONLOOSE", `(${i2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[u2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[u2.NUMERICIDENTIFIERLOOSE]})`), s2("PRERELEASEIDENTIFIER", `(?:${i2[u2.NUMERICIDENTIFIER]}|${i2[u2.NONNUMERICIDENTIFIER]})`), s2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[u2.NUMERICIDENTIFIERLOOSE]}|${i2[u2.NONNUMERICIDENTIFIER]})`), s2("PRERELEASE", `(?:-(${i2[u2.PRERELEASEIDENTIFIER]}(?:\\.${i2[u2.PRERELEASEIDENTIFIER]})*))`), s2("PRERELEASELOOSE", `(?:-?(${i2[u2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[u2.PRERELEASEIDENTIFIERLOOSE]})*))`), s2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), s2("BUILD", `(?:\\+(${i2[u2.BUILDIDENTIFIER]}(?:\\.${i2[u2.BUILDIDENTIFIER]})*))`), s2("FULLPLAIN", `v?${i2[u2.MAINVERSION]}${i2[u2.PRERELEASE]}?${i2[u2.BUILD]}?`), s2("FULL", `^${i2[u2.FULLPLAIN]}$`), s2("LOOSEPLAIN", `[v=\\s]*${i2[u2.MAINVERSIONLOOSE]}${i2[u2.PRERELEASELOOSE]}?${i2[u2.BUILD]}?`), s2("LOOSE", `^${i2[u2.LOOSEPLAIN]}$`), s2("GTLT", "((?:<|>)?=?)"), s2("XRANGEIDENTIFIERLOOSE", `${i2[u2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), s2("XRANGEIDENTIFIER", `${i2[u2.NUMERICIDENTIFIER]}|x|X|\\*`), s2("XRANGEPLAIN", `[v=\\s]*(${i2[u2.XRANGEIDENTIFIER]})(?:\\.(${i2[u2.XRANGEIDENTIFIER]})(?:\\.(${i2[u2.XRANGEIDENTIFIER]})(?:${i2[u2.PRERELEASE]})?${i2[u2.BUILD]}?)?)?`), s2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[u2.XRANGEIDENTIFIERLOOSE]})(?:${i2[u2.PRERELEASELOOSE]})?${i2[u2.BUILD]}?)?)?`), s2("XRANGE", `^${i2[u2.GTLT]}\\s*${i2[u2.XRANGEPLAIN]}$`), s2("XRANGELOOSE", `^${i2[u2.GTLT]}\\s*${i2[u2.XRANGEPLAINLOOSE]}$`), s2("COERCE", `(^|[^\\d])(\\d{1,${n2}})(?:\\.(\\d{1,${n2}}))?(?:\\.(\\d{1,${n2}}))?(?:$|[^\\d])`), s2("COERCERTL", i2[u2.COERCE], true), s2("LONETILDE", "(?:~>?)"), s2("TILDETRIM", `(\\s*)${i2[u2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", s2("TILDE", `^${i2[u2.LONETILDE]}${i2[u2.XRANGEPLAIN]}$`), s2("TILDELOOSE", `^${i2[u2.LONETILDE]}${i2[u2.XRANGEPLAINLOOSE]}$`), s2("LONECARET", "(?:\\^)"), s2("CARETTRIM", `(\\s*)${i2[u2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", s2("CARET", `^${i2[u2.LONECARET]}${i2[u2.XRANGEPLAIN]}$`), s2("CARETLOOSE", `^${i2[u2.LONECARET]}${i2[u2.XRANGEPLAINLOOSE]}$`), s2("COMPARATORLOOSE", `^${i2[u2.GTLT]}\\s*(${i2[u2.LOOSEPLAIN]})$|^$`), s2("COMPARATOR", `^${i2[u2.GTLT]}\\s*(${i2[u2.FULLPLAIN]})$|^$`), s2("COMPARATORTRIM", `(\\s*)${i2[u2.GTLT]}\\s*(${i2[u2.LOOSEPLAIN]}|${i2[u2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", s2("HYPHENRANGE", `^\\s*(${i2[u2.XRANGEPLAIN]})\\s+-\\s+(${i2[u2.XRANGEPLAIN]})\\s*$`), s2("HYPHENRANGELOOSE", `^\\s*(${i2[u2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[u2.XRANGEPLAINLOOSE]})\\s*$`), s2("STAR", "(<|>)?=?\\s*\\*"), s2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), s2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
      });
      const Pr = ["includePrerelease", "loose", "rtl"];
      var Or = (e2) => e2 ? typeof e2 != "object" ? { loose: true } : Pr.filter((t2) => e2[t2]).reduce((e3, t2) => (e3[t2] = true, e3), {}) : {};
      const Ir = /^[0-9]+$/, Lr = (e2, t2) => {
        const n2 = Ir.test(e2), r2 = Ir.test(t2);
        return n2 && r2 && (e2 = +e2, t2 = +t2), e2 === t2 ? 0 : n2 && !r2 ? -1 : r2 && !n2 ? 1 : e2 < t2 ? -1 : 1;
      };
      var jr = { compareIdentifiers: Lr, rcompareIdentifiers: (e2, t2) => Lr(t2, e2) };
      const { MAX_LENGTH: _r, MAX_SAFE_INTEGER: Mr } = Nr, { re: Rr, t: $r } = kr, { compareIdentifiers: Vr } = jr;
      class Wr {
        constructor(e2, t2) {
          if (t2 = Or(t2), e2 instanceof Wr) {
            if (e2.loose === !!t2.loose && e2.includePrerelease === !!t2.includePrerelease)
              return e2;
            e2 = e2.version;
          } else if (typeof e2 != "string")
            throw new TypeError(`Invalid Version: ${e2}`);
          if (e2.length > _r)
            throw new TypeError(`version is longer than ${_r} characters`);
          Br("SemVer", e2, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
          const n2 = e2.trim().match(t2.loose ? Rr[$r.LOOSE] : Rr[$r.FULL]);
          if (!n2)
            throw new TypeError(`Invalid Version: ${e2}`);
          if (this.raw = e2, this.major = +n2[1], this.minor = +n2[2], this.patch = +n2[3], this.major > Mr || this.major < 0)
            throw new TypeError("Invalid major version");
          if (this.minor > Mr || this.minor < 0)
            throw new TypeError("Invalid minor version");
          if (this.patch > Mr || this.patch < 0)
            throw new TypeError("Invalid patch version");
          n2[4] ? this.prerelease = n2[4].split(".").map((e3) => {
            if (/^[0-9]+$/.test(e3)) {
              const t3 = +e3;
              if (t3 >= 0 && t3 < Mr)
                return t3;
            }
            return e3;
          }) : this.prerelease = [], this.build = n2[5] ? n2[5].split(".") : [], this.format();
        }
        format() {
          return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
        }
        toString() {
          return this.version;
        }
        compare(e2) {
          if (Br("SemVer.compare", this.version, this.options, e2), !(e2 instanceof Wr)) {
            if (typeof e2 == "string" && e2 === this.version)
              return 0;
            e2 = new Wr(e2, this.options);
          }
          return e2.version === this.version ? 0 : this.compareMain(e2) || this.comparePre(e2);
        }
        compareMain(e2) {
          return e2 instanceof Wr || (e2 = new Wr(e2, this.options)), Vr(this.major, e2.major) || Vr(this.minor, e2.minor) || Vr(this.patch, e2.patch);
        }
        comparePre(e2) {
          if (e2 instanceof Wr || (e2 = new Wr(e2, this.options)), this.prerelease.length && !e2.prerelease.length)
            return -1;
          if (!this.prerelease.length && e2.prerelease.length)
            return 1;
          if (!this.prerelease.length && !e2.prerelease.length)
            return 0;
          let t2 = 0;
          do {
            const n2 = this.prerelease[t2], r2 = e2.prerelease[t2];
            if (Br("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
              return 0;
            if (r2 === void 0)
              return 1;
            if (n2 === void 0)
              return -1;
            if (n2 !== r2)
              return Vr(n2, r2);
          } while (++t2);
        }
        compareBuild(e2) {
          e2 instanceof Wr || (e2 = new Wr(e2, this.options));
          let t2 = 0;
          do {
            const n2 = this.build[t2], r2 = e2.build[t2];
            if (Br("prerelease compare", t2, n2, r2), n2 === void 0 && r2 === void 0)
              return 0;
            if (r2 === void 0)
              return 1;
            if (n2 === void 0)
              return -1;
            if (n2 !== r2)
              return Vr(n2, r2);
          } while (++t2);
        }
        inc(e2, t2) {
          switch (e2) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
              break;
            case "prerelease":
              this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
              break;
            case "major":
              this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              this.prerelease.length === 0 && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0)
                this.prerelease = [0];
              else {
                let e3 = this.prerelease.length;
                for (; --e3 >= 0; )
                  typeof this.prerelease[e3] == "number" && (this.prerelease[e3]++, e3 = -2);
                e3 === -1 && this.prerelease.push(0);
              }
              t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
              break;
            default:
              throw new Error(`invalid increment argument: ${e2}`);
          }
          return this.format(), this.raw = this.version, this;
        }
      }
      var qr = Wr;
      var Ur = (e2, t2, n2) => new qr(e2, n2).compare(new qr(t2, n2));
      var zr = (e2, t2, n2) => Ur(e2, t2, n2) < 0;
      var Gr = (e2, t2, n2) => Ur(e2, t2, n2) >= 0, Hr = r(function(e2, t2) {
        function n2() {
          for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
            e3[t3] = arguments[t3];
        }
        function r2() {
          return typeof WeakMap != "undefined" ? new WeakMap() : { add: n2, delete: n2, get: n2, set: n2, has: function(e3) {
            return false;
          } };
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.outdent = void 0;
        var i2 = Object.prototype.hasOwnProperty, u2 = function(e3, t3) {
          return i2.call(e3, t3);
        };
        function o2(e3, t3) {
          for (var n3 in t3)
            u2(t3, n3) && (e3[n3] = t3[n3]);
          return e3;
        }
        var s2 = /^[ \t]*(?:\r\n|\r|\n)/, a2 = /(?:\r\n|\r|\n)[ \t]*$/, c2 = /^(?:[\r\n]|$)/, l2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
        function f2(e3, t3, n3) {
          var r3 = 0, i3 = e3[0].match(l2);
          i3 && (r3 = i3[1].length);
          var u3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
          t3 && (e3 = e3.slice(1));
          var o3 = n3.newline, c3 = n3.trimLeadingNewline, p3 = n3.trimTrailingNewline, f3 = typeof o3 == "string", d3 = e3.length;
          return e3.map(function(e4, t4) {
            return e4 = e4.replace(u3, "$1"), t4 === 0 && c3 && (e4 = e4.replace(s2, "")), t4 === d3 - 1 && p3 && (e4 = e4.replace(a2, "")), f3 && (e4 = e4.replace(/\r\n|\n|\r/g, function(e5) {
              return o3;
            })), e4;
          });
        }
        function d2(e3, t3) {
          for (var n3 = "", r3 = 0, i3 = e3.length; r3 < i3; r3++)
            n3 += e3[r3], r3 < i3 - 1 && (n3 += t3[r3]);
          return n3;
        }
        function h2(e3) {
          return u2(e3, "raw") && u2(e3, "length");
        }
        var g2 = function e3(t3) {
          var n3 = r2(), i3 = r2();
          return o2(function r3(u3) {
            for (var s3 = [], a3 = 1; a3 < arguments.length; a3++)
              s3[a3 - 1] = arguments[a3];
            if (h2(u3)) {
              var l3 = u3, m2 = (s3[0] === r3 || s3[0] === g2) && p2.test(l3[0]) && c2.test(l3[1]), y2 = m2 ? i3 : n3, D2 = y2.get(l3);
              if (D2 || (D2 = f2(l3, m2, t3), y2.set(l3, D2)), s3.length === 0)
                return D2[0];
              var E2 = d2(D2, m2 ? s3.slice(1) : s3);
              return E2;
            }
            return e3(o2(o2({}, t3), u3 || {}));
          }, { string: function(e4) {
            return f2([e4], false, t3)[0];
          } });
        }({ trimLeadingNewline: true, trimTrailingNewline: true });
        t2.outdent = g2, t2.default = g2;
        try {
          e2.exports = g2, Object.defineProperty(g2, "__esModule", { value: true }), g2.default = g2, g2.outdent = g2;
        } catch (e3) {
        }
      });
      const { outdent: Jr } = Hr, Xr = "Config", Yr = "Editor", Kr = "Other", Qr = "Global", Zr = "Special", ei = { cursorOffset: { since: "1.4.0", category: Zr, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: Jr`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: Yr }, endOfLine: { since: "1.15.0", category: Qr, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: Jr`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: Zr, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: Kr, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: Zr, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: Kr }, parser: { since: "0.0.10", category: Qr, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (e2) => typeof e2 == "string" || typeof e2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: Qr, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin", cliCategory: Xr }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: Qr, description: Jr`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e2) => typeof e2 == "string" || typeof e2 == "object", cliName: "plugin-search-dir", cliCategory: Xr }, printWidth: { since: "0.0.0", category: Qr, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: Zr, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Jr`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: Yr }, rangeStart: { since: "1.4.0", category: Zr, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Jr`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: Yr }, requirePragma: { since: "1.7.0", category: Zr, type: "boolean", default: false, description: Jr`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: Kr }, tabWidth: { type: "int", category: Qr, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: Qr, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: Qr, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
      const ti = ["cliName", "cliCategory", "cliDescription"], ni = { compare: Ur, lt: zr, gte: Gr }, ri = e.version, ii = { CATEGORY_CONFIG: Xr, CATEGORY_EDITOR: Yr, CATEGORY_FORMAT: "Format", CATEGORY_OTHER: Kr, CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: Qr, CATEGORY_SPECIAL: Zr, options: ei }.options;
      var ui = { getSupportInfo: function({ plugins: e2 = [], showUnreleased: t2 = false, showDeprecated: n2 = false, showInternal: r2 = false } = {}) {
        const i2 = ri.split("-", 1)[0], u2 = e2.flatMap((e3) => e3.languages || []).filter(s2), o2 = ((e3, t3) => Object.entries(e3).map(([e4, n3]) => Object.assign({ [t3]: e4 }, n3)))(Object.assign({}, ...e2.map(({ options: e3 }) => e3), ii), "name").filter((e3) => s2(e3) && a2(e3)).sort((e3, t3) => e3.name === t3.name ? 0 : e3.name < t3.name ? -1 : 1).map(function(e3) {
          if (r2)
            return e3;
          return Mn(e3, ti);
        }).map((t3) => {
          t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(s2).sort((e3, t4) => ni.compare(t4.since, e3.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e3) => s2(e3) && a2(e3)), t3.name === "parser" && function(e3, t4, n4) {
            const r3 = new Set(e3.choices.map((e4) => e4.value));
            for (const i3 of t4)
              if (i3.parsers) {
                for (const t5 of i3.parsers)
                  if (!r3.has(t5)) {
                    r3.add(t5);
                    const u3 = n4.find((e4) => e4.parsers && e4.parsers[t5]);
                    let o3 = i3.name;
                    u3 && u3.name && (o3 += ` (plugin: ${u3.name})`), e3.choices.push({ value: t5, description: o3 });
                  }
              }
          }(t3, u2, e2));
          const n3 = Object.fromEntries(e2.filter((e3) => e3.defaultOptions && e3.defaultOptions[t3.name] !== void 0).map((e3) => [e3.name, e3.defaultOptions[t3.name]]));
          return Object.assign(Object.assign({}, t3), {}, { pluginDefaults: n3 });
        });
        return { languages: u2, options: o2 };
        function s2(e3) {
          return t2 || !("since" in e3) || e3.since && ni.gte(i2, e3.since);
        }
        function a2(e3) {
          return n2 || !("deprecated" in e3) || e3.deprecated && ni.lt(i2, e3.deprecated);
        }
      } };
      const { getSupportInfo: oi } = ui, si = /[^\x20-\x7F]/;
      function ai(e2) {
        return (t2, n2, r2) => {
          const i2 = r2 && r2.backwards;
          if (n2 === false)
            return false;
          const { length: u2 } = t2;
          let o2 = n2;
          for (; o2 >= 0 && o2 < u2; ) {
            const n3 = t2.charAt(o2);
            if (e2 instanceof RegExp) {
              if (!e2.test(n3))
                return o2;
            } else if (!e2.includes(n3))
              return o2;
            i2 ? o2-- : o2++;
          }
          return (o2 === -1 || o2 === u2) && o2;
        };
      }
      const ci = ai(/\s/), li = ai(" 	"), pi = ai(",; 	"), fi = ai(/[^\n\r]/);
      function di(e2, t2) {
        if (t2 === false)
          return false;
        if (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "*") {
          for (let n2 = t2 + 2; n2 < e2.length; ++n2)
            if (e2.charAt(n2) === "*" && e2.charAt(n2 + 1) === "/")
              return n2 + 2;
        }
        return t2;
      }
      function hi(e2, t2) {
        return t2 !== false && (e2.charAt(t2) === "/" && e2.charAt(t2 + 1) === "/" ? fi(e2, t2) : t2);
      }
      function gi(e2, t2, n2) {
        const r2 = n2 && n2.backwards;
        if (t2 === false)
          return false;
        const i2 = e2.charAt(t2);
        if (r2) {
          if (e2.charAt(t2 - 1) === "\r" && i2 === "\n")
            return t2 - 2;
          if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
            return t2 - 1;
        } else {
          if (i2 === "\r" && e2.charAt(t2 + 1) === "\n")
            return t2 + 2;
          if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
            return t2 + 1;
        }
        return t2;
      }
      function mi(e2, t2, n2 = {}) {
        const r2 = li(e2, n2.backwards ? t2 - 1 : t2, n2);
        return r2 !== gi(e2, r2, n2);
      }
      function yi(e2, t2) {
        let n2 = null, r2 = t2;
        for (; r2 !== n2; )
          n2 = r2, r2 = pi(e2, r2), r2 = di(e2, r2), r2 = li(e2, r2);
        return r2 = hi(e2, r2), r2 = gi(e2, r2), r2 !== false && mi(e2, r2);
      }
      function Di(e2, t2) {
        let n2 = null, r2 = t2;
        for (; r2 !== n2; )
          n2 = r2, r2 = li(e2, r2), r2 = di(e2, r2), r2 = hi(e2, r2), r2 = gi(e2, r2);
        return r2;
      }
      function Ei(e2, t2, n2) {
        return Di(e2, n2(t2));
      }
      function Ci(e2, t2, n2 = 0) {
        let r2 = 0;
        for (let i2 = n2; i2 < e2.length; ++i2)
          e2[i2] === "	" ? r2 = r2 + t2 - r2 % t2 : r2++;
        return r2;
      }
      function bi(e2, t2) {
        const n2 = e2.slice(1, -1), r2 = { quote: '"', regex: /"/g }, i2 = { quote: "'", regex: /'/g }, u2 = t2 === "'" ? i2 : r2, o2 = u2 === i2 ? r2 : i2;
        let s2 = u2.quote;
        if (n2.includes(u2.quote) || n2.includes(o2.quote)) {
          s2 = (n2.match(u2.regex) || []).length > (n2.match(o2.regex) || []).length ? o2.quote : u2.quote;
        }
        return s2;
      }
      function Ai(e2, t2, n2) {
        const r2 = t2 === '"' ? "'" : '"', i2 = e2.replace(/\\(.)|(["'])/gs, (e3, i3, u2) => i3 === r2 ? i3 : u2 === t2 ? "\\" + u2 : u2 || (n2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
        return t2 + i2 + t2;
      }
      function vi(e2, t2) {
        (e2.comments || (e2.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e3) {
          const t3 = e3.type || e3.kind || "(unknown type)";
          let n2 = String(e3.name || e3.id && (typeof e3.id == "object" ? e3.id.name : e3.id) || e3.key && (typeof e3.key == "object" ? e3.key.name : e3.key) || e3.value && (typeof e3.value == "object" ? "" : String(e3.value)) || e3.operator || "");
          n2.length > 20 && (n2 = n2.slice(0, 19) + "\u2026");
          return t3 + (n2 ? " " + n2 : "");
        }(e2);
      }
      var Fi = { inferParserByLanguage: function(e2, t2) {
        const { languages: n2 } = oi({ plugins: t2.plugins }), r2 = n2.find(({ name: t3 }) => t3.toLowerCase() === e2) || n2.find(({ aliases: t3 }) => Array.isArray(t3) && t3.includes(e2)) || n2.find(({ extensions: t3 }) => Array.isArray(t3) && t3.includes(`.${e2}`));
        return r2 && r2.parsers[0];
      }, getStringWidth: function(e2) {
        return e2 ? si.test(e2) ? In(e2) : e2.length : 0;
      }, getMaxContinuousCount: function(e2, t2) {
        const n2 = e2.match(new RegExp(`(${jn(t2)})+`, "g"));
        return n2 === null ? 0 : n2.reduce((e3, n3) => Math.max(e3, n3.length / t2.length), 0);
      }, getMinNotPresentContinuousCount: function(e2, t2) {
        const n2 = e2.match(new RegExp(`(${jn(t2)})+`, "g"));
        if (n2 === null)
          return 0;
        const r2 = new Map();
        let i2 = 0;
        for (const e3 of n2) {
          const n3 = e3.length / t2.length;
          r2.set(n3, true), n3 > i2 && (i2 = n3);
        }
        for (let e3 = 1; e3 < i2; e3++)
          if (!r2.get(e3))
            return e3;
        return i2 + 1;
      }, getPenultimate: (e2) => e2[e2.length - 2], getLast: _n, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Di, getNextNonSpaceNonCommentCharacterIndex: Ei, getNextNonSpaceNonCommentCharacter: function(e2, t2, n2) {
        return e2.charAt(Ei(e2, t2, n2));
      }, skip: ai, skipWhitespace: ci, skipSpaces: li, skipToLineEnd: pi, skipEverythingButNewLine: fi, skipInlineComment: di, skipTrailingComment: hi, skipNewline: gi, isNextLineEmptyAfterIndex: yi, isNextLineEmpty: function(e2, t2, n2) {
        return yi(e2, n2(t2));
      }, isPreviousLineEmpty: function(e2, t2, n2) {
        let r2 = n2(t2) - 1;
        return r2 = li(e2, r2, { backwards: true }), r2 = gi(e2, r2, { backwards: true }), r2 = li(e2, r2, { backwards: true }), r2 !== gi(e2, r2, { backwards: true });
      }, hasNewline: mi, hasNewlineInRange: function(e2, t2, n2) {
        for (let r2 = t2; r2 < n2; ++r2)
          if (e2.charAt(r2) === "\n")
            return true;
        return false;
      }, hasSpaces: function(e2, t2, n2 = {}) {
        return li(e2, n2.backwards ? t2 - 1 : t2, n2) !== t2;
      }, getAlignmentSize: Ci, getIndentSize: function(e2, t2) {
        const n2 = e2.lastIndexOf("\n");
        return n2 === -1 ? 0 : Ci(e2.slice(n2 + 1).match(/^[\t ]*/)[0], t2);
      }, getPreferredQuote: bi, printString: function(e2, t2) {
        return Ai(e2.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : bi(e2, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
      }, printNumber: function(e2) {
        return e2.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
      }, makeString: Ai, addLeadingComment: function(e2, t2) {
        t2.leading = true, t2.trailing = false, vi(e2, t2);
      }, addDanglingComment: function(e2, t2, n2) {
        t2.leading = false, t2.trailing = false, n2 && (t2.marker = n2), vi(e2, t2);
      }, addTrailingComment: function(e2, t2) {
        t2.leading = false, t2.trailing = true, vi(e2, t2);
      }, isFrontMatterNode: function(e2) {
        return e2 && e2.type === "front-matter";
      }, getShebang: function(e2) {
        if (!e2.startsWith("#!"))
          return "";
        const t2 = e2.indexOf("\n");
        return t2 === -1 ? e2 : e2.slice(0, t2);
      }, isNonEmptyArray: function(e2) {
        return Array.isArray(e2) && e2.length > 0;
      }, createGroupIdMapper: function(e2) {
        const t2 = new WeakMap();
        return function(n2) {
          return t2.has(n2) || t2.set(n2, Symbol(e2)), t2.get(n2);
        };
      } };
      var xi = { guessEndOfLine: function(e2) {
        const t2 = e2.indexOf("\r");
        return t2 >= 0 ? e2.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
      }, convertEndOfLineToChars: function(e2) {
        switch (e2) {
          case "cr":
            return "\r";
          case "crlf":
            return "\r\n";
          default:
            return "\n";
        }
      }, countEndOfLineChars: function(e2, t2) {
        let n2;
        if (t2 === "\n")
          n2 = /\n/g;
        else if (t2 === "\r")
          n2 = /\r/g;
        else {
          if (t2 !== "\r\n")
            throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
          n2 = /\r\n/g;
        }
        const r2 = e2.match(n2);
        return r2 ? r2.length : 0;
      }, normalizeEndOfLine: function(e2) {
        return e2.replace(/\r\n?/g, "\n");
      } };
      const { literalline: Si, join: wi } = Tn, Ti = (e2) => Array.isArray(e2) || e2 && e2.type === "concat", Bi = (e2) => {
        if (Array.isArray(e2))
          return e2;
        if (e2.type !== "concat" && e2.type !== "fill")
          throw new Error("Expect doc type to be `concat` or `fill`.");
        return e2.parts;
      }, Ni = {};
      function ki(e2, t2, n2, r2) {
        const i2 = [e2];
        for (; i2.length > 0; ) {
          const e3 = i2.pop();
          if (e3 !== Ni) {
            if (n2 && i2.push(e3, Ni), !t2 || t2(e3) !== false)
              if (Ti(e3) || e3.type === "fill") {
                const t3 = Bi(e3);
                for (let e4 = t3.length - 1; e4 >= 0; --e4)
                  i2.push(t3[e4]);
              } else if (e3.type === "if-break")
                e3.flatContents && i2.push(e3.flatContents), e3.breakContents && i2.push(e3.breakContents);
              else if (e3.type === "group" && e3.expandedStates)
                if (r2)
                  for (let t3 = e3.expandedStates.length - 1; t3 >= 0; --t3)
                    i2.push(e3.expandedStates[t3]);
                else
                  i2.push(e3.contents);
              else
                e3.contents && i2.push(e3.contents);
          } else
            n2(i2.pop());
        }
      }
      function Pi(e2, t2) {
        const n2 = new Map();
        return r2(e2);
        function r2(e3) {
          if (n2.has(e3))
            return n2.get(e3);
          const i2 = function(e4) {
            if (Array.isArray(e4))
              return t2(e4.map(r2));
            if (e4.type === "concat" || e4.type === "fill") {
              const n3 = e4.parts.map(r2);
              return t2(Object.assign(Object.assign({}, e4), {}, { parts: n3 }));
            }
            if (e4.type === "if-break") {
              const n3 = e4.breakContents && r2(e4.breakContents), i3 = e4.flatContents && r2(e4.flatContents);
              return t2(Object.assign(Object.assign({}, e4), {}, { breakContents: n3, flatContents: i3 }));
            }
            if (e4.type === "group" && e4.expandedStates) {
              const n3 = e4.expandedStates.map(r2), i3 = n3[0];
              return t2(Object.assign(Object.assign({}, e4), {}, { contents: i3, expandedStates: n3 }));
            }
            if (e4.contents) {
              const n3 = r2(e4.contents);
              return t2(Object.assign(Object.assign({}, e4), {}, { contents: n3 }));
            }
            return t2(e4);
          }(e3);
          return n2.set(e3, i2), i2;
        }
      }
      function Oi(e2, t2, n2) {
        let r2 = n2, i2 = false;
        return ki(e2, function(e3) {
          const n3 = t2(e3);
          if (n3 !== void 0 && (i2 = true, r2 = n3), i2)
            return false;
        }), r2;
      }
      function Ii(e2) {
        return !(e2.type !== "group" || !e2.break) || (!(e2.type !== "line" || !e2.hard) || (e2.type === "break-parent" || void 0));
      }
      function Li(e2) {
        if (e2.length > 0) {
          const t2 = _n(e2);
          t2.expandedStates || t2.break || (t2.break = "propagated");
        }
        return null;
      }
      function ji(e2) {
        return e2.type !== "line" || e2.hard ? e2.type === "if-break" ? e2.flatContents || "" : e2 : e2.soft ? "" : " ";
      }
      const _i = (e2, t2) => e2 && e2.type === "line" && e2.hard && t2 && t2.type === "break-parent";
      function Mi(e2) {
        if (!e2)
          return e2;
        if (Ti(e2) || e2.type === "fill") {
          const t2 = Bi(e2);
          for (; t2.length > 1 && _i(...t2.slice(-2)); )
            t2.length -= 2;
          if (t2.length > 0) {
            const e3 = Mi(_n(t2));
            t2[t2.length - 1] = e3;
          }
          return Array.isArray(e2) ? t2 : Object.assign(Object.assign({}, e2), {}, { parts: t2 });
        }
        switch (e2.type) {
          case "align":
          case "indent":
          case "indent-if-break":
          case "group":
          case "line-suffix":
          case "label": {
            const t2 = Mi(e2.contents);
            return Object.assign(Object.assign({}, e2), {}, { contents: t2 });
          }
          case "if-break": {
            const t2 = Mi(e2.breakContents), n2 = Mi(e2.flatContents);
            return Object.assign(Object.assign({}, e2), {}, { breakContents: t2, flatContents: n2 });
          }
        }
        return e2;
      }
      function Ri(e2) {
        return Pi(e2, (e3) => function(e4) {
          switch (e4.type) {
            case "fill":
              if (e4.parts.length === 0 || e4.parts.every((e5) => e5 === ""))
                return "";
              break;
            case "group":
              if (!(e4.contents || e4.id || e4.break || e4.expandedStates))
                return "";
              if (e4.contents.type === "group" && e4.contents.id === e4.id && e4.contents.break === e4.break && e4.contents.expandedStates === e4.expandedStates)
                return e4.contents;
              break;
            case "align":
            case "indent":
            case "indent-if-break":
            case "line-suffix":
              if (!e4.contents)
                return "";
              break;
            case "if-break":
              if (!e4.flatContents && !e4.breakContents)
                return "";
          }
          if (!Ti(e4))
            return e4;
          const t2 = [];
          for (const n2 of Bi(e4)) {
            if (!n2)
              continue;
            const [e5, ...r2] = Ti(n2) ? Bi(n2) : [n2];
            typeof e5 == "string" && typeof _n(t2) == "string" ? t2[t2.length - 1] += e5 : t2.push(e5), t2.push(...r2);
          }
          return t2.length === 0 ? "" : t2.length === 1 ? t2[0] : Array.isArray(e4) ? t2 : Object.assign(Object.assign({}, e4), {}, { parts: t2 });
        }(e3));
      }
      function $i(e2) {
        const t2 = [], n2 = e2.filter(Boolean);
        for (; n2.length > 0; ) {
          const e3 = n2.shift();
          e3 && (Ti(e3) ? n2.unshift(...Bi(e3)) : t2.length > 0 && typeof _n(t2) == "string" && typeof e3 == "string" ? t2[t2.length - 1] += e3 : t2.push(e3));
        }
        return t2;
      }
      function Vi(e2, t2 = Si) {
        return wi(t2, e2.split("\n")).parts;
      }
      var Wi = { isConcat: Ti, getDocParts: Bi, willBreak: function(e2) {
        return Oi(e2, Ii, false);
      }, traverseDoc: ki, findInDoc: Oi, mapDoc: Pi, propagateBreaks: function(e2) {
        const t2 = new Set(), n2 = [];
        ki(e2, function(e3) {
          if (e3.type === "break-parent" && Li(n2), e3.type === "group") {
            if (n2.push(e3), t2.has(e3))
              return false;
            t2.add(e3);
          }
        }, function(e3) {
          if (e3.type === "group") {
            n2.pop().break && Li(n2);
          }
        }, true);
      }, removeLines: function(e2) {
        return Pi(e2, ji);
      }, stripTrailingHardline: function(e2) {
        return Mi(Ri(e2));
      }, normalizeParts: $i, normalizeDoc: function(e2) {
        return Pi(e2, (e3) => Array.isArray(e3) ? $i(e3) : e3.parts ? Object.assign(Object.assign({}, e3), {}, { parts: $i(e3.parts) }) : e3);
      }, cleanDoc: Ri, replaceTextEndOfLine: Vi, replaceEndOfLine: function(e2) {
        return Pi(e2, (e3) => typeof e3 == "string" && e3.includes("\n") ? Vi(e3) : e3);
      } };
      const { getStringWidth: qi, getLast: Ui } = Fi, { convertEndOfLineToChars: zi } = xi, { fill: Gi, cursor: Hi, indent: Ji } = Tn, { isConcat: Xi, getDocParts: Yi } = Wi;
      let Ki;
      function Qi(e2, t2) {
        return eu(e2, { type: "indent" }, t2);
      }
      function Zi(e2, t2, n2) {
        if (t2 === Number.NEGATIVE_INFINITY)
          return e2.root || { value: "", length: 0, queue: [] };
        if (t2 < 0)
          return eu(e2, { type: "dedent" }, n2);
        if (!t2)
          return e2;
        if (t2.type === "root")
          return Object.assign(Object.assign({}, e2), {}, { root: e2 });
        return eu(e2, { type: typeof t2 == "string" ? "stringAlign" : "numberAlign", n: t2 }, n2);
      }
      function eu(e2, t2, n2) {
        const r2 = t2.type === "dedent" ? e2.queue.slice(0, -1) : [...e2.queue, t2];
        let i2 = "", u2 = 0, o2 = 0, s2 = 0;
        for (const e3 of r2)
          switch (e3.type) {
            case "indent":
              l2(), n2.useTabs ? a2(1) : c2(n2.tabWidth);
              break;
            case "stringAlign":
              l2(), i2 += e3.n, u2 += e3.n.length;
              break;
            case "numberAlign":
              o2 += 1, s2 += e3.n;
              break;
            default:
              throw new Error(`Unexpected type '${e3.type}'`);
          }
        return p2(), Object.assign(Object.assign({}, e2), {}, { value: i2, length: u2, queue: r2 });
        function a2(e3) {
          i2 += "	".repeat(e3), u2 += n2.tabWidth * e3;
        }
        function c2(e3) {
          i2 += " ".repeat(e3), u2 += e3;
        }
        function l2() {
          n2.useTabs ? function() {
            o2 > 0 && a2(o2);
            f2();
          }() : p2();
        }
        function p2() {
          s2 > 0 && c2(s2), f2();
        }
        function f2() {
          o2 = 0, s2 = 0;
        }
      }
      function tu(e2) {
        if (e2.length === 0)
          return 0;
        let t2 = 0;
        for (; e2.length > 0 && typeof Ui(e2) == "string" && /^[\t ]*$/.test(Ui(e2)); )
          t2 += e2.pop().length;
        if (e2.length > 0 && typeof Ui(e2) == "string") {
          const n2 = Ui(e2).replace(/[\t ]*$/, "");
          t2 += Ui(e2).length - n2.length, e2[e2.length - 1] = n2;
        }
        return t2;
      }
      function nu(e2, t2, n2, r2, i2, u2) {
        let o2 = t2.length;
        const s2 = [e2], a2 = [];
        for (; n2 >= 0; ) {
          if (s2.length === 0) {
            if (o2 === 0)
              return true;
            s2.push(t2[o2 - 1]), o2--;
            continue;
          }
          const [e3, c2, l2] = s2.pop();
          if (typeof l2 == "string")
            a2.push(l2), n2 -= qi(l2);
          else if (Xi(l2)) {
            const t3 = Yi(l2);
            for (let n3 = t3.length - 1; n3 >= 0; n3--)
              s2.push([e3, c2, t3[n3]]);
          } else
            switch (l2.type) {
              case "indent":
                s2.push([Qi(e3, r2), c2, l2.contents]);
                break;
              case "align":
                s2.push([Zi(e3, l2.n, r2), c2, l2.contents]);
                break;
              case "trim":
                n2 += tu(a2);
                break;
              case "group": {
                if (u2 && l2.break)
                  return false;
                const t3 = l2.break ? 1 : c2;
                s2.push([e3, t3, l2.expandedStates && t3 === 1 ? Ui(l2.expandedStates) : l2.contents]), l2.id && (Ki[l2.id] = t3);
                break;
              }
              case "fill":
                for (let t3 = l2.parts.length - 1; t3 >= 0; t3--)
                  s2.push([e3, c2, l2.parts[t3]]);
                break;
              case "if-break":
              case "indent-if-break": {
                const t3 = l2.groupId ? Ki[l2.groupId] : c2;
                if (t3 === 1) {
                  const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Ji(l2.contents);
                  t4 && s2.push([e3, c2, t4]);
                }
                if (t3 === 2) {
                  const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Ji(l2.contents) : l2.contents;
                  t4 && s2.push([e3, c2, t4]);
                }
                break;
              }
              case "line":
                switch (c2) {
                  case 2:
                    if (!l2.hard) {
                      l2.soft || (a2.push(" "), n2 -= 1);
                      break;
                    }
                    return true;
                  case 1:
                    return true;
                }
                break;
              case "line-suffix":
                i2 = true;
                break;
              case "line-suffix-boundary":
                if (i2)
                  return false;
                break;
              case "label":
                s2.push([e3, c2, l2.contents]);
            }
        }
        return false;
      }
      var ru = { printDocToString: function(e2, t2) {
        Ki = {};
        const n2 = t2.printWidth, r2 = zi(t2.endOfLine);
        let i2 = 0;
        const u2 = [[{ value: "", length: 0, queue: [] }, 1, e2]], o2 = [];
        let s2 = false, a2 = [];
        for (; u2.length > 0; ) {
          const [e3, c3, l2] = u2.pop();
          if (typeof l2 == "string") {
            const e4 = r2 !== "\n" ? l2.replace(/\n/g, r2) : l2;
            o2.push(e4), i2 += qi(e4);
          } else if (Xi(l2)) {
            const t3 = Yi(l2);
            for (let n3 = t3.length - 1; n3 >= 0; n3--)
              u2.push([e3, c3, t3[n3]]);
          } else
            switch (l2.type) {
              case "cursor":
                o2.push(Hi.placeholder);
                break;
              case "indent":
                u2.push([Qi(e3, t2), c3, l2.contents]);
                break;
              case "align":
                u2.push([Zi(e3, l2.n, t2), c3, l2.contents]);
                break;
              case "trim":
                i2 -= tu(o2);
                break;
              case "group":
                switch (c3) {
                  case 2:
                    if (!s2) {
                      u2.push([e3, l2.break ? 1 : 2, l2.contents]);
                      break;
                    }
                  case 1: {
                    s2 = false;
                    const r3 = [e3, 2, l2.contents], o3 = n2 - i2, c4 = a2.length > 0;
                    if (!l2.break && nu(r3, u2, o3, t2, c4))
                      u2.push(r3);
                    else if (l2.expandedStates) {
                      const n3 = Ui(l2.expandedStates);
                      if (l2.break) {
                        u2.push([e3, 1, n3]);
                        break;
                      }
                      for (let r4 = 1; r4 < l2.expandedStates.length + 1; r4++) {
                        if (r4 >= l2.expandedStates.length) {
                          u2.push([e3, 1, n3]);
                          break;
                        }
                        {
                          const n4 = [e3, 2, l2.expandedStates[r4]];
                          if (nu(n4, u2, o3, t2, c4)) {
                            u2.push(n4);
                            break;
                          }
                        }
                      }
                    } else
                      u2.push([e3, 1, l2.contents]);
                    break;
                  }
                }
                l2.id && (Ki[l2.id] = Ui(u2)[1]);
                break;
              case "fill": {
                const r3 = n2 - i2, { parts: o3 } = l2;
                if (o3.length === 0)
                  break;
                const [s3, p2] = o3, f2 = [e3, 2, s3], d2 = [e3, 1, s3], h2 = nu(f2, [], r3, t2, a2.length > 0, true);
                if (o3.length === 1) {
                  h2 ? u2.push(f2) : u2.push(d2);
                  break;
                }
                const g2 = [e3, 2, p2], m2 = [e3, 1, p2];
                if (o3.length === 2) {
                  h2 ? u2.push(g2, f2) : u2.push(m2, d2);
                  break;
                }
                o3.splice(0, 2);
                const y2 = [e3, c3, Gi(o3)];
                nu([e3, 2, [s3, p2, o3[0]]], [], r3, t2, a2.length > 0, true) ? u2.push(y2, g2, f2) : h2 ? u2.push(y2, m2, f2) : u2.push(y2, m2, d2);
                break;
              }
              case "if-break":
              case "indent-if-break": {
                const t3 = l2.groupId ? Ki[l2.groupId] : c3;
                if (t3 === 1) {
                  const t4 = l2.type === "if-break" ? l2.breakContents : l2.negate ? l2.contents : Ji(l2.contents);
                  t4 && u2.push([e3, c3, t4]);
                }
                if (t3 === 2) {
                  const t4 = l2.type === "if-break" ? l2.flatContents : l2.negate ? Ji(l2.contents) : l2.contents;
                  t4 && u2.push([e3, c3, t4]);
                }
                break;
              }
              case "line-suffix":
                a2.push([e3, c3, l2.contents]);
                break;
              case "line-suffix-boundary":
                a2.length > 0 && u2.push([e3, c3, { type: "line", hard: true }]);
                break;
              case "line":
                switch (c3) {
                  case 2:
                    if (!l2.hard) {
                      l2.soft || (o2.push(" "), i2 += 1);
                      break;
                    }
                    s2 = true;
                  case 1:
                    if (a2.length > 0) {
                      u2.push([e3, c3, l2], ...a2.reverse()), a2 = [];
                      break;
                    }
                    l2.literal ? e3.root ? (o2.push(r2, e3.root.value), i2 = e3.root.length) : (o2.push(r2), i2 = 0) : (i2 -= tu(o2), o2.push(r2 + e3.value), i2 = e3.length);
                }
                break;
              case "label":
                u2.push([e3, c3, l2.contents]);
            }
          u2.length === 0 && a2.length > 0 && (u2.push(...a2.reverse()), a2 = []);
        }
        const c2 = o2.indexOf(Hi.placeholder);
        if (c2 !== -1) {
          const e3 = o2.indexOf(Hi.placeholder, c2 + 1), t3 = o2.slice(0, c2).join(""), n3 = o2.slice(c2 + 1, e3).join("");
          return { formatted: t3 + n3 + o2.slice(e3 + 1).join(""), cursorNodeStart: t3.length, cursorNodeText: n3 };
        }
        return { formatted: o2.join("") };
      } };
      const { isConcat: iu, getDocParts: uu } = Wi;
      function ou(e2) {
        if (!e2)
          return "";
        if (iu(e2)) {
          const t2 = [];
          for (const n2 of uu(e2))
            if (iu(n2))
              t2.push(...ou(n2).parts);
            else {
              const e3 = ou(n2);
              e3 !== "" && t2.push(e3);
            }
          return { type: "concat", parts: t2 };
        }
        return e2.type === "if-break" ? Object.assign(Object.assign({}, e2), {}, { breakContents: ou(e2.breakContents), flatContents: ou(e2.flatContents) }) : e2.type === "group" ? Object.assign(Object.assign({}, e2), {}, { contents: ou(e2.contents), expandedStates: e2.expandedStates && e2.expandedStates.map(ou) }) : e2.type === "fill" ? { type: "fill", parts: e2.parts.map(ou) } : e2.contents ? Object.assign(Object.assign({}, e2), {}, { contents: ou(e2.contents) }) : e2;
      }
      var su = { builders: Tn, printer: ru, utils: Wi, debug: { printDocToDebug: function(e2) {
        const t2 = Object.create(null), n2 = new Set();
        return function e3(t3, n3, i2) {
          if (typeof t3 == "string")
            return JSON.stringify(t3);
          if (iu(t3)) {
            const n4 = uu(t3).map(e3).filter(Boolean);
            return n4.length === 1 ? n4[0] : `[${n4.join(", ")}]`;
          }
          if (t3.type === "line") {
            const e4 = Array.isArray(i2) && i2[n3 + 1] && i2[n3 + 1].type === "break-parent";
            return t3.literal ? e4 ? "literalline" : "literallineWithoutBreakParent" : t3.hard ? e4 ? "hardline" : "hardlineWithoutBreakParent" : t3.soft ? "softline" : "line";
          }
          if (t3.type === "break-parent") {
            return Array.isArray(i2) && i2[n3 - 1] && i2[n3 - 1].type === "line" && i2[n3 - 1].hard ? void 0 : "breakParent";
          }
          if (t3.type === "trim")
            return "trim";
          if (t3.type === "indent")
            return "indent(" + e3(t3.contents) + ")";
          if (t3.type === "align")
            return t3.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + e3(t3.contents) + ")" : t3.n < 0 ? "dedent(" + e3(t3.contents) + ")" : t3.n.type === "root" ? "markAsRoot(" + e3(t3.contents) + ")" : "align(" + JSON.stringify(t3.n) + ", " + e3(t3.contents) + ")";
          if (t3.type === "if-break")
            return "ifBreak(" + e3(t3.breakContents) + (t3.flatContents ? ", " + e3(t3.flatContents) : "") + (t3.groupId ? (t3.flatContents ? "" : ', ""') + `, { groupId: ${r2(t3.groupId)} }` : "") + ")";
          if (t3.type === "indent-if-break") {
            const n4 = [];
            t3.negate && n4.push("negate: true"), t3.groupId && n4.push(`groupId: ${r2(t3.groupId)}`);
            const i3 = n4.length > 0 ? `, { ${n4.join(", ")} }` : "";
            return `indentIfBreak(${e3(t3.contents)}${i3})`;
          }
          if (t3.type === "group") {
            const n4 = [];
            t3.break && t3.break !== "propagated" && n4.push("shouldBreak: true"), t3.id && n4.push(`id: ${r2(t3.id)}`);
            const i3 = n4.length > 0 ? `, { ${n4.join(", ")} }` : "";
            return t3.expandedStates ? `conditionalGroup([${t3.expandedStates.map((t4) => e3(t4)).join(",")}]${i3})` : `group(${e3(t3.contents)}${i3})`;
          }
          if (t3.type === "fill")
            return `fill([${t3.parts.map((t4) => e3(t4)).join(", ")}])`;
          if (t3.type === "line-suffix")
            return "lineSuffix(" + e3(t3.contents) + ")";
          if (t3.type === "line-suffix-boundary")
            return "lineSuffixBoundary";
          if (t3.type === "label")
            return `label(${JSON.stringify(t3.label)}, ${e3(t3.contents)})`;
          throw new Error("Unknown doc type " + t3.type);
        }(ou(e2));
        function r2(e3) {
          if (typeof e3 != "symbol")
            return JSON.stringify(String(e3));
          if (e3 in t2)
            return t2[e3];
          const r3 = String(e3).slice(7, -1) || "symbol";
          for (let i2 = 0; ; i2++) {
            const u2 = r3 + (i2 > 0 ? ` #${i2}` : "");
            if (!n2.has(u2))
              return n2.add(u2), t2[e3] = `Symbol.for(${JSON.stringify(u2)})`;
          }
        }
      } } }, au = Object.freeze({ __proto__: null, default: {} });
      function cu(e2, t2) {
        for (var n2 = 0, r2 = e2.length - 1; r2 >= 0; r2--) {
          var i2 = e2[r2];
          i2 === "." ? e2.splice(r2, 1) : i2 === ".." ? (e2.splice(r2, 1), n2++) : n2 && (e2.splice(r2, 1), n2--);
        }
        if (t2)
          for (; n2--; n2)
            e2.unshift("..");
        return e2;
      }
      var lu = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, pu = function(e2) {
        return lu.exec(e2).slice(1);
      };
      function fu() {
        for (var e2 = "", t2 = false, n2 = arguments.length - 1; n2 >= -1 && !t2; n2--) {
          var r2 = n2 >= 0 ? arguments[n2] : "/";
          if (typeof r2 != "string")
            throw new TypeError("Arguments to path.resolve must be strings");
          r2 && (e2 = r2 + "/" + e2, t2 = r2.charAt(0) === "/");
        }
        return (t2 ? "/" : "") + (e2 = cu(bu(e2.split("/"), function(e3) {
          return !!e3;
        }), !t2).join("/")) || ".";
      }
      function du(e2) {
        var t2 = hu(e2), n2 = Au(e2, -1) === "/";
        return (e2 = cu(bu(e2.split("/"), function(e3) {
          return !!e3;
        }), !t2).join("/")) || t2 || (e2 = "."), e2 && n2 && (e2 += "/"), (t2 ? "/" : "") + e2;
      }
      function hu(e2) {
        return e2.charAt(0) === "/";
      }
      function gu() {
        var e2 = Array.prototype.slice.call(arguments, 0);
        return du(bu(e2, function(e3, t2) {
          if (typeof e3 != "string")
            throw new TypeError("Arguments to path.join must be strings");
          return e3;
        }).join("/"));
      }
      function mu(e2, t2) {
        function n2(e3) {
          for (var t3 = 0; t3 < e3.length && e3[t3] === ""; t3++)
            ;
          for (var n3 = e3.length - 1; n3 >= 0 && e3[n3] === ""; n3--)
            ;
          return t3 > n3 ? [] : e3.slice(t3, n3 - t3 + 1);
        }
        e2 = fu(e2).substr(1), t2 = fu(t2).substr(1);
        for (var r2 = n2(e2.split("/")), i2 = n2(t2.split("/")), u2 = Math.min(r2.length, i2.length), o2 = u2, s2 = 0; s2 < u2; s2++)
          if (r2[s2] !== i2[s2]) {
            o2 = s2;
            break;
          }
        var a2 = [];
        for (s2 = o2; s2 < r2.length; s2++)
          a2.push("..");
        return (a2 = a2.concat(i2.slice(o2))).join("/");
      }
      function yu(e2) {
        var t2 = pu(e2), n2 = t2[0], r2 = t2[1];
        return n2 || r2 ? (r2 && (r2 = r2.substr(0, r2.length - 1)), n2 + r2) : ".";
      }
      function Du(e2, t2) {
        var n2 = pu(e2)[2];
        return t2 && n2.substr(-1 * t2.length) === t2 && (n2 = n2.substr(0, n2.length - t2.length)), n2;
      }
      function Eu(e2) {
        return pu(e2)[3];
      }
      var Cu = { extname: Eu, basename: Du, dirname: yu, sep: "/", delimiter: ":", relative: mu, join: gu, isAbsolute: hu, normalize: du, resolve: fu };
      function bu(e2, t2) {
        if (e2.filter)
          return e2.filter(t2);
        for (var n2 = [], r2 = 0; r2 < e2.length; r2++)
          t2(e2[r2], r2, e2) && n2.push(e2[r2]);
        return n2;
      }
      var Au = "ab".substr(-1) === "b" ? function(e2, t2, n2) {
        return e2.substr(t2, n2);
      } : function(e2, t2, n2) {
        return t2 < 0 && (t2 = e2.length + t2), e2.substr(t2, n2);
      }, vu = Object.freeze({ __proto__: null, resolve: fu, normalize: du, isAbsolute: hu, join: gu, relative: mu, sep: "/", delimiter: ":", dirname: yu, basename: Du, extname: Eu, default: Cu }), Fu = [], xu = [], Su = typeof Uint8Array != "undefined" ? Uint8Array : Array, wu = false;
      function Tu() {
        wu = true;
        for (var e2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", t2 = 0, n2 = e2.length; t2 < n2; ++t2)
          Fu[t2] = e2[t2], xu[e2.charCodeAt(t2)] = t2;
        xu["-".charCodeAt(0)] = 62, xu["_".charCodeAt(0)] = 63;
      }
      function Bu(e2, t2, n2) {
        for (var r2, i2, u2 = [], o2 = t2; o2 < n2; o2 += 3)
          r2 = (e2[o2] << 16) + (e2[o2 + 1] << 8) + e2[o2 + 2], u2.push(Fu[(i2 = r2) >> 18 & 63] + Fu[i2 >> 12 & 63] + Fu[i2 >> 6 & 63] + Fu[63 & i2]);
        return u2.join("");
      }
      function Nu(e2) {
        var t2;
        wu || Tu();
        for (var n2 = e2.length, r2 = n2 % 3, i2 = "", u2 = [], o2 = 16383, s2 = 0, a2 = n2 - r2; s2 < a2; s2 += o2)
          u2.push(Bu(e2, s2, s2 + o2 > a2 ? a2 : s2 + o2));
        return r2 === 1 ? (t2 = e2[n2 - 1], i2 += Fu[t2 >> 2], i2 += Fu[t2 << 4 & 63], i2 += "==") : r2 === 2 && (t2 = (e2[n2 - 2] << 8) + e2[n2 - 1], i2 += Fu[t2 >> 10], i2 += Fu[t2 >> 4 & 63], i2 += Fu[t2 << 2 & 63], i2 += "="), u2.push(i2), u2.join("");
      }
      function ku(e2, t2, n2, r2, i2) {
        var u2, o2, s2 = 8 * i2 - r2 - 1, a2 = (1 << s2) - 1, c2 = a2 >> 1, l2 = -7, p2 = n2 ? i2 - 1 : 0, f2 = n2 ? -1 : 1, d2 = e2[t2 + p2];
        for (p2 += f2, u2 = d2 & (1 << -l2) - 1, d2 >>= -l2, l2 += s2; l2 > 0; u2 = 256 * u2 + e2[t2 + p2], p2 += f2, l2 -= 8)
          ;
        for (o2 = u2 & (1 << -l2) - 1, u2 >>= -l2, l2 += r2; l2 > 0; o2 = 256 * o2 + e2[t2 + p2], p2 += f2, l2 -= 8)
          ;
        if (u2 === 0)
          u2 = 1 - c2;
        else {
          if (u2 === a2)
            return o2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
          o2 += Math.pow(2, r2), u2 -= c2;
        }
        return (d2 ? -1 : 1) * o2 * Math.pow(2, u2 - r2);
      }
      function Pu(e2, t2, n2, r2, i2, u2) {
        var o2, s2, a2, c2 = 8 * u2 - i2 - 1, l2 = (1 << c2) - 1, p2 = l2 >> 1, f2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = r2 ? 0 : u2 - 1, h2 = r2 ? 1 : -1, g2 = t2 < 0 || t2 === 0 && 1 / t2 < 0 ? 1 : 0;
        for (t2 = Math.abs(t2), isNaN(t2) || t2 === 1 / 0 ? (s2 = isNaN(t2) ? 1 : 0, o2 = l2) : (o2 = Math.floor(Math.log(t2) / Math.LN2), t2 * (a2 = Math.pow(2, -o2)) < 1 && (o2--, a2 *= 2), (t2 += o2 + p2 >= 1 ? f2 / a2 : f2 * Math.pow(2, 1 - p2)) * a2 >= 2 && (o2++, a2 /= 2), o2 + p2 >= l2 ? (s2 = 0, o2 = l2) : o2 + p2 >= 1 ? (s2 = (t2 * a2 - 1) * Math.pow(2, i2), o2 += p2) : (s2 = t2 * Math.pow(2, p2 - 1) * Math.pow(2, i2), o2 = 0)); i2 >= 8; e2[n2 + d2] = 255 & s2, d2 += h2, s2 /= 256, i2 -= 8)
          ;
        for (o2 = o2 << i2 | s2, c2 += i2; c2 > 0; e2[n2 + d2] = 255 & o2, d2 += h2, o2 /= 256, c2 -= 8)
          ;
        e2[n2 + d2 - h2] |= 128 * g2;
      }
      var Ou = {}.toString, Iu = Array.isArray || function(e2) {
        return Ou.call(e2) == "[object Array]";
      };
      function Lu() {
        return _u.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
      }
      function ju(e2, t2) {
        if (Lu() < t2)
          throw new RangeError("Invalid typed array length");
        return _u.TYPED_ARRAY_SUPPORT ? (e2 = new Uint8Array(t2)).__proto__ = _u.prototype : (e2 === null && (e2 = new _u(t2)), e2.length = t2), e2;
      }
      function _u(e2, t2, n2) {
        if (!(_u.TYPED_ARRAY_SUPPORT || this instanceof _u))
          return new _u(e2, t2, n2);
        if (typeof e2 == "number") {
          if (typeof t2 == "string")
            throw new Error("If encoding is specified then the first argument must be a string");
          return $u(this, e2);
        }
        return Mu(this, e2, t2, n2);
      }
      function Mu(e2, t2, n2, r2) {
        if (typeof t2 == "number")
          throw new TypeError('"value" argument must not be a number');
        return typeof ArrayBuffer != "undefined" && t2 instanceof ArrayBuffer ? function(e3, t3, n3, r3) {
          if (t3.byteLength, n3 < 0 || t3.byteLength < n3)
            throw new RangeError("'offset' is out of bounds");
          if (t3.byteLength < n3 + (r3 || 0))
            throw new RangeError("'length' is out of bounds");
          t3 = n3 === void 0 && r3 === void 0 ? new Uint8Array(t3) : r3 === void 0 ? new Uint8Array(t3, n3) : new Uint8Array(t3, n3, r3);
          _u.TYPED_ARRAY_SUPPORT ? (e3 = t3).__proto__ = _u.prototype : e3 = Vu(e3, t3);
          return e3;
        }(e2, t2, n2, r2) : typeof t2 == "string" ? function(e3, t3, n3) {
          typeof n3 == "string" && n3 !== "" || (n3 = "utf8");
          if (!_u.isEncoding(n3))
            throw new TypeError('"encoding" must be a valid string encoding');
          var r3 = 0 | Uu(t3, n3), i2 = (e3 = ju(e3, r3)).write(t3, n3);
          i2 !== r3 && (e3 = e3.slice(0, i2));
          return e3;
        }(e2, t2, n2) : function(e3, t3) {
          if (qu(t3)) {
            var n3 = 0 | Wu(t3.length);
            return (e3 = ju(e3, n3)).length === 0 || t3.copy(e3, 0, 0, n3), e3;
          }
          if (t3) {
            if (typeof ArrayBuffer != "undefined" && t3.buffer instanceof ArrayBuffer || "length" in t3)
              return typeof t3.length != "number" || (r3 = t3.length) != r3 ? ju(e3, 0) : Vu(e3, t3);
            if (t3.type === "Buffer" && Iu(t3.data))
              return Vu(e3, t3.data);
          }
          var r3;
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }(e2, t2);
      }
      function Ru(e2) {
        if (typeof e2 != "number")
          throw new TypeError('"size" argument must be a number');
        if (e2 < 0)
          throw new RangeError('"size" argument must not be negative');
      }
      function $u(e2, t2) {
        if (Ru(t2), e2 = ju(e2, t2 < 0 ? 0 : 0 | Wu(t2)), !_u.TYPED_ARRAY_SUPPORT)
          for (var n2 = 0; n2 < t2; ++n2)
            e2[n2] = 0;
        return e2;
      }
      function Vu(e2, t2) {
        var n2 = t2.length < 0 ? 0 : 0 | Wu(t2.length);
        e2 = ju(e2, n2);
        for (var r2 = 0; r2 < n2; r2 += 1)
          e2[r2] = 255 & t2[r2];
        return e2;
      }
      function Wu(e2) {
        if (e2 >= Lu())
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Lu().toString(16) + " bytes");
        return 0 | e2;
      }
      function qu(e2) {
        return !(e2 == null || !e2._isBuffer);
      }
      function Uu(e2, t2) {
        if (qu(e2))
          return e2.length;
        if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(e2) || e2 instanceof ArrayBuffer))
          return e2.byteLength;
        typeof e2 != "string" && (e2 = "" + e2);
        var n2 = e2.length;
        if (n2 === 0)
          return 0;
        for (var r2 = false; ; )
          switch (t2) {
            case "ascii":
            case "latin1":
            case "binary":
              return n2;
            case "utf8":
            case "utf-8":
            case void 0:
              return Do(e2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * n2;
            case "hex":
              return n2 >>> 1;
            case "base64":
              return Eo(e2).length;
            default:
              if (r2)
                return Do(e2).length;
              t2 = ("" + t2).toLowerCase(), r2 = true;
          }
      }
      function zu(e2, t2, n2) {
        var r2 = false;
        if ((t2 === void 0 || t2 < 0) && (t2 = 0), t2 > this.length)
          return "";
        if ((n2 === void 0 || n2 > this.length) && (n2 = this.length), n2 <= 0)
          return "";
        if ((n2 >>>= 0) <= (t2 >>>= 0))
          return "";
        for (e2 || (e2 = "utf8"); ; )
          switch (e2) {
            case "hex":
              return oo(this, t2, n2);
            case "utf8":
            case "utf-8":
              return no(this, t2, n2);
            case "ascii":
              return io(this, t2, n2);
            case "latin1":
            case "binary":
              return uo(this, t2, n2);
            case "base64":
              return to(this, t2, n2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return so(this, t2, n2);
            default:
              if (r2)
                throw new TypeError("Unknown encoding: " + e2);
              e2 = (e2 + "").toLowerCase(), r2 = true;
          }
      }
      function Gu(e2, t2, n2) {
        var r2 = e2[t2];
        e2[t2] = e2[n2], e2[n2] = r2;
      }
      function Hu(e2, t2, n2, r2, i2) {
        if (e2.length === 0)
          return -1;
        if (typeof n2 == "string" ? (r2 = n2, n2 = 0) : n2 > 2147483647 ? n2 = 2147483647 : n2 < -2147483648 && (n2 = -2147483648), n2 = +n2, isNaN(n2) && (n2 = i2 ? 0 : e2.length - 1), n2 < 0 && (n2 = e2.length + n2), n2 >= e2.length) {
          if (i2)
            return -1;
          n2 = e2.length - 1;
        } else if (n2 < 0) {
          if (!i2)
            return -1;
          n2 = 0;
        }
        if (typeof t2 == "string" && (t2 = _u.from(t2, r2)), qu(t2))
          return t2.length === 0 ? -1 : Ju(e2, t2, n2, r2, i2);
        if (typeof t2 == "number")
          return t2 &= 255, _u.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? i2 ? Uint8Array.prototype.indexOf.call(e2, t2, n2) : Uint8Array.prototype.lastIndexOf.call(e2, t2, n2) : Ju(e2, [t2], n2, r2, i2);
        throw new TypeError("val must be string, number or Buffer");
      }
      function Ju(e2, t2, n2, r2, i2) {
        var u2, o2 = 1, s2 = e2.length, a2 = t2.length;
        if (r2 !== void 0 && ((r2 = String(r2).toLowerCase()) === "ucs2" || r2 === "ucs-2" || r2 === "utf16le" || r2 === "utf-16le")) {
          if (e2.length < 2 || t2.length < 2)
            return -1;
          o2 = 2, s2 /= 2, a2 /= 2, n2 /= 2;
        }
        function c2(e3, t3) {
          return o2 === 1 ? e3[t3] : e3.readUInt16BE(t3 * o2);
        }
        if (i2) {
          var l2 = -1;
          for (u2 = n2; u2 < s2; u2++)
            if (c2(e2, u2) === c2(t2, l2 === -1 ? 0 : u2 - l2)) {
              if (l2 === -1 && (l2 = u2), u2 - l2 + 1 === a2)
                return l2 * o2;
            } else
              l2 !== -1 && (u2 -= u2 - l2), l2 = -1;
        } else
          for (n2 + a2 > s2 && (n2 = s2 - a2), u2 = n2; u2 >= 0; u2--) {
            for (var p2 = true, f2 = 0; f2 < a2; f2++)
              if (c2(e2, u2 + f2) !== c2(t2, f2)) {
                p2 = false;
                break;
              }
            if (p2)
              return u2;
          }
        return -1;
      }
      function Xu(e2, t2, n2, r2) {
        n2 = Number(n2) || 0;
        var i2 = e2.length - n2;
        r2 ? (r2 = Number(r2)) > i2 && (r2 = i2) : r2 = i2;
        var u2 = t2.length;
        if (u2 % 2 != 0)
          throw new TypeError("Invalid hex string");
        r2 > u2 / 2 && (r2 = u2 / 2);
        for (var o2 = 0; o2 < r2; ++o2) {
          var s2 = parseInt(t2.substr(2 * o2, 2), 16);
          if (isNaN(s2))
            return o2;
          e2[n2 + o2] = s2;
        }
        return o2;
      }
      function Yu(e2, t2, n2, r2) {
        return Co(Do(t2, e2.length - n2), e2, n2, r2);
      }
      function Ku(e2, t2, n2, r2) {
        return Co(function(e3) {
          for (var t3 = [], n3 = 0; n3 < e3.length; ++n3)
            t3.push(255 & e3.charCodeAt(n3));
          return t3;
        }(t2), e2, n2, r2);
      }
      function Qu(e2, t2, n2, r2) {
        return Ku(e2, t2, n2, r2);
      }
      function Zu(e2, t2, n2, r2) {
        return Co(Eo(t2), e2, n2, r2);
      }
      function eo(e2, t2, n2, r2) {
        return Co(function(e3, t3) {
          for (var n3, r3, i2, u2 = [], o2 = 0; o2 < e3.length && !((t3 -= 2) < 0); ++o2)
            r3 = (n3 = e3.charCodeAt(o2)) >> 8, i2 = n3 % 256, u2.push(i2), u2.push(r3);
          return u2;
        }(t2, e2.length - n2), e2, n2, r2);
      }
      function to(e2, t2, n2) {
        return t2 === 0 && n2 === e2.length ? Nu(e2) : Nu(e2.slice(t2, n2));
      }
      function no(e2, t2, n2) {
        n2 = Math.min(e2.length, n2);
        for (var r2 = [], i2 = t2; i2 < n2; ) {
          var u2, o2, s2, a2, c2 = e2[i2], l2 = null, p2 = c2 > 239 ? 4 : c2 > 223 ? 3 : c2 > 191 ? 2 : 1;
          if (i2 + p2 <= n2)
            switch (p2) {
              case 1:
                c2 < 128 && (l2 = c2);
                break;
              case 2:
                (192 & (u2 = e2[i2 + 1])) == 128 && (a2 = (31 & c2) << 6 | 63 & u2) > 127 && (l2 = a2);
                break;
              case 3:
                u2 = e2[i2 + 1], o2 = e2[i2 + 2], (192 & u2) == 128 && (192 & o2) == 128 && (a2 = (15 & c2) << 12 | (63 & u2) << 6 | 63 & o2) > 2047 && (a2 < 55296 || a2 > 57343) && (l2 = a2);
                break;
              case 4:
                u2 = e2[i2 + 1], o2 = e2[i2 + 2], s2 = e2[i2 + 3], (192 & u2) == 128 && (192 & o2) == 128 && (192 & s2) == 128 && (a2 = (15 & c2) << 18 | (63 & u2) << 12 | (63 & o2) << 6 | 63 & s2) > 65535 && a2 < 1114112 && (l2 = a2);
            }
          l2 === null ? (l2 = 65533, p2 = 1) : l2 > 65535 && (l2 -= 65536, r2.push(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), r2.push(l2), i2 += p2;
        }
        return function(e3) {
          var t3 = e3.length;
          if (t3 <= ro)
            return String.fromCharCode.apply(String, e3);
          var n3 = "", r3 = 0;
          for (; r3 < t3; )
            n3 += String.fromCharCode.apply(String, e3.slice(r3, r3 += ro));
          return n3;
        }(r2);
      }
      _u.TYPED_ARRAY_SUPPORT = ir.TYPED_ARRAY_SUPPORT === void 0 || ir.TYPED_ARRAY_SUPPORT, _u.poolSize = 8192, _u._augment = function(e2) {
        return e2.__proto__ = _u.prototype, e2;
      }, _u.from = function(e2, t2, n2) {
        return Mu(null, e2, t2, n2);
      }, _u.TYPED_ARRAY_SUPPORT && (_u.prototype.__proto__ = Uint8Array.prototype, _u.__proto__ = Uint8Array), _u.alloc = function(e2, t2, n2) {
        return function(e3, t3, n3, r2) {
          return Ru(t3), t3 <= 0 ? ju(e3, t3) : n3 !== void 0 ? typeof r2 == "string" ? ju(e3, t3).fill(n3, r2) : ju(e3, t3).fill(n3) : ju(e3, t3);
        }(null, e2, t2, n2);
      }, _u.allocUnsafe = function(e2) {
        return $u(null, e2);
      }, _u.allocUnsafeSlow = function(e2) {
        return $u(null, e2);
      }, _u.isBuffer = bo, _u.compare = function(e2, t2) {
        if (!qu(e2) || !qu(t2))
          throw new TypeError("Arguments must be Buffers");
        if (e2 === t2)
          return 0;
        for (var n2 = e2.length, r2 = t2.length, i2 = 0, u2 = Math.min(n2, r2); i2 < u2; ++i2)
          if (e2[i2] !== t2[i2]) {
            n2 = e2[i2], r2 = t2[i2];
            break;
          }
        return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
      }, _u.isEncoding = function(e2) {
        switch (String(e2).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, _u.concat = function(e2, t2) {
        if (!Iu(e2))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (e2.length === 0)
          return _u.alloc(0);
        var n2;
        if (t2 === void 0)
          for (t2 = 0, n2 = 0; n2 < e2.length; ++n2)
            t2 += e2[n2].length;
        var r2 = _u.allocUnsafe(t2), i2 = 0;
        for (n2 = 0; n2 < e2.length; ++n2) {
          var u2 = e2[n2];
          if (!qu(u2))
            throw new TypeError('"list" argument must be an Array of Buffers');
          u2.copy(r2, i2), i2 += u2.length;
        }
        return r2;
      }, _u.byteLength = Uu, _u.prototype._isBuffer = true, _u.prototype.swap16 = function() {
        var e2 = this.length;
        if (e2 % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var t2 = 0; t2 < e2; t2 += 2)
          Gu(this, t2, t2 + 1);
        return this;
      }, _u.prototype.swap32 = function() {
        var e2 = this.length;
        if (e2 % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var t2 = 0; t2 < e2; t2 += 4)
          Gu(this, t2, t2 + 3), Gu(this, t2 + 1, t2 + 2);
        return this;
      }, _u.prototype.swap64 = function() {
        var e2 = this.length;
        if (e2 % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var t2 = 0; t2 < e2; t2 += 8)
          Gu(this, t2, t2 + 7), Gu(this, t2 + 1, t2 + 6), Gu(this, t2 + 2, t2 + 5), Gu(this, t2 + 3, t2 + 4);
        return this;
      }, _u.prototype.toString = function() {
        var e2 = 0 | this.length;
        return e2 === 0 ? "" : arguments.length === 0 ? no(this, 0, e2) : zu.apply(this, arguments);
      }, _u.prototype.equals = function(e2) {
        if (!qu(e2))
          throw new TypeError("Argument must be a Buffer");
        return this === e2 || _u.compare(this, e2) === 0;
      }, _u.prototype.inspect = function() {
        var e2 = "";
        return this.length > 0 && (e2 = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (e2 += " ... ")), "<Buffer " + e2 + ">";
      }, _u.prototype.compare = function(e2, t2, n2, r2, i2) {
        if (!qu(e2))
          throw new TypeError("Argument must be a Buffer");
        if (t2 === void 0 && (t2 = 0), n2 === void 0 && (n2 = e2 ? e2.length : 0), r2 === void 0 && (r2 = 0), i2 === void 0 && (i2 = this.length), t2 < 0 || n2 > e2.length || r2 < 0 || i2 > this.length)
          throw new RangeError("out of range index");
        if (r2 >= i2 && t2 >= n2)
          return 0;
        if (r2 >= i2)
          return -1;
        if (t2 >= n2)
          return 1;
        if (this === e2)
          return 0;
        for (var u2 = (i2 >>>= 0) - (r2 >>>= 0), o2 = (n2 >>>= 0) - (t2 >>>= 0), s2 = Math.min(u2, o2), a2 = this.slice(r2, i2), c2 = e2.slice(t2, n2), l2 = 0; l2 < s2; ++l2)
          if (a2[l2] !== c2[l2]) {
            u2 = a2[l2], o2 = c2[l2];
            break;
          }
        return u2 < o2 ? -1 : o2 < u2 ? 1 : 0;
      }, _u.prototype.includes = function(e2, t2, n2) {
        return this.indexOf(e2, t2, n2) !== -1;
      }, _u.prototype.indexOf = function(e2, t2, n2) {
        return Hu(this, e2, t2, n2, true);
      }, _u.prototype.lastIndexOf = function(e2, t2, n2) {
        return Hu(this, e2, t2, n2, false);
      }, _u.prototype.write = function(e2, t2, n2, r2) {
        if (t2 === void 0)
          r2 = "utf8", n2 = this.length, t2 = 0;
        else if (n2 === void 0 && typeof t2 == "string")
          r2 = t2, n2 = this.length, t2 = 0;
        else {
          if (!isFinite(t2))
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          t2 |= 0, isFinite(n2) ? (n2 |= 0, r2 === void 0 && (r2 = "utf8")) : (r2 = n2, n2 = void 0);
        }
        var i2 = this.length - t2;
        if ((n2 === void 0 || n2 > i2) && (n2 = i2), e2.length > 0 && (n2 < 0 || t2 < 0) || t2 > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        r2 || (r2 = "utf8");
        for (var u2 = false; ; )
          switch (r2) {
            case "hex":
              return Xu(this, e2, t2, n2);
            case "utf8":
            case "utf-8":
              return Yu(this, e2, t2, n2);
            case "ascii":
              return Ku(this, e2, t2, n2);
            case "latin1":
            case "binary":
              return Qu(this, e2, t2, n2);
            case "base64":
              return Zu(this, e2, t2, n2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return eo(this, e2, t2, n2);
            default:
              if (u2)
                throw new TypeError("Unknown encoding: " + r2);
              r2 = ("" + r2).toLowerCase(), u2 = true;
          }
      }, _u.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      var ro = 4096;
      function io(e2, t2, n2) {
        var r2 = "";
        n2 = Math.min(e2.length, n2);
        for (var i2 = t2; i2 < n2; ++i2)
          r2 += String.fromCharCode(127 & e2[i2]);
        return r2;
      }
      function uo(e2, t2, n2) {
        var r2 = "";
        n2 = Math.min(e2.length, n2);
        for (var i2 = t2; i2 < n2; ++i2)
          r2 += String.fromCharCode(e2[i2]);
        return r2;
      }
      function oo(e2, t2, n2) {
        var r2 = e2.length;
        (!t2 || t2 < 0) && (t2 = 0), (!n2 || n2 < 0 || n2 > r2) && (n2 = r2);
        for (var i2 = "", u2 = t2; u2 < n2; ++u2)
          i2 += yo(e2[u2]);
        return i2;
      }
      function so(e2, t2, n2) {
        for (var r2 = e2.slice(t2, n2), i2 = "", u2 = 0; u2 < r2.length; u2 += 2)
          i2 += String.fromCharCode(r2[u2] + 256 * r2[u2 + 1]);
        return i2;
      }
      function ao(e2, t2, n2) {
        if (e2 % 1 != 0 || e2 < 0)
          throw new RangeError("offset is not uint");
        if (e2 + t2 > n2)
          throw new RangeError("Trying to access beyond buffer length");
      }
      function co(e2, t2, n2, r2, i2, u2) {
        if (!qu(e2))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (t2 > i2 || t2 < u2)
          throw new RangeError('"value" argument is out of bounds');
        if (n2 + r2 > e2.length)
          throw new RangeError("Index out of range");
      }
      function lo(e2, t2, n2, r2) {
        t2 < 0 && (t2 = 65535 + t2 + 1);
        for (var i2 = 0, u2 = Math.min(e2.length - n2, 2); i2 < u2; ++i2)
          e2[n2 + i2] = (t2 & 255 << 8 * (r2 ? i2 : 1 - i2)) >>> 8 * (r2 ? i2 : 1 - i2);
      }
      function po(e2, t2, n2, r2) {
        t2 < 0 && (t2 = 4294967295 + t2 + 1);
        for (var i2 = 0, u2 = Math.min(e2.length - n2, 4); i2 < u2; ++i2)
          e2[n2 + i2] = t2 >>> 8 * (r2 ? i2 : 3 - i2) & 255;
      }
      function fo(e2, t2, n2, r2, i2, u2) {
        if (n2 + r2 > e2.length)
          throw new RangeError("Index out of range");
        if (n2 < 0)
          throw new RangeError("Index out of range");
      }
      function ho(e2, t2, n2, r2, i2) {
        return i2 || fo(e2, 0, n2, 4), Pu(e2, t2, n2, r2, 23, 4), n2 + 4;
      }
      function go(e2, t2, n2, r2, i2) {
        return i2 || fo(e2, 0, n2, 8), Pu(e2, t2, n2, r2, 52, 8), n2 + 8;
      }
      _u.prototype.slice = function(e2, t2) {
        var n2, r2 = this.length;
        if ((e2 = ~~e2) < 0 ? (e2 += r2) < 0 && (e2 = 0) : e2 > r2 && (e2 = r2), (t2 = t2 === void 0 ? r2 : ~~t2) < 0 ? (t2 += r2) < 0 && (t2 = 0) : t2 > r2 && (t2 = r2), t2 < e2 && (t2 = e2), _u.TYPED_ARRAY_SUPPORT)
          (n2 = this.subarray(e2, t2)).__proto__ = _u.prototype;
        else {
          var i2 = t2 - e2;
          n2 = new _u(i2, void 0);
          for (var u2 = 0; u2 < i2; ++u2)
            n2[u2] = this[u2 + e2];
        }
        return n2;
      }, _u.prototype.readUIntLE = function(e2, t2, n2) {
        e2 |= 0, t2 |= 0, n2 || ao(e2, t2, this.length);
        for (var r2 = this[e2], i2 = 1, u2 = 0; ++u2 < t2 && (i2 *= 256); )
          r2 += this[e2 + u2] * i2;
        return r2;
      }, _u.prototype.readUIntBE = function(e2, t2, n2) {
        e2 |= 0, t2 |= 0, n2 || ao(e2, t2, this.length);
        for (var r2 = this[e2 + --t2], i2 = 1; t2 > 0 && (i2 *= 256); )
          r2 += this[e2 + --t2] * i2;
        return r2;
      }, _u.prototype.readUInt8 = function(e2, t2) {
        return t2 || ao(e2, 1, this.length), this[e2];
      }, _u.prototype.readUInt16LE = function(e2, t2) {
        return t2 || ao(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
      }, _u.prototype.readUInt16BE = function(e2, t2) {
        return t2 || ao(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
      }, _u.prototype.readUInt32LE = function(e2, t2) {
        return t2 || ao(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
      }, _u.prototype.readUInt32BE = function(e2, t2) {
        return t2 || ao(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
      }, _u.prototype.readIntLE = function(e2, t2, n2) {
        e2 |= 0, t2 |= 0, n2 || ao(e2, t2, this.length);
        for (var r2 = this[e2], i2 = 1, u2 = 0; ++u2 < t2 && (i2 *= 256); )
          r2 += this[e2 + u2] * i2;
        return r2 >= (i2 *= 128) && (r2 -= Math.pow(2, 8 * t2)), r2;
      }, _u.prototype.readIntBE = function(e2, t2, n2) {
        e2 |= 0, t2 |= 0, n2 || ao(e2, t2, this.length);
        for (var r2 = t2, i2 = 1, u2 = this[e2 + --r2]; r2 > 0 && (i2 *= 256); )
          u2 += this[e2 + --r2] * i2;
        return u2 >= (i2 *= 128) && (u2 -= Math.pow(2, 8 * t2)), u2;
      }, _u.prototype.readInt8 = function(e2, t2) {
        return t2 || ao(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
      }, _u.prototype.readInt16LE = function(e2, t2) {
        t2 || ao(e2, 2, this.length);
        var n2 = this[e2] | this[e2 + 1] << 8;
        return 32768 & n2 ? 4294901760 | n2 : n2;
      }, _u.prototype.readInt16BE = function(e2, t2) {
        t2 || ao(e2, 2, this.length);
        var n2 = this[e2 + 1] | this[e2] << 8;
        return 32768 & n2 ? 4294901760 | n2 : n2;
      }, _u.prototype.readInt32LE = function(e2, t2) {
        return t2 || ao(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
      }, _u.prototype.readInt32BE = function(e2, t2) {
        return t2 || ao(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
      }, _u.prototype.readFloatLE = function(e2, t2) {
        return t2 || ao(e2, 4, this.length), ku(this, e2, true, 23, 4);
      }, _u.prototype.readFloatBE = function(e2, t2) {
        return t2 || ao(e2, 4, this.length), ku(this, e2, false, 23, 4);
      }, _u.prototype.readDoubleLE = function(e2, t2) {
        return t2 || ao(e2, 8, this.length), ku(this, e2, true, 52, 8);
      }, _u.prototype.readDoubleBE = function(e2, t2) {
        return t2 || ao(e2, 8, this.length), ku(this, e2, false, 52, 8);
      }, _u.prototype.writeUIntLE = function(e2, t2, n2, r2) {
        (e2 = +e2, t2 |= 0, n2 |= 0, r2) || co(this, e2, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
        var i2 = 1, u2 = 0;
        for (this[t2] = 255 & e2; ++u2 < n2 && (i2 *= 256); )
          this[t2 + u2] = e2 / i2 & 255;
        return t2 + n2;
      }, _u.prototype.writeUIntBE = function(e2, t2, n2, r2) {
        (e2 = +e2, t2 |= 0, n2 |= 0, r2) || co(this, e2, t2, n2, Math.pow(2, 8 * n2) - 1, 0);
        var i2 = n2 - 1, u2 = 1;
        for (this[t2 + i2] = 255 & e2; --i2 >= 0 && (u2 *= 256); )
          this[t2 + i2] = e2 / u2 & 255;
        return t2 + n2;
      }, _u.prototype.writeUInt8 = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || co(this, e2, t2, 1, 255, 0), _u.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), this[t2] = 255 & e2, t2 + 1;
      }, _u.prototype.writeUInt16LE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || co(this, e2, t2, 2, 65535, 0), _u.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8) : lo(this, e2, t2, true), t2 + 2;
      }, _u.prototype.writeUInt16BE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || co(this, e2, t2, 2, 65535, 0), _u.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 8, this[t2 + 1] = 255 & e2) : lo(this, e2, t2, false), t2 + 2;
      }, _u.prototype.writeUInt32LE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || co(this, e2, t2, 4, 4294967295, 0), _u.TYPED_ARRAY_SUPPORT ? (this[t2 + 3] = e2 >>> 24, this[t2 + 2] = e2 >>> 16, this[t2 + 1] = e2 >>> 8, this[t2] = 255 & e2) : po(this, e2, t2, true), t2 + 4;
      }, _u.prototype.writeUInt32BE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || co(this, e2, t2, 4, 4294967295, 0), _u.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 24, this[t2 + 1] = e2 >>> 16, this[t2 + 2] = e2 >>> 8, this[t2 + 3] = 255 & e2) : po(this, e2, t2, false), t2 + 4;
      }, _u.prototype.writeIntLE = function(e2, t2, n2, r2) {
        if (e2 = +e2, t2 |= 0, !r2) {
          var i2 = Math.pow(2, 8 * n2 - 1);
          co(this, e2, t2, n2, i2 - 1, -i2);
        }
        var u2 = 0, o2 = 1, s2 = 0;
        for (this[t2] = 255 & e2; ++u2 < n2 && (o2 *= 256); )
          e2 < 0 && s2 === 0 && this[t2 + u2 - 1] !== 0 && (s2 = 1), this[t2 + u2] = (e2 / o2 >> 0) - s2 & 255;
        return t2 + n2;
      }, _u.prototype.writeIntBE = function(e2, t2, n2, r2) {
        if (e2 = +e2, t2 |= 0, !r2) {
          var i2 = Math.pow(2, 8 * n2 - 1);
          co(this, e2, t2, n2, i2 - 1, -i2);
        }
        var u2 = n2 - 1, o2 = 1, s2 = 0;
        for (this[t2 + u2] = 255 & e2; --u2 >= 0 && (o2 *= 256); )
          e2 < 0 && s2 === 0 && this[t2 + u2 + 1] !== 0 && (s2 = 1), this[t2 + u2] = (e2 / o2 >> 0) - s2 & 255;
        return t2 + n2;
      }, _u.prototype.writeInt8 = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || co(this, e2, t2, 1, 127, -128), _u.TYPED_ARRAY_SUPPORT || (e2 = Math.floor(e2)), e2 < 0 && (e2 = 255 + e2 + 1), this[t2] = 255 & e2, t2 + 1;
      }, _u.prototype.writeInt16LE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || co(this, e2, t2, 2, 32767, -32768), _u.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8) : lo(this, e2, t2, true), t2 + 2;
      }, _u.prototype.writeInt16BE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || co(this, e2, t2, 2, 32767, -32768), _u.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 8, this[t2 + 1] = 255 & e2) : lo(this, e2, t2, false), t2 + 2;
      }, _u.prototype.writeInt32LE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || co(this, e2, t2, 4, 2147483647, -2147483648), _u.TYPED_ARRAY_SUPPORT ? (this[t2] = 255 & e2, this[t2 + 1] = e2 >>> 8, this[t2 + 2] = e2 >>> 16, this[t2 + 3] = e2 >>> 24) : po(this, e2, t2, true), t2 + 4;
      }, _u.prototype.writeInt32BE = function(e2, t2, n2) {
        return e2 = +e2, t2 |= 0, n2 || co(this, e2, t2, 4, 2147483647, -2147483648), e2 < 0 && (e2 = 4294967295 + e2 + 1), _u.TYPED_ARRAY_SUPPORT ? (this[t2] = e2 >>> 24, this[t2 + 1] = e2 >>> 16, this[t2 + 2] = e2 >>> 8, this[t2 + 3] = 255 & e2) : po(this, e2, t2, false), t2 + 4;
      }, _u.prototype.writeFloatLE = function(e2, t2, n2) {
        return ho(this, e2, t2, true, n2);
      }, _u.prototype.writeFloatBE = function(e2, t2, n2) {
        return ho(this, e2, t2, false, n2);
      }, _u.prototype.writeDoubleLE = function(e2, t2, n2) {
        return go(this, e2, t2, true, n2);
      }, _u.prototype.writeDoubleBE = function(e2, t2, n2) {
        return go(this, e2, t2, false, n2);
      }, _u.prototype.copy = function(e2, t2, n2, r2) {
        if (n2 || (n2 = 0), r2 || r2 === 0 || (r2 = this.length), t2 >= e2.length && (t2 = e2.length), t2 || (t2 = 0), r2 > 0 && r2 < n2 && (r2 = n2), r2 === n2)
          return 0;
        if (e2.length === 0 || this.length === 0)
          return 0;
        if (t2 < 0)
          throw new RangeError("targetStart out of bounds");
        if (n2 < 0 || n2 >= this.length)
          throw new RangeError("sourceStart out of bounds");
        if (r2 < 0)
          throw new RangeError("sourceEnd out of bounds");
        r2 > this.length && (r2 = this.length), e2.length - t2 < r2 - n2 && (r2 = e2.length - t2 + n2);
        var i2, u2 = r2 - n2;
        if (this === e2 && n2 < t2 && t2 < r2)
          for (i2 = u2 - 1; i2 >= 0; --i2)
            e2[i2 + t2] = this[i2 + n2];
        else if (u2 < 1e3 || !_u.TYPED_ARRAY_SUPPORT)
          for (i2 = 0; i2 < u2; ++i2)
            e2[i2 + t2] = this[i2 + n2];
        else
          Uint8Array.prototype.set.call(e2, this.subarray(n2, n2 + u2), t2);
        return u2;
      }, _u.prototype.fill = function(e2, t2, n2, r2) {
        if (typeof e2 == "string") {
          if (typeof t2 == "string" ? (r2 = t2, t2 = 0, n2 = this.length) : typeof n2 == "string" && (r2 = n2, n2 = this.length), e2.length === 1) {
            var i2 = e2.charCodeAt(0);
            i2 < 256 && (e2 = i2);
          }
          if (r2 !== void 0 && typeof r2 != "string")
            throw new TypeError("encoding must be a string");
          if (typeof r2 == "string" && !_u.isEncoding(r2))
            throw new TypeError("Unknown encoding: " + r2);
        } else
          typeof e2 == "number" && (e2 &= 255);
        if (t2 < 0 || this.length < t2 || this.length < n2)
          throw new RangeError("Out of range index");
        if (n2 <= t2)
          return this;
        var u2;
        if (t2 >>>= 0, n2 = n2 === void 0 ? this.length : n2 >>> 0, e2 || (e2 = 0), typeof e2 == "number")
          for (u2 = t2; u2 < n2; ++u2)
            this[u2] = e2;
        else {
          var o2 = qu(e2) ? e2 : Do(new _u(e2, r2).toString()), s2 = o2.length;
          for (u2 = 0; u2 < n2 - t2; ++u2)
            this[u2 + t2] = o2[u2 % s2];
        }
        return this;
      };
      var mo = /[^+\/0-9A-Za-z-_]/g;
      function yo(e2) {
        return e2 < 16 ? "0" + e2.toString(16) : e2.toString(16);
      }
      function Do(e2, t2) {
        var n2;
        t2 = t2 || 1 / 0;
        for (var r2 = e2.length, i2 = null, u2 = [], o2 = 0; o2 < r2; ++o2) {
          if ((n2 = e2.charCodeAt(o2)) > 55295 && n2 < 57344) {
            if (!i2) {
              if (n2 > 56319) {
                (t2 -= 3) > -1 && u2.push(239, 191, 189);
                continue;
              }
              if (o2 + 1 === r2) {
                (t2 -= 3) > -1 && u2.push(239, 191, 189);
                continue;
              }
              i2 = n2;
              continue;
            }
            if (n2 < 56320) {
              (t2 -= 3) > -1 && u2.push(239, 191, 189), i2 = n2;
              continue;
            }
            n2 = 65536 + (i2 - 55296 << 10 | n2 - 56320);
          } else
            i2 && (t2 -= 3) > -1 && u2.push(239, 191, 189);
          if (i2 = null, n2 < 128) {
            if ((t2 -= 1) < 0)
              break;
            u2.push(n2);
          } else if (n2 < 2048) {
            if ((t2 -= 2) < 0)
              break;
            u2.push(n2 >> 6 | 192, 63 & n2 | 128);
          } else if (n2 < 65536) {
            if ((t2 -= 3) < 0)
              break;
            u2.push(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128);
          } else {
            if (!(n2 < 1114112))
              throw new Error("Invalid code point");
            if ((t2 -= 4) < 0)
              break;
            u2.push(n2 >> 18 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128);
          }
        }
        return u2;
      }
      function Eo(e2) {
        return function(e3) {
          var t2, n2, r2, i2, u2, o2;
          wu || Tu();
          var s2 = e3.length;
          if (s2 % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          u2 = e3[s2 - 2] === "=" ? 2 : e3[s2 - 1] === "=" ? 1 : 0, o2 = new Su(3 * s2 / 4 - u2), r2 = u2 > 0 ? s2 - 4 : s2;
          var a2 = 0;
          for (t2 = 0, n2 = 0; t2 < r2; t2 += 4, n2 += 3)
            i2 = xu[e3.charCodeAt(t2)] << 18 | xu[e3.charCodeAt(t2 + 1)] << 12 | xu[e3.charCodeAt(t2 + 2)] << 6 | xu[e3.charCodeAt(t2 + 3)], o2[a2++] = i2 >> 16 & 255, o2[a2++] = i2 >> 8 & 255, o2[a2++] = 255 & i2;
          return u2 === 2 ? (i2 = xu[e3.charCodeAt(t2)] << 2 | xu[e3.charCodeAt(t2 + 1)] >> 4, o2[a2++] = 255 & i2) : u2 === 1 && (i2 = xu[e3.charCodeAt(t2)] << 10 | xu[e3.charCodeAt(t2 + 1)] << 4 | xu[e3.charCodeAt(t2 + 2)] >> 2, o2[a2++] = i2 >> 8 & 255, o2[a2++] = 255 & i2), o2;
        }(function(e3) {
          if ((e3 = function(e4) {
            return e4.trim ? e4.trim() : e4.replace(/^\s+|\s+$/g, "");
          }(e3).replace(mo, "")).length < 2)
            return "";
          for (; e3.length % 4 != 0; )
            e3 += "=";
          return e3;
        }(e2));
      }
      function Co(e2, t2, n2, r2) {
        for (var i2 = 0; i2 < r2 && !(i2 + n2 >= t2.length || i2 >= e2.length); ++i2)
          t2[i2 + n2] = e2[i2];
        return i2;
      }
      function bo(e2) {
        return e2 != null && (!!e2._isBuffer || Ao(e2) || function(e3) {
          return typeof e3.readFloatLE == "function" && typeof e3.slice == "function" && Ao(e3.slice(0, 0));
        }(e2));
      }
      function Ao(e2) {
        return !!e2.constructor && typeof e2.constructor.isBuffer == "function" && e2.constructor.isBuffer(e2);
      }
      var vo = n(au);
      var Fo = class {
        constructor(e2, t2) {
          (t2 = t2 || {}).readChunk || (t2.readChunk = 1024), t2.newLineCharacter ? t2.newLineCharacter = t2.newLineCharacter.charCodeAt(0) : t2.newLineCharacter = 10, this.fd = typeof e2 == "number" ? e2 : vo.openSync(e2, "r"), this.options = t2, this.newLineCharacter = t2.newLineCharacter, this.reset();
        }
        _searchInBuffer(e2, t2) {
          let n2 = -1;
          for (let r2 = 0; r2 <= e2.length; r2++) {
            if (e2[r2] === t2) {
              n2 = r2;
              break;
            }
          }
          return n2;
        }
        reset() {
          this.eofReached = false, this.linesCache = [], this.fdPosition = 0;
        }
        close() {
          vo.closeSync(this.fd), this.fd = null;
        }
        _extractLines(e2) {
          let t2;
          const n2 = [];
          let r2 = 0, i2 = 0;
          for (; ; ) {
            let u3 = e2[r2++];
            if (u3 === this.newLineCharacter)
              t2 = e2.slice(i2, r2), n2.push(t2), i2 = r2;
            else if (u3 === void 0)
              break;
          }
          let u2 = e2.slice(i2, r2);
          return u2.length && n2.push(u2), n2;
        }
        _readChunk(e2) {
          let t2, n2 = 0;
          const r2 = [];
          do {
            const e3 = new _u(this.options.readChunk);
            t2 = vo.readSync(this.fd, e3, 0, this.options.readChunk, this.fdPosition), n2 += t2, this.fdPosition = this.fdPosition + t2, r2.push(e3);
          } while (t2 && this._searchInBuffer(r2[r2.length - 1], this.options.newLineCharacter) === -1);
          let i2 = _u.concat(r2);
          return t2 < this.options.readChunk && (this.eofReached = true, i2 = i2.slice(0, n2)), n2 && (this.linesCache = this._extractLines(i2), e2 && (this.linesCache[0] = _u.concat([e2, this.linesCache[0]]))), n2;
        }
        next() {
          if (!this.fd)
            return false;
          let e2, t2 = false;
          if (this.eofReached && this.linesCache.length === 0)
            return t2;
          if (this.linesCache.length || (e2 = this._readChunk()), this.linesCache.length) {
            t2 = this.linesCache.shift();
            t2[t2.length - 1] !== this.newLineCharacter && (e2 = this._readChunk(t2), e2 && (t2 = this.linesCache.shift()));
          }
          return this.eofReached && this.linesCache.length === 0 && this.close(), t2 && t2[t2.length - 1] === this.newLineCharacter && (t2 = t2.slice(0, t2.length - 1)), t2;
        }
      };
      class xo extends Error {
      }
      class So extends Error {
      }
      class wo extends Error {
      }
      class To extends Error {
      }
      var Bo = { ConfigError: xo, DebugError: So, UndefinedParserError: wo, ArgExpansionBailout: To }, No = function(e2, t2) {
        return (No = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
          e3.__proto__ = t3;
        } || function(e3, t3) {
          for (var n2 in t3)
            t3.hasOwnProperty(n2) && (e3[n2] = t3[n2]);
        })(e2, t2);
      };
      var ko = function() {
        return (ko = Object.assign || function(e2) {
          for (var t2, n2 = 1, r2 = arguments.length; n2 < r2; n2++)
            for (var i2 in t2 = arguments[n2])
              Object.prototype.hasOwnProperty.call(t2, i2) && (e2[i2] = t2[i2]);
          return e2;
        }).apply(this, arguments);
      };
      function Po(e2) {
        var t2 = typeof Symbol == "function" && Symbol.iterator, n2 = t2 && e2[t2], r2 = 0;
        if (n2)
          return n2.call(e2);
        if (e2 && typeof e2.length == "number")
          return { next: function() {
            return e2 && r2 >= e2.length && (e2 = void 0), { value: e2 && e2[r2++], done: !e2 };
          } };
        throw new TypeError(t2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      }
      function Oo(e2, t2) {
        var n2 = typeof Symbol == "function" && e2[Symbol.iterator];
        if (!n2)
          return e2;
        var r2, i2, u2 = n2.call(e2), o2 = [];
        try {
          for (; (t2 === void 0 || t2-- > 0) && !(r2 = u2.next()).done; )
            o2.push(r2.value);
        } catch (e3) {
          i2 = { error: e3 };
        } finally {
          try {
            r2 && !r2.done && (n2 = u2.return) && n2.call(u2);
          } finally {
            if (i2)
              throw i2.error;
          }
        }
        return o2;
      }
      function Io(e2) {
        return this instanceof Io ? (this.v = e2, this) : new Io(e2);
      }
      var Lo = Object.freeze({ __proto__: null, __extends: function(e2, t2) {
        function n2() {
          this.constructor = e2;
        }
        No(e2, t2), e2.prototype = t2 === null ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
      }, get __assign() {
        return ko;
      }, __rest: function(e2, t2) {
        var n2 = {};
        for (var r2 in e2)
          Object.prototype.hasOwnProperty.call(e2, r2) && t2.indexOf(r2) < 0 && (n2[r2] = e2[r2]);
        if (e2 != null && typeof Object.getOwnPropertySymbols == "function") {
          var i2 = 0;
          for (r2 = Object.getOwnPropertySymbols(e2); i2 < r2.length; i2++)
            t2.indexOf(r2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, r2[i2]) && (n2[r2[i2]] = e2[r2[i2]]);
        }
        return n2;
      }, __decorate: function(e2, t2, n2, r2) {
        var i2, u2 = arguments.length, o2 = u2 < 3 ? t2 : r2 === null ? r2 = Object.getOwnPropertyDescriptor(t2, n2) : r2;
        if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
          o2 = Reflect.decorate(e2, t2, n2, r2);
        else
          for (var s2 = e2.length - 1; s2 >= 0; s2--)
            (i2 = e2[s2]) && (o2 = (u2 < 3 ? i2(o2) : u2 > 3 ? i2(t2, n2, o2) : i2(t2, n2)) || o2);
        return u2 > 3 && o2 && Object.defineProperty(t2, n2, o2), o2;
      }, __param: function(e2, t2) {
        return function(n2, r2) {
          t2(n2, r2, e2);
        };
      }, __metadata: function(e2, t2) {
        if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
          return Reflect.metadata(e2, t2);
      }, __awaiter: function(e2, t2, n2, r2) {
        return new (n2 || (n2 = Promise))(function(i2, u2) {
          function o2(e3) {
            try {
              a2(r2.next(e3));
            } catch (e4) {
              u2(e4);
            }
          }
          function s2(e3) {
            try {
              a2(r2.throw(e3));
            } catch (e4) {
              u2(e4);
            }
          }
          function a2(e3) {
            var t3;
            e3.done ? i2(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
              e4(t3);
            })).then(o2, s2);
          }
          a2((r2 = r2.apply(e2, t2 || [])).next());
        });
      }, __generator: function(e2, t2) {
        var n2, r2, i2, u2, o2 = { label: 0, sent: function() {
          if (1 & i2[0])
            throw i2[1];
          return i2[1];
        }, trys: [], ops: [] };
        return u2 = { next: s2(0), throw: s2(1), return: s2(2) }, typeof Symbol == "function" && (u2[Symbol.iterator] = function() {
          return this;
        }), u2;
        function s2(u3) {
          return function(s3) {
            return function(u4) {
              if (n2)
                throw new TypeError("Generator is already executing.");
              for (; o2; )
                try {
                  if (n2 = 1, r2 && (i2 = 2 & u4[0] ? r2.return : u4[0] ? r2.throw || ((i2 = r2.return) && i2.call(r2), 0) : r2.next) && !(i2 = i2.call(r2, u4[1])).done)
                    return i2;
                  switch (r2 = 0, i2 && (u4 = [2 & u4[0], i2.value]), u4[0]) {
                    case 0:
                    case 1:
                      i2 = u4;
                      break;
                    case 4:
                      return o2.label++, { value: u4[1], done: false };
                    case 5:
                      o2.label++, r2 = u4[1], u4 = [0];
                      continue;
                    case 7:
                      u4 = o2.ops.pop(), o2.trys.pop();
                      continue;
                    default:
                      if (!(i2 = o2.trys, (i2 = i2.length > 0 && i2[i2.length - 1]) || u4[0] !== 6 && u4[0] !== 2)) {
                        o2 = 0;
                        continue;
                      }
                      if (u4[0] === 3 && (!i2 || u4[1] > i2[0] && u4[1] < i2[3])) {
                        o2.label = u4[1];
                        break;
                      }
                      if (u4[0] === 6 && o2.label < i2[1]) {
                        o2.label = i2[1], i2 = u4;
                        break;
                      }
                      if (i2 && o2.label < i2[2]) {
                        o2.label = i2[2], o2.ops.push(u4);
                        break;
                      }
                      i2[2] && o2.ops.pop(), o2.trys.pop();
                      continue;
                  }
                  u4 = t2.call(e2, o2);
                } catch (e3) {
                  u4 = [6, e3], r2 = 0;
                } finally {
                  n2 = i2 = 0;
                }
              if (5 & u4[0])
                throw u4[1];
              return { value: u4[0] ? u4[1] : void 0, done: true };
            }([u3, s3]);
          };
        }
      }, __createBinding: function(e2, t2, n2, r2) {
        r2 === void 0 && (r2 = n2), e2[r2] = t2[n2];
      }, __exportStar: function(e2, t2) {
        for (var n2 in e2)
          n2 === "default" || t2.hasOwnProperty(n2) || (t2[n2] = e2[n2]);
      }, __values: Po, __read: Oo, __spread: function() {
        for (var e2 = [], t2 = 0; t2 < arguments.length; t2++)
          e2 = e2.concat(Oo(arguments[t2]));
        return e2;
      }, __spreadArrays: function() {
        for (var e2 = 0, t2 = 0, n2 = arguments.length; t2 < n2; t2++)
          e2 += arguments[t2].length;
        var r2 = Array(e2), i2 = 0;
        for (t2 = 0; t2 < n2; t2++)
          for (var u2 = arguments[t2], o2 = 0, s2 = u2.length; o2 < s2; o2++, i2++)
            r2[i2] = u2[o2];
        return r2;
      }, __await: Io, __asyncGenerator: function(e2, t2, n2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var r2, i2 = n2.apply(e2, t2 || []), u2 = [];
        return r2 = {}, o2("next"), o2("throw"), o2("return"), r2[Symbol.asyncIterator] = function() {
          return this;
        }, r2;
        function o2(e3) {
          i2[e3] && (r2[e3] = function(t3) {
            return new Promise(function(n3, r3) {
              u2.push([e3, t3, n3, r3]) > 1 || s2(e3, t3);
            });
          });
        }
        function s2(e3, t3) {
          try {
            (n3 = i2[e3](t3)).value instanceof Io ? Promise.resolve(n3.value.v).then(a2, c2) : l2(u2[0][2], n3);
          } catch (e4) {
            l2(u2[0][3], e4);
          }
          var n3;
        }
        function a2(e3) {
          s2("next", e3);
        }
        function c2(e3) {
          s2("throw", e3);
        }
        function l2(e3, t3) {
          e3(t3), u2.shift(), u2.length && s2(u2[0][0], u2[0][1]);
        }
      }, __asyncDelegator: function(e2) {
        var t2, n2;
        return t2 = {}, r2("next"), r2("throw", function(e3) {
          throw e3;
        }), r2("return"), t2[Symbol.iterator] = function() {
          return this;
        }, t2;
        function r2(r3, i2) {
          t2[r3] = e2[r3] ? function(t3) {
            return (n2 = !n2) ? { value: Io(e2[r3](t3)), done: r3 === "return" } : i2 ? i2(t3) : t3;
          } : i2;
        }
      }, __asyncValues: function(e2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var t2, n2 = e2[Symbol.asyncIterator];
        return n2 ? n2.call(e2) : (e2 = Po(e2), t2 = {}, r2("next"), r2("throw"), r2("return"), t2[Symbol.asyncIterator] = function() {
          return this;
        }, t2);
        function r2(n3) {
          t2[n3] = e2[n3] && function(t3) {
            return new Promise(function(r3, i2) {
              (function(e3, t4, n4, r4) {
                Promise.resolve(r4).then(function(t5) {
                  e3({ value: t5, done: n4 });
                }, t4);
              })(r3, i2, (t3 = e2[n3](t3)).done, t3.value);
            });
          };
        }
      }, __makeTemplateObject: function(e2, t2) {
        return Object.defineProperty ? Object.defineProperty(e2, "raw", { value: t2 }) : e2.raw = t2, e2;
      }, __importStar: function(e2) {
        if (e2 && e2.__esModule)
          return e2;
        var t2 = {};
        if (e2 != null)
          for (var n2 in e2)
            Object.hasOwnProperty.call(e2, n2) && (t2[n2] = e2[n2]);
        return t2.default = e2, t2;
      }, __importDefault: function(e2) {
        return e2 && e2.__esModule ? e2 : { default: e2 };
      }, __classPrivateFieldGet: function(e2, t2) {
        if (!t2.has(e2))
          throw new TypeError("attempted to get private field on non-instance");
        return t2.get(e2);
      }, __classPrivateFieldSet: function(e2, t2, n2) {
        if (!t2.has(e2))
          throw new TypeError("attempted to set private field on non-instance");
        return t2.set(e2, n2), n2;
      } }), jo = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true }), t2.apiDescriptor = { key: (e3) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e3) ? e3 : JSON.stringify(e3), value(e3) {
          if (e3 === null || typeof e3 != "object")
            return JSON.stringify(e3);
          if (Array.isArray(e3))
            return `[${e3.map((e4) => t2.apiDescriptor.value(e4)).join(", ")}]`;
          const n2 = Object.keys(e3);
          return n2.length === 0 ? "{}" : `{ ${n2.map((n3) => `${t2.apiDescriptor.key(n3)}: ${t2.apiDescriptor.value(e3[n3])}`).join(", ")} }`;
        }, pair: ({ key: e3, value: n2 }) => t2.apiDescriptor.value({ [e3]: n2 }) };
      }), _o = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true }), Lo.__exportStar(jo, t2);
      }), Mo = /[|\\{}()[\]^$+*?.]/g, Ro = function(e2) {
        if (typeof e2 != "string")
          throw new TypeError("Expected a string");
        return e2.replace(Mo, "\\$&");
      }, $o = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }, Vo = r(function(e2) {
        var t2 = {};
        for (var n2 in $o)
          $o.hasOwnProperty(n2) && (t2[$o[n2]] = n2);
        var r2 = e2.exports = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
        for (var i2 in r2)
          if (r2.hasOwnProperty(i2)) {
            if (!("channels" in r2[i2]))
              throw new Error("missing channels property: " + i2);
            if (!("labels" in r2[i2]))
              throw new Error("missing channel labels property: " + i2);
            if (r2[i2].labels.length !== r2[i2].channels)
              throw new Error("channel and label counts mismatch: " + i2);
            var u2 = r2[i2].channels, o2 = r2[i2].labels;
            delete r2[i2].channels, delete r2[i2].labels, Object.defineProperty(r2[i2], "channels", { value: u2 }), Object.defineProperty(r2[i2], "labels", { value: o2 });
          }
        r2.rgb.hsl = function(e3) {
          var t3, n3, r3 = e3[0] / 255, i3 = e3[1] / 255, u3 = e3[2] / 255, o3 = Math.min(r3, i3, u3), s2 = Math.max(r3, i3, u3), a2 = s2 - o3;
          return s2 === o3 ? t3 = 0 : r3 === s2 ? t3 = (i3 - u3) / a2 : i3 === s2 ? t3 = 2 + (u3 - r3) / a2 : u3 === s2 && (t3 = 4 + (r3 - i3) / a2), (t3 = Math.min(60 * t3, 360)) < 0 && (t3 += 360), n3 = (o3 + s2) / 2, [t3, 100 * (s2 === o3 ? 0 : n3 <= 0.5 ? a2 / (s2 + o3) : a2 / (2 - s2 - o3)), 100 * n3];
        }, r2.rgb.hsv = function(e3) {
          var t3, n3, r3, i3, u3, o3 = e3[0] / 255, s2 = e3[1] / 255, a2 = e3[2] / 255, c2 = Math.max(o3, s2, a2), l2 = c2 - Math.min(o3, s2, a2), p2 = function(e4) {
            return (c2 - e4) / 6 / l2 + 0.5;
          };
          return l2 === 0 ? i3 = u3 = 0 : (u3 = l2 / c2, t3 = p2(o3), n3 = p2(s2), r3 = p2(a2), o3 === c2 ? i3 = r3 - n3 : s2 === c2 ? i3 = 1 / 3 + t3 - r3 : a2 === c2 && (i3 = 2 / 3 + n3 - t3), i3 < 0 ? i3 += 1 : i3 > 1 && (i3 -= 1)), [360 * i3, 100 * u3, 100 * c2];
        }, r2.rgb.hwb = function(e3) {
          var t3 = e3[0], n3 = e3[1], i3 = e3[2];
          return [r2.rgb.hsl(e3)[0], 100 * (1 / 255 * Math.min(t3, Math.min(n3, i3))), 100 * (i3 = 1 - 1 / 255 * Math.max(t3, Math.max(n3, i3)))];
        }, r2.rgb.cmyk = function(e3) {
          var t3, n3 = e3[0] / 255, r3 = e3[1] / 255, i3 = e3[2] / 255;
          return [100 * ((1 - n3 - (t3 = Math.min(1 - n3, 1 - r3, 1 - i3))) / (1 - t3) || 0), 100 * ((1 - r3 - t3) / (1 - t3) || 0), 100 * ((1 - i3 - t3) / (1 - t3) || 0), 100 * t3];
        }, r2.rgb.keyword = function(e3) {
          var n3 = t2[e3];
          if (n3)
            return n3;
          var r3, i3, u3, o3 = 1 / 0;
          for (var s2 in $o)
            if ($o.hasOwnProperty(s2)) {
              var a2 = $o[s2], c2 = (i3 = e3, u3 = a2, Math.pow(i3[0] - u3[0], 2) + Math.pow(i3[1] - u3[1], 2) + Math.pow(i3[2] - u3[2], 2));
              c2 < o3 && (o3 = c2, r3 = s2);
            }
          return r3;
        }, r2.keyword.rgb = function(e3) {
          return $o[e3];
        }, r2.rgb.xyz = function(e3) {
          var t3 = e3[0] / 255, n3 = e3[1] / 255, r3 = e3[2] / 255;
          return [100 * (0.4124 * (t3 = t3 > 0.04045 ? Math.pow((t3 + 0.055) / 1.055, 2.4) : t3 / 12.92) + 0.3576 * (n3 = n3 > 0.04045 ? Math.pow((n3 + 0.055) / 1.055, 2.4) : n3 / 12.92) + 0.1805 * (r3 = r3 > 0.04045 ? Math.pow((r3 + 0.055) / 1.055, 2.4) : r3 / 12.92)), 100 * (0.2126 * t3 + 0.7152 * n3 + 0.0722 * r3), 100 * (0.0193 * t3 + 0.1192 * n3 + 0.9505 * r3)];
        }, r2.rgb.lab = function(e3) {
          var t3 = r2.rgb.xyz(e3), n3 = t3[0], i3 = t3[1], u3 = t3[2];
          return i3 /= 100, u3 /= 108.883, n3 = (n3 /= 95.047) > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116, [116 * (i3 = i3 > 8856e-6 ? Math.pow(i3, 1 / 3) : 7.787 * i3 + 16 / 116) - 16, 500 * (n3 - i3), 200 * (i3 - (u3 = u3 > 8856e-6 ? Math.pow(u3, 1 / 3) : 7.787 * u3 + 16 / 116))];
        }, r2.hsl.rgb = function(e3) {
          var t3, n3, r3, i3, u3, o3 = e3[0] / 360, s2 = e3[1] / 100, a2 = e3[2] / 100;
          if (s2 === 0)
            return [u3 = 255 * a2, u3, u3];
          t3 = 2 * a2 - (n3 = a2 < 0.5 ? a2 * (1 + s2) : a2 + s2 - a2 * s2), i3 = [0, 0, 0];
          for (var c2 = 0; c2 < 3; c2++)
            (r3 = o3 + 1 / 3 * -(c2 - 1)) < 0 && r3++, r3 > 1 && r3--, u3 = 6 * r3 < 1 ? t3 + 6 * (n3 - t3) * r3 : 2 * r3 < 1 ? n3 : 3 * r3 < 2 ? t3 + (n3 - t3) * (2 / 3 - r3) * 6 : t3, i3[c2] = 255 * u3;
          return i3;
        }, r2.hsl.hsv = function(e3) {
          var t3 = e3[0], n3 = e3[1] / 100, r3 = e3[2] / 100, i3 = n3, u3 = Math.max(r3, 0.01);
          return n3 *= (r3 *= 2) <= 1 ? r3 : 2 - r3, i3 *= u3 <= 1 ? u3 : 2 - u3, [t3, 100 * (r3 === 0 ? 2 * i3 / (u3 + i3) : 2 * n3 / (r3 + n3)), 100 * ((r3 + n3) / 2)];
        }, r2.hsv.rgb = function(e3) {
          var t3 = e3[0] / 60, n3 = e3[1] / 100, r3 = e3[2] / 100, i3 = Math.floor(t3) % 6, u3 = t3 - Math.floor(t3), o3 = 255 * r3 * (1 - n3), s2 = 255 * r3 * (1 - n3 * u3), a2 = 255 * r3 * (1 - n3 * (1 - u3));
          switch (r3 *= 255, i3) {
            case 0:
              return [r3, a2, o3];
            case 1:
              return [s2, r3, o3];
            case 2:
              return [o3, r3, a2];
            case 3:
              return [o3, s2, r3];
            case 4:
              return [a2, o3, r3];
            case 5:
              return [r3, o3, s2];
          }
        }, r2.hsv.hsl = function(e3) {
          var t3, n3, r3, i3 = e3[0], u3 = e3[1] / 100, o3 = e3[2] / 100, s2 = Math.max(o3, 0.01);
          return r3 = (2 - u3) * o3, n3 = u3 * s2, [i3, 100 * (n3 = (n3 /= (t3 = (2 - u3) * s2) <= 1 ? t3 : 2 - t3) || 0), 100 * (r3 /= 2)];
        }, r2.hwb.rgb = function(e3) {
          var t3, n3, r3, i3, u3, o3, s2, a2 = e3[0] / 360, c2 = e3[1] / 100, l2 = e3[2] / 100, p2 = c2 + l2;
          switch (p2 > 1 && (c2 /= p2, l2 /= p2), r3 = 6 * a2 - (t3 = Math.floor(6 * a2)), (1 & t3) != 0 && (r3 = 1 - r3), i3 = c2 + r3 * ((n3 = 1 - l2) - c2), t3) {
            default:
            case 6:
            case 0:
              u3 = n3, o3 = i3, s2 = c2;
              break;
            case 1:
              u3 = i3, o3 = n3, s2 = c2;
              break;
            case 2:
              u3 = c2, o3 = n3, s2 = i3;
              break;
            case 3:
              u3 = c2, o3 = i3, s2 = n3;
              break;
            case 4:
              u3 = i3, o3 = c2, s2 = n3;
              break;
            case 5:
              u3 = n3, o3 = c2, s2 = i3;
          }
          return [255 * u3, 255 * o3, 255 * s2];
        }, r2.cmyk.rgb = function(e3) {
          var t3 = e3[0] / 100, n3 = e3[1] / 100, r3 = e3[2] / 100, i3 = e3[3] / 100;
          return [255 * (1 - Math.min(1, t3 * (1 - i3) + i3)), 255 * (1 - Math.min(1, n3 * (1 - i3) + i3)), 255 * (1 - Math.min(1, r3 * (1 - i3) + i3))];
        }, r2.xyz.rgb = function(e3) {
          var t3, n3, r3, i3 = e3[0] / 100, u3 = e3[1] / 100, o3 = e3[2] / 100;
          return n3 = -0.9689 * i3 + 1.8758 * u3 + 0.0415 * o3, r3 = 0.0557 * i3 + -0.204 * u3 + 1.057 * o3, t3 = (t3 = 3.2406 * i3 + -1.5372 * u3 + -0.4986 * o3) > 31308e-7 ? 1.055 * Math.pow(t3, 1 / 2.4) - 0.055 : 12.92 * t3, n3 = n3 > 31308e-7 ? 1.055 * Math.pow(n3, 1 / 2.4) - 0.055 : 12.92 * n3, r3 = r3 > 31308e-7 ? 1.055 * Math.pow(r3, 1 / 2.4) - 0.055 : 12.92 * r3, [255 * (t3 = Math.min(Math.max(0, t3), 1)), 255 * (n3 = Math.min(Math.max(0, n3), 1)), 255 * (r3 = Math.min(Math.max(0, r3), 1))];
        }, r2.xyz.lab = function(e3) {
          var t3 = e3[0], n3 = e3[1], r3 = e3[2];
          return n3 /= 100, r3 /= 108.883, t3 = (t3 /= 95.047) > 8856e-6 ? Math.pow(t3, 1 / 3) : 7.787 * t3 + 16 / 116, [116 * (n3 = n3 > 8856e-6 ? Math.pow(n3, 1 / 3) : 7.787 * n3 + 16 / 116) - 16, 500 * (t3 - n3), 200 * (n3 - (r3 = r3 > 8856e-6 ? Math.pow(r3, 1 / 3) : 7.787 * r3 + 16 / 116))];
        }, r2.lab.xyz = function(e3) {
          var t3, n3, r3, i3 = e3[0];
          t3 = e3[1] / 500 + (n3 = (i3 + 16) / 116), r3 = n3 - e3[2] / 200;
          var u3 = Math.pow(n3, 3), o3 = Math.pow(t3, 3), s2 = Math.pow(r3, 3);
          return n3 = u3 > 8856e-6 ? u3 : (n3 - 16 / 116) / 7.787, t3 = o3 > 8856e-6 ? o3 : (t3 - 16 / 116) / 7.787, r3 = s2 > 8856e-6 ? s2 : (r3 - 16 / 116) / 7.787, [t3 *= 95.047, n3 *= 100, r3 *= 108.883];
        }, r2.lab.lch = function(e3) {
          var t3, n3 = e3[0], r3 = e3[1], i3 = e3[2];
          return (t3 = 360 * Math.atan2(i3, r3) / 2 / Math.PI) < 0 && (t3 += 360), [n3, Math.sqrt(r3 * r3 + i3 * i3), t3];
        }, r2.lch.lab = function(e3) {
          var t3, n3 = e3[0], r3 = e3[1];
          return t3 = e3[2] / 360 * 2 * Math.PI, [n3, r3 * Math.cos(t3), r3 * Math.sin(t3)];
        }, r2.rgb.ansi16 = function(e3) {
          var t3 = e3[0], n3 = e3[1], i3 = e3[2], u3 = 1 in arguments ? arguments[1] : r2.rgb.hsv(e3)[2];
          if ((u3 = Math.round(u3 / 50)) === 0)
            return 30;
          var o3 = 30 + (Math.round(i3 / 255) << 2 | Math.round(n3 / 255) << 1 | Math.round(t3 / 255));
          return u3 === 2 && (o3 += 60), o3;
        }, r2.hsv.ansi16 = function(e3) {
          return r2.rgb.ansi16(r2.hsv.rgb(e3), e3[2]);
        }, r2.rgb.ansi256 = function(e3) {
          var t3 = e3[0], n3 = e3[1], r3 = e3[2];
          return t3 === n3 && n3 === r3 ? t3 < 8 ? 16 : t3 > 248 ? 231 : Math.round((t3 - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t3 / 255 * 5) + 6 * Math.round(n3 / 255 * 5) + Math.round(r3 / 255 * 5);
        }, r2.ansi16.rgb = function(e3) {
          var t3 = e3 % 10;
          if (t3 === 0 || t3 === 7)
            return e3 > 50 && (t3 += 3.5), [t3 = t3 / 10.5 * 255, t3, t3];
          var n3 = 0.5 * (1 + ~~(e3 > 50));
          return [(1 & t3) * n3 * 255, (t3 >> 1 & 1) * n3 * 255, (t3 >> 2 & 1) * n3 * 255];
        }, r2.ansi256.rgb = function(e3) {
          if (e3 >= 232) {
            var t3 = 10 * (e3 - 232) + 8;
            return [t3, t3, t3];
          }
          var n3;
          return e3 -= 16, [Math.floor(e3 / 36) / 5 * 255, Math.floor((n3 = e3 % 36) / 6) / 5 * 255, n3 % 6 / 5 * 255];
        }, r2.rgb.hex = function(e3) {
          var t3 = (((255 & Math.round(e3[0])) << 16) + ((255 & Math.round(e3[1])) << 8) + (255 & Math.round(e3[2]))).toString(16).toUpperCase();
          return "000000".substring(t3.length) + t3;
        }, r2.hex.rgb = function(e3) {
          var t3 = e3.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!t3)
            return [0, 0, 0];
          var n3 = t3[0];
          t3[0].length === 3 && (n3 = n3.split("").map(function(e4) {
            return e4 + e4;
          }).join(""));
          var r3 = parseInt(n3, 16);
          return [r3 >> 16 & 255, r3 >> 8 & 255, 255 & r3];
        }, r2.rgb.hcg = function(e3) {
          var t3, n3 = e3[0] / 255, r3 = e3[1] / 255, i3 = e3[2] / 255, u3 = Math.max(Math.max(n3, r3), i3), o3 = Math.min(Math.min(n3, r3), i3), s2 = u3 - o3;
          return t3 = s2 <= 0 ? 0 : u3 === n3 ? (r3 - i3) / s2 % 6 : u3 === r3 ? 2 + (i3 - n3) / s2 : 4 + (n3 - r3) / s2 + 4, t3 /= 6, [360 * (t3 %= 1), 100 * s2, 100 * (s2 < 1 ? o3 / (1 - s2) : 0)];
        }, r2.hsl.hcg = function(e3) {
          var t3 = e3[1] / 100, n3 = e3[2] / 100, r3 = 1, i3 = 0;
          return (r3 = n3 < 0.5 ? 2 * t3 * n3 : 2 * t3 * (1 - n3)) < 1 && (i3 = (n3 - 0.5 * r3) / (1 - r3)), [e3[0], 100 * r3, 100 * i3];
        }, r2.hsv.hcg = function(e3) {
          var t3 = e3[1] / 100, n3 = e3[2] / 100, r3 = t3 * n3, i3 = 0;
          return r3 < 1 && (i3 = (n3 - r3) / (1 - r3)), [e3[0], 100 * r3, 100 * i3];
        }, r2.hcg.rgb = function(e3) {
          var t3 = e3[0] / 360, n3 = e3[1] / 100, r3 = e3[2] / 100;
          if (n3 === 0)
            return [255 * r3, 255 * r3, 255 * r3];
          var i3, u3 = [0, 0, 0], o3 = t3 % 1 * 6, s2 = o3 % 1, a2 = 1 - s2;
          switch (Math.floor(o3)) {
            case 0:
              u3[0] = 1, u3[1] = s2, u3[2] = 0;
              break;
            case 1:
              u3[0] = a2, u3[1] = 1, u3[2] = 0;
              break;
            case 2:
              u3[0] = 0, u3[1] = 1, u3[2] = s2;
              break;
            case 3:
              u3[0] = 0, u3[1] = a2, u3[2] = 1;
              break;
            case 4:
              u3[0] = s2, u3[1] = 0, u3[2] = 1;
              break;
            default:
              u3[0] = 1, u3[1] = 0, u3[2] = a2;
          }
          return i3 = (1 - n3) * r3, [255 * (n3 * u3[0] + i3), 255 * (n3 * u3[1] + i3), 255 * (n3 * u3[2] + i3)];
        }, r2.hcg.hsv = function(e3) {
          var t3 = e3[1] / 100, n3 = t3 + e3[2] / 100 * (1 - t3), r3 = 0;
          return n3 > 0 && (r3 = t3 / n3), [e3[0], 100 * r3, 100 * n3];
        }, r2.hcg.hsl = function(e3) {
          var t3 = e3[1] / 100, n3 = e3[2] / 100 * (1 - t3) + 0.5 * t3, r3 = 0;
          return n3 > 0 && n3 < 0.5 ? r3 = t3 / (2 * n3) : n3 >= 0.5 && n3 < 1 && (r3 = t3 / (2 * (1 - n3))), [e3[0], 100 * r3, 100 * n3];
        }, r2.hcg.hwb = function(e3) {
          var t3 = e3[1] / 100, n3 = t3 + e3[2] / 100 * (1 - t3);
          return [e3[0], 100 * (n3 - t3), 100 * (1 - n3)];
        }, r2.hwb.hcg = function(e3) {
          var t3 = e3[1] / 100, n3 = 1 - e3[2] / 100, r3 = n3 - t3, i3 = 0;
          return r3 < 1 && (i3 = (n3 - r3) / (1 - r3)), [e3[0], 100 * r3, 100 * i3];
        }, r2.apple.rgb = function(e3) {
          return [e3[0] / 65535 * 255, e3[1] / 65535 * 255, e3[2] / 65535 * 255];
        }, r2.rgb.apple = function(e3) {
          return [e3[0] / 255 * 65535, e3[1] / 255 * 65535, e3[2] / 255 * 65535];
        }, r2.gray.rgb = function(e3) {
          return [e3[0] / 100 * 255, e3[0] / 100 * 255, e3[0] / 100 * 255];
        }, r2.gray.hsl = r2.gray.hsv = function(e3) {
          return [0, 0, e3[0]];
        }, r2.gray.hwb = function(e3) {
          return [0, 100, e3[0]];
        }, r2.gray.cmyk = function(e3) {
          return [0, 0, 0, e3[0]];
        }, r2.gray.lab = function(e3) {
          return [e3[0], 0, 0];
        }, r2.gray.hex = function(e3) {
          var t3 = 255 & Math.round(e3[0] / 100 * 255), n3 = ((t3 << 16) + (t3 << 8) + t3).toString(16).toUpperCase();
          return "000000".substring(n3.length) + n3;
        }, r2.rgb.gray = function(e3) {
          return [(e3[0] + e3[1] + e3[2]) / 3 / 255 * 100];
        };
      });
      function Wo(e2) {
        var t2 = function() {
          for (var e3 = {}, t3 = Object.keys(Vo), n3 = t3.length, r3 = 0; r3 < n3; r3++)
            e3[t3[r3]] = { distance: -1, parent: null };
          return e3;
        }(), n2 = [e2];
        for (t2[e2].distance = 0; n2.length; )
          for (var r2 = n2.pop(), i2 = Object.keys(Vo[r2]), u2 = i2.length, o2 = 0; o2 < u2; o2++) {
            var s2 = i2[o2], a2 = t2[s2];
            a2.distance === -1 && (a2.distance = t2[r2].distance + 1, a2.parent = r2, n2.unshift(s2));
          }
        return t2;
      }
      function qo(e2, t2) {
        return function(n2) {
          return t2(e2(n2));
        };
      }
      function Uo(e2, t2) {
        for (var n2 = [t2[e2].parent, e2], r2 = Vo[t2[e2].parent][e2], i2 = t2[e2].parent; t2[i2].parent; )
          n2.unshift(t2[i2].parent), r2 = qo(Vo[t2[i2].parent][i2], r2), i2 = t2[i2].parent;
        return r2.conversion = n2, r2;
      }
      var zo = {};
      Object.keys(Vo).forEach(function(e2) {
        zo[e2] = {}, Object.defineProperty(zo[e2], "channels", { value: Vo[e2].channels }), Object.defineProperty(zo[e2], "labels", { value: Vo[e2].labels });
        var t2 = function(e3) {
          for (var t3 = Wo(e3), n2 = {}, r2 = Object.keys(t3), i2 = r2.length, u2 = 0; u2 < i2; u2++) {
            var o2 = r2[u2];
            t3[o2].parent !== null && (n2[o2] = Uo(o2, t3));
          }
          return n2;
        }(e2);
        Object.keys(t2).forEach(function(n2) {
          var r2 = t2[n2];
          zo[e2][n2] = function(e3) {
            var t3 = function(t4) {
              if (t4 == null)
                return t4;
              arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments));
              var n3 = e3(t4);
              if (typeof n3 == "object")
                for (var r3 = n3.length, i2 = 0; i2 < r3; i2++)
                  n3[i2] = Math.round(n3[i2]);
              return n3;
            };
            return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
          }(r2), zo[e2][n2].raw = function(e3) {
            var t3 = function(t4) {
              return t4 == null ? t4 : (arguments.length > 1 && (t4 = Array.prototype.slice.call(arguments)), e3(t4));
            };
            return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
          }(r2);
        });
      });
      var Go, Ho = zo, Jo = r(function(e2) {
        const t2 = (e3, t3) => function() {
          const n3 = e3.apply(Ho, arguments);
          return `[${n3 + t3}m`;
        }, n2 = (e3, t3) => function() {
          const n3 = e3.apply(Ho, arguments);
          return `[${38 + t3};5;${n3}m`;
        }, r2 = (e3, t3) => function() {
          const n3 = e3.apply(Ho, arguments);
          return `[${38 + t3};2;${n3[0]};${n3[1]};${n3[2]}m`;
        };
        Object.defineProperty(e2, "exports", { enumerable: true, get: function() {
          const e3 = new Map(), i2 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
          i2.color.grey = i2.color.gray;
          for (const t3 of Object.keys(i2)) {
            const n3 = i2[t3];
            for (const t4 of Object.keys(n3)) {
              const r3 = n3[t4];
              i2[t4] = { open: `[${r3[0]}m`, close: `[${r3[1]}m` }, n3[t4] = i2[t4], e3.set(r3[0], r3[1]);
            }
            Object.defineProperty(i2, t3, { value: n3, enumerable: false }), Object.defineProperty(i2, "codes", { value: e3, enumerable: false });
          }
          const u2 = (e4) => e4, o2 = (e4, t3, n3) => [e4, t3, n3];
          i2.color.close = "[39m", i2.bgColor.close = "[49m", i2.color.ansi = { ansi: t2(u2, 0) }, i2.color.ansi256 = { ansi256: n2(u2, 0) }, i2.color.ansi16m = { rgb: r2(o2, 0) }, i2.bgColor.ansi = { ansi: t2(u2, 10) }, i2.bgColor.ansi256 = { ansi256: n2(u2, 10) }, i2.bgColor.ansi16m = { rgb: r2(o2, 10) };
          for (let e4 of Object.keys(Ho)) {
            if (typeof Ho[e4] != "object")
              continue;
            const u3 = Ho[e4];
            e4 === "ansi16" && (e4 = "ansi"), "ansi16" in u3 && (i2.color.ansi[e4] = t2(u3.ansi16, 0), i2.bgColor.ansi[e4] = t2(u3.ansi16, 10)), "ansi256" in u3 && (i2.color.ansi256[e4] = n2(u3.ansi256, 0), i2.bgColor.ansi256[e4] = n2(u3.ansi256, 10)), "rgb" in u3 && (i2.color.ansi16m[e4] = r2(u3.rgb, 0), i2.bgColor.ansi16m[e4] = r2(u3.rgb, 10));
          }
          return i2;
        } });
      });
      function Xo() {
        if (Go === void 0) {
          var e2 = new ArrayBuffer(2), t2 = new Uint8Array(e2), n2 = new Uint16Array(e2);
          if (t2[0] = 1, t2[1] = 2, n2[0] === 258)
            Go = "BE";
          else {
            if (n2[0] !== 513)
              throw new Error("unable to figure out endianess");
            Go = "LE";
          }
        }
        return Go;
      }
      function Yo() {
        return ir.location !== void 0 ? ir.location.hostname : "";
      }
      function Ko() {
        return [];
      }
      function Qo() {
        return 0;
      }
      function Zo() {
        return Number.MAX_VALUE;
      }
      function es() {
        return Number.MAX_VALUE;
      }
      function ts() {
        return [];
      }
      function ns() {
        return "Browser";
      }
      function rs() {
        return ir.navigator !== void 0 ? ir.navigator.appVersion : "";
      }
      function is() {
      }
      function us() {
      }
      function os() {
        return "javascript";
      }
      function ss() {
        return "browser";
      }
      function as() {
        return "/tmp";
      }
      var cs = as, ls = { EOL: "\n", arch: os, platform: ss, tmpdir: cs, tmpDir: as, networkInterfaces: is, getNetworkInterfaces: us, release: rs, type: ns, cpus: ts, totalmem: es, freemem: Zo, uptime: Qo, loadavg: Ko, hostname: Yo, endianness: Xo }, ps = (e2, t2) => {
        t2 = t2 || Tr.argv;
        const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e2), i2 = t2.indexOf("--");
        return r2 !== -1 && (i2 === -1 || r2 < i2);
      }, fs = n(Object.freeze({ __proto__: null, endianness: Xo, hostname: Yo, loadavg: Ko, uptime: Qo, freemem: Zo, totalmem: es, cpus: ts, type: ns, release: rs, networkInterfaces: is, getNetworkInterfaces: us, arch: os, platform: ss, tmpDir: as, tmpdir: cs, EOL: "\n", default: ls }));
      const ds = Tr.env;
      let hs;
      function gs(e2) {
        return function(e3) {
          return e3 !== 0 && { level: e3, hasBasic: true, has256: e3 >= 2, has16m: e3 >= 3 };
        }(function(e3) {
          if (hs === false)
            return 0;
          if (ps("color=16m") || ps("color=full") || ps("color=truecolor"))
            return 3;
          if (ps("color=256"))
            return 2;
          if (e3 && !e3.isTTY && hs !== true)
            return 0;
          const t2 = hs ? 1 : 0;
          if (Tr.platform === "win32") {
            const e4 = fs.release().split(".");
            return Number(Tr.versions.node.split(".")[0]) >= 8 && Number(e4[0]) >= 10 && Number(e4[2]) >= 10586 ? Number(e4[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in ds)
            return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e4) => e4 in ds) || ds.CI_NAME === "codeship" ? 1 : t2;
          if ("TEAMCITY_VERSION" in ds)
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(ds.TEAMCITY_VERSION) ? 1 : 0;
          if (ds.COLORTERM === "truecolor")
            return 3;
          if ("TERM_PROGRAM" in ds) {
            const e4 = parseInt((ds.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (ds.TERM_PROGRAM) {
              case "iTerm.app":
                return e4 >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          return /-256(color)?$/i.test(ds.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(ds.TERM) || "COLORTERM" in ds ? 1 : (ds.TERM, t2);
        }(e2));
      }
      ps("no-color") || ps("no-colors") || ps("color=false") ? hs = false : (ps("color") || ps("colors") || ps("color=true") || ps("color=always")) && (hs = true), "FORCE_COLOR" in ds && (hs = ds.FORCE_COLOR.length === 0 || parseInt(ds.FORCE_COLOR, 10) !== 0);
      var ms = { supportsColor: gs, stdout: gs(Tr.stdout), stderr: gs(Tr.stderr) };
      const ys = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Ds = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Es = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, Cs = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, bs = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
      function As(e2) {
        return e2[0] === "u" && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : bs.get(e2) || e2;
      }
      function vs(e2, t2) {
        const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
        let i2;
        for (const t3 of r2)
          if (isNaN(t3)) {
            if (!(i2 = t3.match(Es)))
              throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e2}')`);
            n2.push(i2[2].replace(Cs, (e3, t4, n3) => t4 ? As(t4) : n3));
          } else
            n2.push(Number(t3));
        return n2;
      }
      function Fs(e2) {
        Ds.lastIndex = 0;
        const t2 = [];
        let n2;
        for (; (n2 = Ds.exec(e2)) !== null; ) {
          const e3 = n2[1];
          if (n2[2]) {
            const r2 = vs(e3, n2[2]);
            t2.push([e3].concat(r2));
          } else
            t2.push([e3]);
        }
        return t2;
      }
      function xs(e2, t2) {
        const n2 = {};
        for (const e3 of t2)
          for (const t3 of e3.styles)
            n2[t3[0]] = e3.inverse ? null : t3.slice(1);
        let r2 = e2;
        for (const e3 of Object.keys(n2))
          if (Array.isArray(n2[e3])) {
            if (!(e3 in r2))
              throw new Error(`Unknown Chalk style: ${e3}`);
            r2 = n2[e3].length > 0 ? r2[e3].apply(r2, n2[e3]) : r2[e3];
          }
        return r2;
      }
      var Ss = (e2, t2) => {
        const n2 = [], r2 = [];
        let i2 = [];
        if (t2.replace(ys, (t3, u2, o2, s2, a2, c2) => {
          if (u2)
            i2.push(As(u2));
          else if (s2) {
            const t4 = i2.join("");
            i2 = [], r2.push(n2.length === 0 ? t4 : xs(e2, n2)(t4)), n2.push({ inverse: o2, styles: Fs(s2) });
          } else if (a2) {
            if (n2.length === 0)
              throw new Error("Found extraneous } in Chalk template literal");
            r2.push(xs(e2, n2)(i2.join(""))), i2 = [], n2.pop();
          } else
            i2.push(c2);
        }), r2.push(i2.join("")), n2.length > 0) {
          const e3 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(e3);
        }
        return r2.join("");
      }, ws = r(function(e2) {
        const t2 = ms.stdout, n2 = Tr.platform === "win32" && !(Tr.env.TERM || "").toLowerCase().startsWith("xterm"), r2 = ["ansi", "ansi", "ansi256", "ansi16m"], i2 = new Set(["gray"]), u2 = Object.create(null);
        function o2(e3, n3) {
          n3 = n3 || {};
          const r3 = t2 ? t2.level : 0;
          e3.level = n3.level === void 0 ? r3 : n3.level, e3.enabled = "enabled" in n3 ? n3.enabled : e3.level > 0;
        }
        function s2(e3) {
          if (!this || !(this instanceof s2) || this.template) {
            const t3 = {};
            return o2(t3, e3), t3.template = function() {
              const e4 = [].slice.call(arguments);
              return p2.apply(null, [t3.template].concat(e4));
            }, Object.setPrototypeOf(t3, s2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = s2, t3.template;
          }
          o2(this, e3);
        }
        n2 && (Jo.blue.open = "[94m");
        for (const e3 of Object.keys(Jo))
          Jo[e3].closeRe = new RegExp(Ro(Jo[e3].close), "g"), u2[e3] = { get() {
            const t3 = Jo[e3];
            return c2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e3);
          } };
        u2.visible = { get() {
          return c2.call(this, this._styles || [], true, "visible");
        } }, Jo.color.closeRe = new RegExp(Ro(Jo.color.close), "g");
        for (const e3 of Object.keys(Jo.color.ansi))
          i2.has(e3) || (u2[e3] = { get() {
            const t3 = this.level;
            return function() {
              const n3 = Jo.color[r2[t3]][e3].apply(null, arguments), i3 = { open: n3, close: Jo.color.close, closeRe: Jo.color.closeRe };
              return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e3);
            };
          } });
        Jo.bgColor.closeRe = new RegExp(Ro(Jo.bgColor.close), "g");
        for (const e3 of Object.keys(Jo.bgColor.ansi)) {
          if (i2.has(e3))
            continue;
          u2["bg" + e3[0].toUpperCase() + e3.slice(1)] = { get() {
            const t3 = this.level;
            return function() {
              const n3 = Jo.bgColor[r2[t3]][e3].apply(null, arguments), i3 = { open: n3, close: Jo.bgColor.close, closeRe: Jo.bgColor.closeRe };
              return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e3);
            };
          } };
        }
        const a2 = Object.defineProperties(() => {
        }, u2);
        function c2(e3, t3, n3) {
          const r3 = function() {
            return l2.apply(r3, arguments);
          };
          r3._styles = e3, r3._empty = t3;
          const i3 = this;
          return Object.defineProperty(r3, "level", { enumerable: true, get: () => i3.level, set(e4) {
            i3.level = e4;
          } }), Object.defineProperty(r3, "enabled", { enumerable: true, get: () => i3.enabled, set(e4) {
            i3.enabled = e4;
          } }), r3.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r3.__proto__ = a2, r3;
        }
        function l2() {
          const e3 = arguments, t3 = e3.length;
          let r3 = String(arguments[0]);
          if (t3 === 0)
            return "";
          if (t3 > 1)
            for (let n3 = 1; n3 < t3; n3++)
              r3 += " " + e3[n3];
          if (!this.enabled || this.level <= 0 || !r3)
            return this._empty ? "" : r3;
          const i3 = Jo.dim.open;
          n2 && this.hasGrey && (Jo.dim.open = "");
          for (const e4 of this._styles.slice().reverse())
            r3 = e4.open + r3.replace(e4.closeRe, e4.open) + e4.close, r3 = r3.replace(/\r?\n/g, `${e4.close}$&${e4.open}`);
          return Jo.dim.open = i3, r3;
        }
        function p2(e3, t3) {
          if (!Array.isArray(t3))
            return [].slice.call(arguments, 1).join(" ");
          const n3 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
          for (let e4 = 1; e4 < t3.length; e4++)
            r3.push(String(n3[e4 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e4]));
          return Ss(e3, r3.join(""));
        }
        Object.defineProperties(s2.prototype, u2), e2.exports = s2(), e2.exports.supportsColor = t2, e2.exports.default = e2.exports;
      }), Ts = Object.defineProperty({ commonDeprecatedHandler: (e2, t2, { descriptor: n2 }) => {
        const r2 = [`${ws.default.yellow(typeof e2 == "string" ? n2.key(e2) : n2.pair(e2))} is deprecated`];
        return t2 && r2.push(`we now treat it as ${ws.default.blue(typeof t2 == "string" ? n2.key(t2) : n2.pair(t2))}`), r2.join("; ") + ".";
      } }, "__esModule", { value: true }), Bs = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true }), Lo.__exportStar(Ts, t2);
      }), Ns = Object.defineProperty({ commonInvalidHandler: (e2, t2, n2) => [`Invalid ${ws.default.red(n2.descriptor.key(e2))} value.`, `Expected ${ws.default.blue(n2.schemas[e2].expected(n2))},`, `but received ${ws.default.red(n2.descriptor.value(t2))}.`].join(" ") }, "__esModule", { value: true }), ks = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true }), Lo.__exportStar(Ns, t2);
      }), Ps = [], Os = [], Is = Object.defineProperty({ levenUnknownHandler: (e2, t2, { descriptor: n2, logger: r2, schemas: i2 }) => {
        const u2 = [`Ignored unknown option ${ws.default.yellow(n2.pair({ key: e2, value: t2 }))}.`], o2 = Object.keys(i2).sort().find((t3) => function(e3, t4) {
          if (e3 === t4)
            return 0;
          var n3 = e3;
          e3.length > t4.length && (e3 = t4, t4 = n3);
          var r3 = e3.length, i3 = t4.length;
          if (r3 === 0)
            return i3;
          if (i3 === 0)
            return r3;
          for (; r3 > 0 && e3.charCodeAt(~-r3) === t4.charCodeAt(~-i3); )
            r3--, i3--;
          if (r3 === 0)
            return i3;
          for (var u3, o3, s2, a2, c2 = 0; c2 < r3 && e3.charCodeAt(c2) === t4.charCodeAt(c2); )
            c2++;
          if (i3 -= c2, (r3 -= c2) == 0)
            return i3;
          for (var l2 = 0, p2 = 0; l2 < r3; )
            Os[c2 + l2] = e3.charCodeAt(c2 + l2), Ps[l2] = ++l2;
          for (; p2 < i3; )
            for (u3 = t4.charCodeAt(c2 + p2), s2 = p2++, o3 = p2, l2 = 0; l2 < r3; l2++)
              a2 = u3 === Os[c2 + l2] ? s2 : s2 + 1, s2 = Ps[l2], o3 = Ps[l2] = s2 > o3 ? a2 > o3 ? o3 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
          return o3;
        }(e2, t3) < 3);
        o2 && u2.push(`Did you mean ${ws.default.blue(n2.key(o2))}?`), r2.warn(u2.join(" "));
      } }, "__esModule", { value: true }), Ls = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true }), Lo.__exportStar(Is, t2);
      }), js = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true }), Lo.__exportStar(Bs, t2), Lo.__exportStar(ks, t2), Lo.__exportStar(Ls, t2);
      });
      const _s = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
      function Ms(e2, t2) {
        const n2 = new e2(t2), r2 = Object.create(n2);
        for (const e3 of _s)
          e3 in t2 && (r2[e3] = Ws(t2[e3], n2, $s.prototype[e3].length));
        return r2;
      }
      var Rs = Ms;
      class $s {
        constructor(e2) {
          this.name = e2.name;
        }
        static create(e2) {
          return Ms(this, e2);
        }
        default(e2) {
        }
        expected(e2) {
          return "nothing";
        }
        validate(e2, t2) {
          return false;
        }
        deprecated(e2, t2) {
          return false;
        }
        forward(e2, t2) {
        }
        redirect(e2, t2) {
        }
        overlap(e2, t2, n2) {
          return e2;
        }
        preprocess(e2, t2) {
          return e2;
        }
        postprocess(e2, t2) {
          return e2;
        }
      }
      var Vs = $s;
      function Ws(e2, t2, n2) {
        return typeof e2 == "function" ? (...r2) => e2(...r2.slice(0, n2 - 1), t2, ...r2.slice(n2 - 1)) : () => e2;
      }
      var qs = Object.defineProperty({ createSchema: Rs, Schema: Vs }, "__esModule", { value: true });
      class Us extends qs.Schema {
        constructor(e2) {
          super(e2), this._sourceName = e2.sourceName;
        }
        expected(e2) {
          return e2.schemas[this._sourceName].expected(e2);
        }
        validate(e2, t2) {
          return t2.schemas[this._sourceName].validate(e2, t2);
        }
        redirect(e2, t2) {
          return this._sourceName;
        }
      }
      var zs = Us, Gs = Object.defineProperty({ AliasSchema: zs }, "__esModule", { value: true });
      class Hs extends qs.Schema {
        expected() {
          return "anything";
        }
        validate() {
          return true;
        }
      }
      var Js = Hs, Xs = Object.defineProperty({ AnySchema: Js }, "__esModule", { value: true });
      class Ys extends qs.Schema {
        constructor(e2) {
          var { valueSchema: t2, name: n2 = t2.name } = e2, r2 = Lo.__rest(e2, ["valueSchema", "name"]);
          super(Object.assign({}, r2, { name: n2 })), this._valueSchema = t2;
        }
        expected(e2) {
          return `an array of ${this._valueSchema.expected(e2)}`;
        }
        validate(e2, t2) {
          if (!Array.isArray(e2))
            return false;
          const n2 = [];
          for (const r2 of e2) {
            const e3 = t2.normalizeValidateResult(this._valueSchema.validate(r2, t2), r2);
            e3 !== true && n2.push(e3.value);
          }
          return n2.length === 0 || { value: n2 };
        }
        deprecated(e2, t2) {
          const n2 = [];
          for (const r2 of e2) {
            const e3 = t2.normalizeDeprecatedResult(this._valueSchema.deprecated(r2, t2), r2);
            e3 !== false && n2.push(...e3.map(({ value: e4 }) => ({ value: [e4] })));
          }
          return n2;
        }
        forward(e2, t2) {
          const n2 = [];
          for (const r2 of e2) {
            const e3 = t2.normalizeForwardResult(this._valueSchema.forward(r2, t2), r2);
            n2.push(...e3.map(Qs));
          }
          return n2;
        }
        redirect(e2, t2) {
          const n2 = [], r2 = [];
          for (const i2 of e2) {
            const e3 = t2.normalizeRedirectResult(this._valueSchema.redirect(i2, t2), i2);
            "remain" in e3 && n2.push(e3.remain), r2.push(...e3.redirect.map(Qs));
          }
          return n2.length === 0 ? { redirect: r2 } : { redirect: r2, remain: n2 };
        }
        overlap(e2, t2) {
          return e2.concat(t2);
        }
      }
      var Ks = Ys;
      function Qs({ from: e2, to: t2 }) {
        return { from: [e2], to: t2 };
      }
      var Zs = Object.defineProperty({ ArraySchema: Ks }, "__esModule", { value: true });
      class ea extends qs.Schema {
        expected() {
          return "true or false";
        }
        validate(e2) {
          return typeof e2 == "boolean";
        }
      }
      var ta = ea, na = Object.defineProperty({ BooleanSchema: ta }, "__esModule", { value: true });
      var ra = function(e2, t2) {
        const n2 = Object.create(null);
        for (const r2 of e2) {
          const e3 = r2[t2];
          if (n2[e3])
            throw new Error(`Duplicate ${t2} ${JSON.stringify(e3)}`);
          n2[e3] = r2;
        }
        return n2;
      };
      var ia = function(e2, t2) {
        const n2 = new Map();
        for (const r2 of e2) {
          const e3 = r2[t2];
          if (n2.has(e3))
            throw new Error(`Duplicate ${t2} ${JSON.stringify(e3)}`);
          n2.set(e3, r2);
        }
        return n2;
      };
      var ua = function() {
        const e2 = Object.create(null);
        return (t2) => {
          const n2 = JSON.stringify(t2);
          return !!e2[n2] || (e2[n2] = true, false);
        };
      };
      var oa = function(e2, t2) {
        const n2 = [], r2 = [];
        for (const i2 of e2)
          t2(i2) ? n2.push(i2) : r2.push(i2);
        return [n2, r2];
      };
      var sa = function(e2) {
        return e2 === Math.floor(e2);
      };
      var aa = function(e2, t2) {
        if (e2 === t2)
          return 0;
        const n2 = typeof e2, r2 = typeof t2, i2 = ["undefined", "object", "boolean", "number", "string"];
        return n2 !== r2 ? i2.indexOf(n2) - i2.indexOf(r2) : n2 !== "string" ? Number(e2) - Number(t2) : e2.localeCompare(t2);
      };
      var ca = function(e2) {
        return e2 === void 0 ? {} : e2;
      };
      var la = function(e2, t2) {
        return e2 === true || (e2 === false ? { value: t2 } : e2);
      };
      var pa = function(e2, t2, n2 = false) {
        return e2 !== false && (e2 === true ? !!n2 || [{ value: t2 }] : "value" in e2 ? [e2] : e2.length !== 0 && e2);
      };
      function fa(e2, t2) {
        return typeof e2 == "string" || "key" in e2 ? { from: t2, to: e2 } : "from" in e2 ? { from: e2.from, to: e2.to } : { from: t2, to: e2.to };
      }
      var da = fa;
      function ha(e2, t2) {
        return e2 === void 0 ? [] : Array.isArray(e2) ? e2.map((e3) => fa(e3, t2)) : [fa(e2, t2)];
      }
      var ga = ha;
      var ma = function(e2, t2) {
        const n2 = ha(typeof e2 == "object" && "redirect" in e2 ? e2.redirect : e2, t2);
        return n2.length === 0 ? { remain: t2, redirect: n2 } : typeof e2 == "object" && "remain" in e2 ? { remain: e2.remain, redirect: n2 } : { redirect: n2 };
      }, ya = Object.defineProperty({ recordFromArray: ra, mapFromArray: ia, createAutoChecklist: ua, partition: oa, isInt: sa, comparePrimitive: aa, normalizeDefaultResult: ca, normalizeValidateResult: la, normalizeDeprecatedResult: pa, normalizeTransferResult: da, normalizeForwardResult: ga, normalizeRedirectResult: ma }, "__esModule", { value: true });
      class Da extends qs.Schema {
        constructor(e2) {
          super(e2), this._choices = ya.mapFromArray(e2.choices.map((e3) => e3 && typeof e3 == "object" ? e3 : { value: e3 }), "value");
        }
        expected({ descriptor: e2 }) {
          const t2 = Array.from(this._choices.keys()).map((e3) => this._choices.get(e3)).filter((e3) => !e3.deprecated).map((e3) => e3.value).sort(ya.comparePrimitive).map(e2.value), n2 = t2.slice(0, -2), r2 = t2.slice(-2);
          return n2.concat(r2.join(" or ")).join(", ");
        }
        validate(e2) {
          return this._choices.has(e2);
        }
        deprecated(e2) {
          const t2 = this._choices.get(e2);
          return !(!t2 || !t2.deprecated) && { value: e2 };
        }
        forward(e2) {
          const t2 = this._choices.get(e2);
          return t2 ? t2.forward : void 0;
        }
        redirect(e2) {
          const t2 = this._choices.get(e2);
          return t2 ? t2.redirect : void 0;
        }
      }
      var Ea = Da, Ca = Object.defineProperty({ ChoiceSchema: Ea }, "__esModule", { value: true });
      class ba extends qs.Schema {
        expected() {
          return "a number";
        }
        validate(e2, t2) {
          return typeof e2 == "number";
        }
      }
      var Aa = ba, va = Object.defineProperty({ NumberSchema: Aa }, "__esModule", { value: true });
      class Fa extends va.NumberSchema {
        expected() {
          return "an integer";
        }
        validate(e2, t2) {
          return t2.normalizeValidateResult(super.validate(e2, t2), e2) === true && ya.isInt(e2);
        }
      }
      var xa = Fa, Sa = Object.defineProperty({ IntegerSchema: xa }, "__esModule", { value: true });
      class wa extends qs.Schema {
        expected() {
          return "a string";
        }
        validate(e2) {
          return typeof e2 == "string";
        }
      }
      var Ta = wa, Ba = Object.defineProperty({ StringSchema: Ta }, "__esModule", { value: true }), Na = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true }), Lo.__exportStar(Gs, t2), Lo.__exportStar(Xs, t2), Lo.__exportStar(Zs, t2), Lo.__exportStar(na, t2), Lo.__exportStar(Ca, t2), Lo.__exportStar(Sa, t2), Lo.__exportStar(va, t2), Lo.__exportStar(Ba, t2);
      }), ka = jo.apiDescriptor, Pa = Is.levenUnknownHandler, Oa = ks.commonInvalidHandler, Ia = Ts.commonDeprecatedHandler, La = Object.defineProperty({ defaultDescriptor: ka, defaultUnknownHandler: Pa, defaultInvalidHandler: Oa, defaultDeprecatedHandler: Ia }, "__esModule", { value: true });
      class ja {
        constructor(e2, t2) {
          const { logger: n2 = console, descriptor: r2 = La.defaultDescriptor, unknown: i2 = La.defaultUnknownHandler, invalid: u2 = La.defaultInvalidHandler, deprecated: o2 = La.defaultDeprecatedHandler } = t2 || {};
          this._utils = { descriptor: r2, logger: n2 || { warn: () => {
          } }, schemas: ya.recordFromArray(e2, "name"), normalizeDefaultResult: ya.normalizeDefaultResult, normalizeDeprecatedResult: ya.normalizeDeprecatedResult, normalizeForwardResult: ya.normalizeForwardResult, normalizeRedirectResult: ya.normalizeRedirectResult, normalizeValidateResult: ya.normalizeValidateResult }, this._unknownHandler = i2, this._invalidHandler = u2, this._deprecatedHandler = o2, this.cleanHistory();
        }
        cleanHistory() {
          this._hasDeprecationWarned = ya.createAutoChecklist();
        }
        normalize(e2) {
          const t2 = {}, n2 = [e2], r2 = () => {
            for (; n2.length !== 0; ) {
              const e3 = n2.shift(), r3 = this._applyNormalization(e3, t2);
              n2.push(...r3);
            }
          };
          r2();
          for (const e3 of Object.keys(this._utils.schemas)) {
            const r3 = this._utils.schemas[e3];
            if (!(e3 in t2)) {
              const t3 = ya.normalizeDefaultResult(r3.default(this._utils));
              "value" in t3 && n2.push({ [e3]: t3.value });
            }
          }
          r2();
          for (const e3 of Object.keys(this._utils.schemas)) {
            const n3 = this._utils.schemas[e3];
            e3 in t2 && (t2[e3] = n3.postprocess(t2[e3], this._utils));
          }
          return t2;
        }
        _applyNormalization(e2, t2) {
          const n2 = [], [r2, i2] = ya.partition(Object.keys(e2), (e3) => e3 in this._utils.schemas);
          for (const i3 of r2) {
            const r3 = this._utils.schemas[i3], u2 = r3.preprocess(e2[i3], this._utils), o2 = ya.normalizeValidateResult(r3.validate(u2, this._utils), u2);
            if (o2 !== true) {
              const { value: e3 } = o2, t3 = this._invalidHandler(i3, e3, this._utils);
              throw typeof t3 == "string" ? new Error(t3) : t3;
            }
            const s2 = ({ from: e3, to: t3 }) => {
              n2.push(typeof t3 == "string" ? { [t3]: e3 } : { [t3.key]: t3.value });
            }, a2 = ({ value: e3, redirectTo: t3 }) => {
              const n3 = ya.normalizeDeprecatedResult(r3.deprecated(e3, this._utils), u2, true);
              if (n3 !== false)
                if (n3 === true)
                  this._hasDeprecationWarned(i3) || this._utils.logger.warn(this._deprecatedHandler(i3, t3, this._utils));
                else
                  for (const { value: e4 } of n3) {
                    const n4 = { key: i3, value: e4 };
                    if (!this._hasDeprecationWarned(n4)) {
                      const r4 = typeof t3 == "string" ? { key: t3, value: e4 } : t3;
                      this._utils.logger.warn(this._deprecatedHandler(n4, r4, this._utils));
                    }
                  }
            };
            ya.normalizeForwardResult(r3.forward(u2, this._utils), u2).forEach(s2);
            const c2 = ya.normalizeRedirectResult(r3.redirect(u2, this._utils), u2);
            if (c2.redirect.forEach(s2), "remain" in c2) {
              const e3 = c2.remain;
              t2[i3] = i3 in t2 ? r3.overlap(t2[i3], e3, this._utils) : e3, a2({ value: e3 });
            }
            for (const { from: e3, to: t3 } of c2.redirect)
              a2({ value: e3, redirectTo: t3 });
          }
          for (const r3 of i2) {
            const i3 = e2[r3], u2 = this._unknownHandler(r3, i3, this._utils);
            if (u2)
              for (const e3 of Object.keys(u2)) {
                const r4 = { [e3]: u2[e3] };
                e3 in this._utils.schemas ? n2.push(r4) : Object.assign(t2, r4);
              }
          }
          return n2;
        }
      }
      var _a = ja, Ma = Object.defineProperty({ normalize: (e2, t2, n2) => new ja(t2, n2).normalize(e2), Normalizer: _a }, "__esModule", { value: true }), Ra = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true }), Lo.__exportStar(_o, t2), Lo.__exportStar(js, t2), Lo.__exportStar(Na, t2), Lo.__exportStar(Ma, t2), Lo.__exportStar(qs, t2);
      });
      const $a = [], Va = [], Wa = (e2, t2) => {
        if (e2 === t2)
          return 0;
        const n2 = e2;
        e2.length > t2.length && (e2 = t2, t2 = n2);
        let r2 = e2.length, i2 = t2.length;
        for (; r2 > 0 && e2.charCodeAt(~-r2) === t2.charCodeAt(~-i2); )
          r2--, i2--;
        let u2, o2, s2, a2, c2 = 0;
        for (; c2 < r2 && e2.charCodeAt(c2) === t2.charCodeAt(c2); )
          c2++;
        if (r2 -= c2, i2 -= c2, r2 === 0)
          return i2;
        let l2 = 0, p2 = 0;
        for (; l2 < r2; )
          Va[l2] = e2.charCodeAt(c2 + l2), $a[l2] = ++l2;
        for (; p2 < i2; )
          for (u2 = t2.charCodeAt(c2 + p2), s2 = p2++, o2 = p2, l2 = 0; l2 < r2; l2++)
            a2 = u2 === Va[l2] ? s2 : s2 + 1, s2 = $a[l2], o2 = $a[l2] = s2 > o2 ? a2 > o2 ? o2 + 1 : a2 : a2 > s2 ? s2 + 1 : a2;
        return o2;
      };
      var qa = Wa, Ua = Wa;
      qa.default = Ua;
      var za = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      const Ga = {};
      for (const e2 of Object.keys(za))
        Ga[za[e2]] = e2;
      const Ha = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
      var Ja = Ha;
      for (const e2 of Object.keys(Ha)) {
        if (!("channels" in Ha[e2]))
          throw new Error("missing channels property: " + e2);
        if (!("labels" in Ha[e2]))
          throw new Error("missing channel labels property: " + e2);
        if (Ha[e2].labels.length !== Ha[e2].channels)
          throw new Error("channel and label counts mismatch: " + e2);
        const { channels: t2, labels: n2 } = Ha[e2];
        delete Ha[e2].channels, delete Ha[e2].labels, Object.defineProperty(Ha[e2], "channels", { value: t2 }), Object.defineProperty(Ha[e2], "labels", { value: n2 });
      }
      function Xa(e2) {
        const t2 = function() {
          const e3 = {}, t3 = Object.keys(Ja);
          for (let n3 = t3.length, r2 = 0; r2 < n3; r2++)
            e3[t3[r2]] = { distance: -1, parent: null };
          return e3;
        }(), n2 = [e2];
        for (t2[e2].distance = 0; n2.length; ) {
          const e3 = n2.pop(), r2 = Object.keys(Ja[e3]);
          for (let i2 = r2.length, u2 = 0; u2 < i2; u2++) {
            const i3 = r2[u2], o2 = t2[i3];
            o2.distance === -1 && (o2.distance = t2[e3].distance + 1, o2.parent = e3, n2.unshift(i3));
          }
        }
        return t2;
      }
      function Ya(e2, t2) {
        return function(n2) {
          return t2(e2(n2));
        };
      }
      function Ka(e2, t2) {
        const n2 = [t2[e2].parent, e2];
        let r2 = Ja[t2[e2].parent][e2], i2 = t2[e2].parent;
        for (; t2[i2].parent; )
          n2.unshift(t2[i2].parent), r2 = Ya(Ja[t2[i2].parent][i2], r2), i2 = t2[i2].parent;
        return r2.conversion = n2, r2;
      }
      Ha.rgb.hsl = function(e2) {
        const t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, i2 = Math.min(t2, n2, r2), u2 = Math.max(t2, n2, r2), o2 = u2 - i2;
        let s2, a2;
        u2 === i2 ? s2 = 0 : t2 === u2 ? s2 = (n2 - r2) / o2 : n2 === u2 ? s2 = 2 + (r2 - t2) / o2 : r2 === u2 && (s2 = 4 + (t2 - n2) / o2), s2 = Math.min(60 * s2, 360), s2 < 0 && (s2 += 360);
        const c2 = (i2 + u2) / 2;
        return a2 = u2 === i2 ? 0 : c2 <= 0.5 ? o2 / (u2 + i2) : o2 / (2 - u2 - i2), [s2, 100 * a2, 100 * c2];
      }, Ha.rgb.hsv = function(e2) {
        let t2, n2, r2, i2, u2;
        const o2 = e2[0] / 255, s2 = e2[1] / 255, a2 = e2[2] / 255, c2 = Math.max(o2, s2, a2), l2 = c2 - Math.min(o2, s2, a2), p2 = function(e3) {
          return (c2 - e3) / 6 / l2 + 0.5;
        };
        return l2 === 0 ? (i2 = 0, u2 = 0) : (u2 = l2 / c2, t2 = p2(o2), n2 = p2(s2), r2 = p2(a2), o2 === c2 ? i2 = r2 - n2 : s2 === c2 ? i2 = 1 / 3 + t2 - r2 : a2 === c2 && (i2 = 2 / 3 + n2 - t2), i2 < 0 ? i2 += 1 : i2 > 1 && (i2 -= 1)), [360 * i2, 100 * u2, 100 * c2];
      }, Ha.rgb.hwb = function(e2) {
        const t2 = e2[0], n2 = e2[1];
        let r2 = e2[2];
        const i2 = Ha.rgb.hsl(e2)[0], u2 = 1 / 255 * Math.min(t2, Math.min(n2, r2));
        return r2 = 1 - 1 / 255 * Math.max(t2, Math.max(n2, r2)), [i2, 100 * u2, 100 * r2];
      }, Ha.rgb.cmyk = function(e2) {
        const t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, i2 = Math.min(1 - t2, 1 - n2, 1 - r2);
        return [100 * ((1 - t2 - i2) / (1 - i2) || 0), 100 * ((1 - n2 - i2) / (1 - i2) || 0), 100 * ((1 - r2 - i2) / (1 - i2) || 0), 100 * i2];
      }, Ha.rgb.keyword = function(e2) {
        const t2 = Ga[e2];
        if (t2)
          return t2;
        let n2, r2 = 1 / 0;
        for (const t3 of Object.keys(za)) {
          const o2 = (u2 = za[t3], ((i2 = e2)[0] - u2[0]) ** 2 + (i2[1] - u2[1]) ** 2 + (i2[2] - u2[2]) ** 2);
          o2 < r2 && (r2 = o2, n2 = t3);
        }
        var i2, u2;
        return n2;
      }, Ha.keyword.rgb = function(e2) {
        return za[e2];
      }, Ha.rgb.xyz = function(e2) {
        let t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255;
        t2 = t2 > 0.04045 ? ((t2 + 0.055) / 1.055) ** 2.4 : t2 / 12.92, n2 = n2 > 0.04045 ? ((n2 + 0.055) / 1.055) ** 2.4 : n2 / 12.92, r2 = r2 > 0.04045 ? ((r2 + 0.055) / 1.055) ** 2.4 : r2 / 12.92;
        return [100 * (0.4124 * t2 + 0.3576 * n2 + 0.1805 * r2), 100 * (0.2126 * t2 + 0.7152 * n2 + 0.0722 * r2), 100 * (0.0193 * t2 + 0.1192 * n2 + 0.9505 * r2)];
      }, Ha.rgb.lab = function(e2) {
        const t2 = Ha.rgb.xyz(e2);
        let n2 = t2[0], r2 = t2[1], i2 = t2[2];
        n2 /= 95.047, r2 /= 100, i2 /= 108.883, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116, i2 = i2 > 8856e-6 ? i2 ** (1 / 3) : 7.787 * i2 + 16 / 116;
        return [116 * r2 - 16, 500 * (n2 - r2), 200 * (r2 - i2)];
      }, Ha.hsl.rgb = function(e2) {
        const t2 = e2[0] / 360, n2 = e2[1] / 100, r2 = e2[2] / 100;
        let i2, u2, o2;
        if (n2 === 0)
          return o2 = 255 * r2, [o2, o2, o2];
        i2 = r2 < 0.5 ? r2 * (1 + n2) : r2 + n2 - r2 * n2;
        const s2 = 2 * r2 - i2, a2 = [0, 0, 0];
        for (let e3 = 0; e3 < 3; e3++)
          u2 = t2 + 1 / 3 * -(e3 - 1), u2 < 0 && u2++, u2 > 1 && u2--, o2 = 6 * u2 < 1 ? s2 + 6 * (i2 - s2) * u2 : 2 * u2 < 1 ? i2 : 3 * u2 < 2 ? s2 + (i2 - s2) * (2 / 3 - u2) * 6 : s2, a2[e3] = 255 * o2;
        return a2;
      }, Ha.hsl.hsv = function(e2) {
        const t2 = e2[0];
        let n2 = e2[1] / 100, r2 = e2[2] / 100, i2 = n2;
        const u2 = Math.max(r2, 0.01);
        r2 *= 2, n2 *= r2 <= 1 ? r2 : 2 - r2, i2 *= u2 <= 1 ? u2 : 2 - u2;
        return [t2, 100 * (r2 === 0 ? 2 * i2 / (u2 + i2) : 2 * n2 / (r2 + n2)), 100 * ((r2 + n2) / 2)];
      }, Ha.hsv.rgb = function(e2) {
        const t2 = e2[0] / 60, n2 = e2[1] / 100;
        let r2 = e2[2] / 100;
        const i2 = Math.floor(t2) % 6, u2 = t2 - Math.floor(t2), o2 = 255 * r2 * (1 - n2), s2 = 255 * r2 * (1 - n2 * u2), a2 = 255 * r2 * (1 - n2 * (1 - u2));
        switch (r2 *= 255, i2) {
          case 0:
            return [r2, a2, o2];
          case 1:
            return [s2, r2, o2];
          case 2:
            return [o2, r2, a2];
          case 3:
            return [o2, s2, r2];
          case 4:
            return [a2, o2, r2];
          case 5:
            return [r2, o2, s2];
        }
      }, Ha.hsv.hsl = function(e2) {
        const t2 = e2[0], n2 = e2[1] / 100, r2 = e2[2] / 100, i2 = Math.max(r2, 0.01);
        let u2, o2;
        o2 = (2 - n2) * r2;
        const s2 = (2 - n2) * i2;
        return u2 = n2 * i2, u2 /= s2 <= 1 ? s2 : 2 - s2, u2 = u2 || 0, o2 /= 2, [t2, 100 * u2, 100 * o2];
      }, Ha.hwb.rgb = function(e2) {
        const t2 = e2[0] / 360;
        let n2 = e2[1] / 100, r2 = e2[2] / 100;
        const i2 = n2 + r2;
        let u2;
        i2 > 1 && (n2 /= i2, r2 /= i2);
        const o2 = Math.floor(6 * t2), s2 = 1 - r2;
        u2 = 6 * t2 - o2, (1 & o2) != 0 && (u2 = 1 - u2);
        const a2 = n2 + u2 * (s2 - n2);
        let c2, l2, p2;
        switch (o2) {
          default:
          case 6:
          case 0:
            c2 = s2, l2 = a2, p2 = n2;
            break;
          case 1:
            c2 = a2, l2 = s2, p2 = n2;
            break;
          case 2:
            c2 = n2, l2 = s2, p2 = a2;
            break;
          case 3:
            c2 = n2, l2 = a2, p2 = s2;
            break;
          case 4:
            c2 = a2, l2 = n2, p2 = s2;
            break;
          case 5:
            c2 = s2, l2 = n2, p2 = a2;
        }
        return [255 * c2, 255 * l2, 255 * p2];
      }, Ha.cmyk.rgb = function(e2) {
        const t2 = e2[0] / 100, n2 = e2[1] / 100, r2 = e2[2] / 100, i2 = e2[3] / 100;
        return [255 * (1 - Math.min(1, t2 * (1 - i2) + i2)), 255 * (1 - Math.min(1, n2 * (1 - i2) + i2)), 255 * (1 - Math.min(1, r2 * (1 - i2) + i2))];
      }, Ha.xyz.rgb = function(e2) {
        const t2 = e2[0] / 100, n2 = e2[1] / 100, r2 = e2[2] / 100;
        let i2, u2, o2;
        return i2 = 3.2406 * t2 + -1.5372 * n2 + -0.4986 * r2, u2 = -0.9689 * t2 + 1.8758 * n2 + 0.0415 * r2, o2 = 0.0557 * t2 + -0.204 * n2 + 1.057 * r2, i2 = i2 > 31308e-7 ? 1.055 * i2 ** (1 / 2.4) - 0.055 : 12.92 * i2, u2 = u2 > 31308e-7 ? 1.055 * u2 ** (1 / 2.4) - 0.055 : 12.92 * u2, o2 = o2 > 31308e-7 ? 1.055 * o2 ** (1 / 2.4) - 0.055 : 12.92 * o2, i2 = Math.min(Math.max(0, i2), 1), u2 = Math.min(Math.max(0, u2), 1), o2 = Math.min(Math.max(0, o2), 1), [255 * i2, 255 * u2, 255 * o2];
      }, Ha.xyz.lab = function(e2) {
        let t2 = e2[0], n2 = e2[1], r2 = e2[2];
        t2 /= 95.047, n2 /= 100, r2 /= 108.883, t2 = t2 > 8856e-6 ? t2 ** (1 / 3) : 7.787 * t2 + 16 / 116, n2 = n2 > 8856e-6 ? n2 ** (1 / 3) : 7.787 * n2 + 16 / 116, r2 = r2 > 8856e-6 ? r2 ** (1 / 3) : 7.787 * r2 + 16 / 116;
        return [116 * n2 - 16, 500 * (t2 - n2), 200 * (n2 - r2)];
      }, Ha.lab.xyz = function(e2) {
        let t2, n2, r2;
        n2 = (e2[0] + 16) / 116, t2 = e2[1] / 500 + n2, r2 = n2 - e2[2] / 200;
        const i2 = n2 ** 3, u2 = t2 ** 3, o2 = r2 ** 3;
        return n2 = i2 > 8856e-6 ? i2 : (n2 - 16 / 116) / 7.787, t2 = u2 > 8856e-6 ? u2 : (t2 - 16 / 116) / 7.787, r2 = o2 > 8856e-6 ? o2 : (r2 - 16 / 116) / 7.787, t2 *= 95.047, n2 *= 100, r2 *= 108.883, [t2, n2, r2];
      }, Ha.lab.lch = function(e2) {
        const t2 = e2[0], n2 = e2[1], r2 = e2[2];
        let i2;
        i2 = 360 * Math.atan2(r2, n2) / 2 / Math.PI, i2 < 0 && (i2 += 360);
        return [t2, Math.sqrt(n2 * n2 + r2 * r2), i2];
      }, Ha.lch.lab = function(e2) {
        const t2 = e2[0], n2 = e2[1], r2 = e2[2] / 360 * 2 * Math.PI;
        return [t2, n2 * Math.cos(r2), n2 * Math.sin(r2)];
      }, Ha.rgb.ansi16 = function(e2, t2 = null) {
        const [n2, r2, i2] = e2;
        let u2 = t2 === null ? Ha.rgb.hsv(e2)[2] : t2;
        if (u2 = Math.round(u2 / 50), u2 === 0)
          return 30;
        let o2 = 30 + (Math.round(i2 / 255) << 2 | Math.round(r2 / 255) << 1 | Math.round(n2 / 255));
        return u2 === 2 && (o2 += 60), o2;
      }, Ha.hsv.ansi16 = function(e2) {
        return Ha.rgb.ansi16(Ha.hsv.rgb(e2), e2[2]);
      }, Ha.rgb.ansi256 = function(e2) {
        const t2 = e2[0], n2 = e2[1], r2 = e2[2];
        if (t2 === n2 && n2 === r2)
          return t2 < 8 ? 16 : t2 > 248 ? 231 : Math.round((t2 - 8) / 247 * 24) + 232;
        return 16 + 36 * Math.round(t2 / 255 * 5) + 6 * Math.round(n2 / 255 * 5) + Math.round(r2 / 255 * 5);
      }, Ha.ansi16.rgb = function(e2) {
        let t2 = e2 % 10;
        if (t2 === 0 || t2 === 7)
          return e2 > 50 && (t2 += 3.5), t2 = t2 / 10.5 * 255, [t2, t2, t2];
        const n2 = 0.5 * (1 + ~~(e2 > 50));
        return [(1 & t2) * n2 * 255, (t2 >> 1 & 1) * n2 * 255, (t2 >> 2 & 1) * n2 * 255];
      }, Ha.ansi256.rgb = function(e2) {
        if (e2 >= 232) {
          const t3 = 10 * (e2 - 232) + 8;
          return [t3, t3, t3];
        }
        let t2;
        e2 -= 16;
        return [Math.floor(e2 / 36) / 5 * 255, Math.floor((t2 = e2 % 36) / 6) / 5 * 255, t2 % 6 / 5 * 255];
      }, Ha.rgb.hex = function(e2) {
        const t2 = (((255 & Math.round(e2[0])) << 16) + ((255 & Math.round(e2[1])) << 8) + (255 & Math.round(e2[2]))).toString(16).toUpperCase();
        return "000000".substring(t2.length) + t2;
      }, Ha.hex.rgb = function(e2) {
        const t2 = e2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!t2)
          return [0, 0, 0];
        let n2 = t2[0];
        t2[0].length === 3 && (n2 = n2.split("").map((e3) => e3 + e3).join(""));
        const r2 = parseInt(n2, 16);
        return [r2 >> 16 & 255, r2 >> 8 & 255, 255 & r2];
      }, Ha.rgb.hcg = function(e2) {
        const t2 = e2[0] / 255, n2 = e2[1] / 255, r2 = e2[2] / 255, i2 = Math.max(Math.max(t2, n2), r2), u2 = Math.min(Math.min(t2, n2), r2), o2 = i2 - u2;
        let s2, a2;
        return s2 = o2 < 1 ? u2 / (1 - o2) : 0, a2 = o2 <= 0 ? 0 : i2 === t2 ? (n2 - r2) / o2 % 6 : i2 === n2 ? 2 + (r2 - t2) / o2 : 4 + (t2 - n2) / o2, a2 /= 6, a2 %= 1, [360 * a2, 100 * o2, 100 * s2];
      }, Ha.hsl.hcg = function(e2) {
        const t2 = e2[1] / 100, n2 = e2[2] / 100, r2 = n2 < 0.5 ? 2 * t2 * n2 : 2 * t2 * (1 - n2);
        let i2 = 0;
        return r2 < 1 && (i2 = (n2 - 0.5 * r2) / (1 - r2)), [e2[0], 100 * r2, 100 * i2];
      }, Ha.hsv.hcg = function(e2) {
        const t2 = e2[1] / 100, n2 = e2[2] / 100, r2 = t2 * n2;
        let i2 = 0;
        return r2 < 1 && (i2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * i2];
      }, Ha.hcg.rgb = function(e2) {
        const t2 = e2[0] / 360, n2 = e2[1] / 100, r2 = e2[2] / 100;
        if (n2 === 0)
          return [255 * r2, 255 * r2, 255 * r2];
        const i2 = [0, 0, 0], u2 = t2 % 1 * 6, o2 = u2 % 1, s2 = 1 - o2;
        let a2 = 0;
        switch (Math.floor(u2)) {
          case 0:
            i2[0] = 1, i2[1] = o2, i2[2] = 0;
            break;
          case 1:
            i2[0] = s2, i2[1] = 1, i2[2] = 0;
            break;
          case 2:
            i2[0] = 0, i2[1] = 1, i2[2] = o2;
            break;
          case 3:
            i2[0] = 0, i2[1] = s2, i2[2] = 1;
            break;
          case 4:
            i2[0] = o2, i2[1] = 0, i2[2] = 1;
            break;
          default:
            i2[0] = 1, i2[1] = 0, i2[2] = s2;
        }
        return a2 = (1 - n2) * r2, [255 * (n2 * i2[0] + a2), 255 * (n2 * i2[1] + a2), 255 * (n2 * i2[2] + a2)];
      }, Ha.hcg.hsv = function(e2) {
        const t2 = e2[1] / 100, n2 = t2 + e2[2] / 100 * (1 - t2);
        let r2 = 0;
        return n2 > 0 && (r2 = t2 / n2), [e2[0], 100 * r2, 100 * n2];
      }, Ha.hcg.hsl = function(e2) {
        const t2 = e2[1] / 100, n2 = e2[2] / 100 * (1 - t2) + 0.5 * t2;
        let r2 = 0;
        return n2 > 0 && n2 < 0.5 ? r2 = t2 / (2 * n2) : n2 >= 0.5 && n2 < 1 && (r2 = t2 / (2 * (1 - n2))), [e2[0], 100 * r2, 100 * n2];
      }, Ha.hcg.hwb = function(e2) {
        const t2 = e2[1] / 100, n2 = t2 + e2[2] / 100 * (1 - t2);
        return [e2[0], 100 * (n2 - t2), 100 * (1 - n2)];
      }, Ha.hwb.hcg = function(e2) {
        const t2 = e2[1] / 100, n2 = 1 - e2[2] / 100, r2 = n2 - t2;
        let i2 = 0;
        return r2 < 1 && (i2 = (n2 - r2) / (1 - r2)), [e2[0], 100 * r2, 100 * i2];
      }, Ha.apple.rgb = function(e2) {
        return [e2[0] / 65535 * 255, e2[1] / 65535 * 255, e2[2] / 65535 * 255];
      }, Ha.rgb.apple = function(e2) {
        return [e2[0] / 255 * 65535, e2[1] / 255 * 65535, e2[2] / 255 * 65535];
      }, Ha.gray.rgb = function(e2) {
        return [e2[0] / 100 * 255, e2[0] / 100 * 255, e2[0] / 100 * 255];
      }, Ha.gray.hsl = function(e2) {
        return [0, 0, e2[0]];
      }, Ha.gray.hsv = Ha.gray.hsl, Ha.gray.hwb = function(e2) {
        return [0, 100, e2[0]];
      }, Ha.gray.cmyk = function(e2) {
        return [0, 0, 0, e2[0]];
      }, Ha.gray.lab = function(e2) {
        return [e2[0], 0, 0];
      }, Ha.gray.hex = function(e2) {
        const t2 = 255 & Math.round(e2[0] / 100 * 255), n2 = ((t2 << 16) + (t2 << 8) + t2).toString(16).toUpperCase();
        return "000000".substring(n2.length) + n2;
      }, Ha.rgb.gray = function(e2) {
        return [(e2[0] + e2[1] + e2[2]) / 3 / 255 * 100];
      };
      const Qa = {};
      Object.keys(Ja).forEach((e2) => {
        Qa[e2] = {}, Object.defineProperty(Qa[e2], "channels", { value: Ja[e2].channels }), Object.defineProperty(Qa[e2], "labels", { value: Ja[e2].labels });
        const t2 = function(e3) {
          const t3 = Xa(e3), n2 = {}, r2 = Object.keys(t3);
          for (let e4 = r2.length, i2 = 0; i2 < e4; i2++) {
            const e5 = r2[i2];
            t3[e5].parent !== null && (n2[e5] = Ka(e5, t3));
          }
          return n2;
        }(e2);
        Object.keys(t2).forEach((n2) => {
          const r2 = t2[n2];
          Qa[e2][n2] = function(e3) {
            const t3 = function(...t4) {
              const n3 = t4[0];
              if (n3 == null)
                return n3;
              n3.length > 1 && (t4 = n3);
              const r3 = e3(t4);
              if (typeof r3 == "object")
                for (let e4 = r3.length, t5 = 0; t5 < e4; t5++)
                  r3[t5] = Math.round(r3[t5]);
              return r3;
            };
            return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
          }(r2), Qa[e2][n2].raw = function(e3) {
            const t3 = function(...t4) {
              const n3 = t4[0];
              return n3 == null ? n3 : (n3.length > 1 && (t4 = n3), e3(t4));
            };
            return "conversion" in e3 && (t3.conversion = e3.conversion), t3;
          }(r2);
        });
      });
      var Za = Qa, ec = r(function(e2) {
        const t2 = (e3, t3) => (...n3) => `[${e3(...n3) + t3}m`, n2 = (e3, t3) => (...n3) => {
          const r3 = e3(...n3);
          return `[${38 + t3};5;${r3}m`;
        }, r2 = (e3, t3) => (...n3) => {
          const r3 = e3(...n3);
          return `[${38 + t3};2;${r3[0]};${r3[1]};${r3[2]}m`;
        }, i2 = (e3) => e3, u2 = (e3, t3, n3) => [e3, t3, n3], o2 = (e3, t3, n3) => {
          Object.defineProperty(e3, t3, { get: () => {
            const r3 = n3();
            return Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true }), r3;
          }, enumerable: true, configurable: true });
        };
        let s2;
        const a2 = (e3, t3, n3, r3) => {
          s2 === void 0 && (s2 = Za);
          const i3 = r3 ? 10 : 0, u3 = {};
          for (const [r4, o3] of Object.entries(s2)) {
            const s3 = r4 === "ansi16" ? "ansi" : r4;
            r4 === t3 ? u3[s3] = e3(n3, i3) : typeof o3 == "object" && (u3[s3] = e3(o3[t3], i3));
          }
          return u3;
        };
        Object.defineProperty(e2, "exports", { enumerable: true, get: function() {
          const e3 = new Map(), s3 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
          s3.color.gray = s3.color.blackBright, s3.bgColor.bgGray = s3.bgColor.bgBlackBright, s3.color.grey = s3.color.blackBright, s3.bgColor.bgGrey = s3.bgColor.bgBlackBright;
          for (const [t3, n3] of Object.entries(s3)) {
            for (const [t4, r3] of Object.entries(n3))
              s3[t4] = { open: `[${r3[0]}m`, close: `[${r3[1]}m` }, n3[t4] = s3[t4], e3.set(r3[0], r3[1]);
            Object.defineProperty(s3, t3, { value: n3, enumerable: false });
          }
          return Object.defineProperty(s3, "codes", { value: e3, enumerable: false }), s3.color.close = "[39m", s3.bgColor.close = "[49m", o2(s3.color, "ansi", () => a2(t2, "ansi16", i2, false)), o2(s3.color, "ansi256", () => a2(n2, "ansi256", i2, false)), o2(s3.color, "ansi16m", () => a2(r2, "rgb", u2, false)), o2(s3.bgColor, "ansi", () => a2(t2, "ansi16", i2, true)), o2(s3.bgColor, "ansi256", () => a2(n2, "ansi256", i2, true)), o2(s3.bgColor, "ansi16m", () => a2(r2, "rgb", u2, true)), s3;
        } });
      });
      function tc() {
        return false;
      }
      function nc() {
        throw new Error("tty.ReadStream is not implemented");
      }
      function rc() {
        throw new Error("tty.ReadStream is not implemented");
      }
      var ic = { isatty: tc, ReadStream: nc, WriteStream: rc }, uc = (e2, t2 = Tr.argv) => {
        const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e2), i2 = t2.indexOf("--");
        return r2 !== -1 && (i2 === -1 || r2 < i2);
      }, oc = n(Object.freeze({ __proto__: null, isatty: tc, ReadStream: nc, WriteStream: rc, default: ic }));
      const { env: sc } = Tr;
      let ac;
      function cc(e2) {
        return e2 !== 0 && { level: e2, hasBasic: true, has256: e2 >= 2, has16m: e2 >= 3 };
      }
      function lc(e2, t2) {
        if (ac === 0)
          return 0;
        if (uc("color=16m") || uc("color=full") || uc("color=truecolor"))
          return 3;
        if (uc("color=256"))
          return 2;
        if (e2 && !t2 && ac === void 0)
          return 0;
        const n2 = ac || 0;
        if (sc.TERM === "dumb")
          return n2;
        if (Tr.platform === "win32") {
          const e3 = fs.release().split(".");
          return Number(e3[0]) >= 10 && Number(e3[2]) >= 10586 ? Number(e3[2]) >= 14931 ? 3 : 2 : 1;
        }
        if ("CI" in sc)
          return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((e3) => e3 in sc) || sc.CI_NAME === "codeship" ? 1 : n2;
        if ("TEAMCITY_VERSION" in sc)
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(sc.TEAMCITY_VERSION) ? 1 : 0;
        if (sc.COLORTERM === "truecolor")
          return 3;
        if ("TERM_PROGRAM" in sc) {
          const e3 = parseInt((sc.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (sc.TERM_PROGRAM) {
            case "iTerm.app":
              return e3 >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        return /-256(color)?$/i.test(sc.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(sc.TERM) || "COLORTERM" in sc ? 1 : n2;
      }
      uc("no-color") || uc("no-colors") || uc("color=false") || uc("color=never") ? ac = 0 : (uc("color") || uc("colors") || uc("color=true") || uc("color=always")) && (ac = 1), "FORCE_COLOR" in sc && (ac = sc.FORCE_COLOR === "true" ? 1 : sc.FORCE_COLOR === "false" ? 0 : sc.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(sc.FORCE_COLOR, 10), 3));
      var pc = { supportsColor: function(e2) {
        return cc(lc(e2, e2 && e2.isTTY));
      }, stdout: cc(lc(true, oc.isatty(1))), stderr: cc(lc(true, oc.isatty(2))) };
      var fc = { stringReplaceAll: (e2, t2, n2) => {
        let r2 = e2.indexOf(t2);
        if (r2 === -1)
          return e2;
        const i2 = t2.length;
        let u2 = 0, o2 = "";
        do {
          o2 += e2.substr(u2, r2 - u2) + t2 + n2, u2 = r2 + i2, r2 = e2.indexOf(t2, u2);
        } while (r2 !== -1);
        return o2 += e2.substr(u2), o2;
      }, stringEncaseCRLFWithFirstIndex: (e2, t2, n2, r2) => {
        let i2 = 0, u2 = "";
        do {
          const o2 = e2[r2 - 1] === "\r";
          u2 += e2.substr(i2, (o2 ? r2 - 1 : r2) - i2) + t2 + (o2 ? "\r\n" : "\n") + n2, i2 = r2 + 1, r2 = e2.indexOf("\n", i2);
        } while (r2 !== -1);
        return u2 += e2.substr(i2), u2;
      } };
      const dc = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, hc = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, gc = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, mc = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi, yc = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
      function Dc(e2) {
        const t2 = e2[0] === "u", n2 = e2[1] === "{";
        return t2 && !n2 && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : t2 && n2 ? String.fromCodePoint(parseInt(e2.slice(2, -1), 16)) : yc.get(e2) || e2;
      }
      function Ec(e2, t2) {
        const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
        let i2;
        for (const t3 of r2) {
          const r3 = Number(t3);
          if (Number.isNaN(r3)) {
            if (!(i2 = t3.match(gc)))
              throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e2}')`);
            n2.push(i2[2].replace(mc, (e3, t4, n3) => t4 ? Dc(t4) : n3));
          } else
            n2.push(r3);
        }
        return n2;
      }
      function Cc(e2) {
        hc.lastIndex = 0;
        const t2 = [];
        let n2;
        for (; (n2 = hc.exec(e2)) !== null; ) {
          const e3 = n2[1];
          if (n2[2]) {
            const r2 = Ec(e3, n2[2]);
            t2.push([e3].concat(r2));
          } else
            t2.push([e3]);
        }
        return t2;
      }
      function bc(e2, t2) {
        const n2 = {};
        for (const e3 of t2)
          for (const t3 of e3.styles)
            n2[t3[0]] = e3.inverse ? null : t3.slice(1);
        let r2 = e2;
        for (const [e3, t3] of Object.entries(n2))
          if (Array.isArray(t3)) {
            if (!(e3 in r2))
              throw new Error(`Unknown Chalk style: ${e3}`);
            r2 = t3.length > 0 ? r2[e3](...t3) : r2[e3];
          }
        return r2;
      }
      var Ac = (e2, t2) => {
        const n2 = [], r2 = [];
        let i2 = [];
        if (t2.replace(dc, (t3, u2, o2, s2, a2, c2) => {
          if (u2)
            i2.push(Dc(u2));
          else if (s2) {
            const t4 = i2.join("");
            i2 = [], r2.push(n2.length === 0 ? t4 : bc(e2, n2)(t4)), n2.push({ inverse: o2, styles: Cc(s2) });
          } else if (a2) {
            if (n2.length === 0)
              throw new Error("Found extraneous } in Chalk template literal");
            r2.push(bc(e2, n2)(i2.join(""))), i2 = [], n2.pop();
          } else
            i2.push(c2);
        }), r2.push(i2.join("")), n2.length > 0) {
          const e3 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(e3);
        }
        return r2.join("");
      };
      const { stdout: vc, stderr: Fc } = pc, { stringReplaceAll: xc, stringEncaseCRLFWithFirstIndex: Sc } = fc, { isArray: wc } = Array, Tc = ["ansi", "ansi", "ansi256", "ansi16m"], Bc = Object.create(null);
      class Nc {
        constructor(e2) {
          return kc(e2);
        }
      }
      const kc = (e2) => {
        const t2 = {};
        return ((e3, t3 = {}) => {
          if (t3.level && !(Number.isInteger(t3.level) && t3.level >= 0 && t3.level <= 3))
            throw new Error("The `level` option should be an integer from 0 to 3");
          const n2 = vc ? vc.level : 0;
          e3.level = t3.level === void 0 ? n2 : t3.level;
        })(t2, e2), t2.template = (...e3) => Rc(t2.template, ...e3), Object.setPrototypeOf(t2, Pc.prototype), Object.setPrototypeOf(t2.template, t2), t2.template.constructor = () => {
          throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
        }, t2.template.Instance = Nc, t2.template;
      };
      function Pc(e2) {
        return kc(e2);
      }
      for (const [e2, t2] of Object.entries(ec))
        Bc[e2] = { get() {
          const n2 = jc(this, Lc(t2.open, t2.close, this._styler), this._isEmpty);
          return Object.defineProperty(this, e2, { value: n2 }), n2;
        } };
      Bc.visible = { get() {
        const e2 = jc(this, this._styler, true);
        return Object.defineProperty(this, "visible", { value: e2 }), e2;
      } };
      const Oc = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
      for (const e2 of Oc)
        Bc[e2] = { get() {
          const { level: t2 } = this;
          return function(...n2) {
            const r2 = Lc(ec.color[Tc[t2]][e2](...n2), ec.color.close, this._styler);
            return jc(this, r2, this._isEmpty);
          };
        } };
      for (const e2 of Oc) {
        Bc["bg" + e2[0].toUpperCase() + e2.slice(1)] = { get() {
          const { level: t2 } = this;
          return function(...n2) {
            const r2 = Lc(ec.bgColor[Tc[t2]][e2](...n2), ec.bgColor.close, this._styler);
            return jc(this, r2, this._isEmpty);
          };
        } };
      }
      const Ic = Object.defineProperties(() => {
      }, Object.assign(Object.assign({}, Bc), {}, { level: { enumerable: true, get() {
        return this._generator.level;
      }, set(e2) {
        this._generator.level = e2;
      } } })), Lc = (e2, t2, n2) => {
        let r2, i2;
        return n2 === void 0 ? (r2 = e2, i2 = t2) : (r2 = n2.openAll + e2, i2 = t2 + n2.closeAll), { open: e2, close: t2, openAll: r2, closeAll: i2, parent: n2 };
      }, jc = (e2, t2, n2) => {
        const r2 = (...e3) => wc(e3[0]) && wc(e3[0].raw) ? _c(r2, Rc(r2, ...e3)) : _c(r2, e3.length === 1 ? "" + e3[0] : e3.join(" "));
        return Object.setPrototypeOf(r2, Ic), r2._generator = e2, r2._styler = t2, r2._isEmpty = n2, r2;
      }, _c = (e2, t2) => {
        if (e2.level <= 0 || !t2)
          return e2._isEmpty ? "" : t2;
        let n2 = e2._styler;
        if (n2 === void 0)
          return t2;
        const { openAll: r2, closeAll: i2 } = n2;
        if (t2.indexOf("") !== -1)
          for (; n2 !== void 0; )
            t2 = xc(t2, n2.close, n2.open), n2 = n2.parent;
        const u2 = t2.indexOf("\n");
        return u2 !== -1 && (t2 = Sc(t2, i2, r2, u2)), r2 + t2 + i2;
      };
      let Mc;
      const Rc = (e2, ...t2) => {
        const [n2] = t2;
        if (!wc(n2) || !wc(n2.raw))
          return t2.join(" ");
        const r2 = t2.slice(1), i2 = [n2.raw[0]];
        for (let e3 = 1; e3 < n2.length; e3++)
          i2.push(String(r2[e3 - 1]).replace(/[{}\\]/g, "\\$&"), String(n2.raw[e3]));
        return Mc === void 0 && (Mc = Ac), Mc(e2, i2.join(""));
      };
      Object.defineProperties(Pc.prototype, Bc);
      const $c = Pc();
      $c.supportsColor = vc, $c.stderr = Pc({ level: Fc ? Fc.level : 0 }), $c.stderr.supportsColor = Fc;
      var Vc = $c;
      const Wc = ["_"], qc = { key: (e2) => e2.length === 1 ? `-${e2}` : `--${e2}`, value: (e2) => Ra.apiDescriptor.value(e2), pair: ({ key: e2, value: t2 }) => t2 === false ? `--no-${e2}` : t2 === true ? qc.key(e2) : t2 === "" ? `${qc.key(e2)} without an argument` : `${qc.key(e2)}=${t2}` };
      class Uc extends Ra.ChoiceSchema {
        constructor({ name: e2, flags: t2 }) {
          super({ name: e2, choices: t2 }), this._flags = [...t2].sort();
        }
        preprocess(e2, t2) {
          if (typeof e2 == "string" && e2.length > 0 && !this._flags.includes(e2)) {
            const n2 = this._flags.find((t3) => qa(t3, e2) < 3);
            if (n2)
              return t2.logger.warn([`Unknown flag ${Vc.yellow(t2.descriptor.value(e2))},`, `did you mean ${Vc.blue(t2.descriptor.value(n2))}?`].join(" ")), n2;
          }
          return e2;
        }
        expected() {
          return "a flag";
        }
      }
      let zc;
      function Gc(e2, t2, { logger: n2, isCLI: r2 = false, passThrough: i2 = false } = {}) {
        const u2 = i2 ? Array.isArray(i2) ? (e3, t3) => i2.includes(e3) ? { [e3]: t3 } : void 0 : (e3, t3) => ({ [e3]: t3 }) : (e3, t3, n3) => {
          const r3 = Mn(n3.schemas, Wc);
          return Ra.levenUnknownHandler(e3, t3, Object.assign(Object.assign({}, n3), {}, { schemas: r3 }));
        }, o2 = r2 ? qc : Ra.apiDescriptor, s2 = function(e3, { isCLI: t3 }) {
          const n3 = [];
          t3 && n3.push(Ra.AnySchema.create({ name: "_" }));
          for (const r3 of e3)
            n3.push(Hc(r3, { isCLI: t3, optionInfos: e3 })), r3.alias && t3 && n3.push(Ra.AliasSchema.create({ name: r3.alias, sourceName: r3.name }));
          return n3;
        }(t2, { isCLI: r2 }), a2 = new Ra.Normalizer(s2, { logger: n2, unknown: u2, descriptor: o2 }), c2 = n2 !== false;
        c2 && zc && (a2._hasDeprecationWarned = zc);
        const l2 = a2.normalize(e2);
        return c2 && (zc = a2._hasDeprecationWarned), l2;
      }
      function Hc(e2, { isCLI: t2, optionInfos: n2 }) {
        let r2;
        const i2 = { name: e2.name }, u2 = {};
        switch (e2.type) {
          case "int":
            r2 = Ra.IntegerSchema, t2 && (i2.preprocess = (e3) => Number(e3));
            break;
          case "string":
            r2 = Ra.StringSchema;
            break;
          case "choice":
            r2 = Ra.ChoiceSchema, i2.choices = e2.choices.map((t3) => typeof t3 == "object" && t3.redirect ? Object.assign(Object.assign({}, t3), {}, { redirect: { to: { key: e2.name, value: t3.redirect } } }) : t3);
            break;
          case "boolean":
            r2 = Ra.BooleanSchema;
            break;
          case "flag":
            r2 = Uc, i2.flags = n2.flatMap((e3) => [e3.alias, e3.description && e3.name, e3.oppositeDescription && `no-${e3.name}`].filter(Boolean));
            break;
          case "path":
            r2 = Ra.StringSchema;
            break;
          default:
            throw new Error(`Unexpected type ${e2.type}`);
        }
        if (e2.exception ? i2.validate = (t3, n3, r3) => e2.exception(t3) || n3.validate(t3, r3) : i2.validate = (e3, t3, n3) => e3 === void 0 || t3.validate(e3, n3), e2.redirect && (u2.redirect = (t3) => t3 ? { to: { key: e2.redirect.option, value: e2.redirect.value } } : void 0), e2.deprecated && (u2.deprecated = true), t2 && !e2.array) {
          const e3 = i2.preprocess || ((e4) => e4);
          i2.preprocess = (t3, n3, r3) => n3.preprocess(e3(Array.isArray(t3) ? _n(t3) : t3), r3);
        }
        return e2.array ? Ra.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, t2 ? { preprocess: (e3) => Array.isArray(e3) ? e3 : [e3] } : {}), u2), {}, { valueSchema: r2.create(i2) })) : r2.create(Object.assign(Object.assign({}, i2), u2));
      }
      var Jc = { normalizeApiOptions: function(e2, t2, n2) {
        return Gc(e2, t2, n2);
      }, normalizeCliOptions: function(e2, t2, n2) {
        return Gc(e2, t2, Object.assign({ isCLI: true }, n2));
      } };
      const { isNonEmptyArray: Xc } = Fi;
      function Yc(e2, t2) {
        const { ignoreDecorators: n2 } = t2 || {};
        if (!n2) {
          const t3 = e2.declaration && e2.declaration.decorators || e2.decorators;
          if (Xc(t3))
            return Yc(t3[0]);
        }
        return e2.range ? e2.range[0] : e2.start;
      }
      function Kc(e2) {
        return e2.range ? e2.range[1] : e2.end;
      }
      function Qc(e2, t2) {
        return Yc(e2) === Yc(t2);
      }
      var Zc = { locStart: Yc, locEnd: Kc, hasSameLocStart: Qc, hasSameLoc: function(e2, t2) {
        return Qc(e2, t2) && function(e3, t3) {
          return Kc(e3) === Kc(t3);
        }(e2, t2);
      } }, el = Object.defineProperty({ default: /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g, matchToToken: function(e2) {
        var t2 = { type: "invalid", value: e2[0], closed: void 0 };
        return e2[1] ? (t2.type = "string", t2.closed = !(!e2[3] && !e2[4])) : e2[5] ? t2.type = "comment" : e2[6] ? (t2.type = "comment", t2.closed = !!e2[7]) : e2[8] ? t2.type = "regex" : e2[9] ? t2.type = "number" : e2[10] ? t2.type = "name" : e2[11] ? t2.type = "punctuator" : e2[12] && (t2.type = "whitespace"), t2;
      } }, "__esModule", { value: true }), tl = pl, nl = fl, rl = function(e2) {
        let t2 = true;
        for (let n2 = 0; n2 < e2.length; n2++) {
          let r2 = e2.charCodeAt(n2);
          if ((64512 & r2) == 55296 && n2 + 1 < e2.length) {
            const t3 = e2.charCodeAt(++n2);
            (64512 & t3) == 56320 && (r2 = 65536 + ((1023 & r2) << 10) + (1023 & t3));
          }
          if (t2) {
            if (t2 = false, !pl(r2))
              return false;
          } else if (!fl(r2))
            return false;
        }
        return !t2;
      };
      let il = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", ul = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      const ol = new RegExp("[" + il + "]"), sl = new RegExp("[" + il + ul + "]");
      il = ul = null;
      const al = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], cl = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      function ll(e2, t2) {
        let n2 = 65536;
        for (let r2 = 0, i2 = t2.length; r2 < i2; r2 += 2) {
          if (n2 += t2[r2], n2 > e2)
            return false;
          if (n2 += t2[r2 + 1], n2 >= e2)
            return true;
        }
        return false;
      }
      function pl(e2) {
        return e2 < 65 ? e2 === 36 : e2 <= 90 || (e2 < 97 ? e2 === 95 : e2 <= 122 || (e2 <= 65535 ? e2 >= 170 && ol.test(String.fromCharCode(e2)) : ll(e2, al)));
      }
      function fl(e2) {
        return e2 < 48 ? e2 === 36 : e2 < 58 || !(e2 < 65) && (e2 <= 90 || (e2 < 97 ? e2 === 95 : e2 <= 122 || (e2 <= 65535 ? e2 >= 170 && sl.test(String.fromCharCode(e2)) : ll(e2, al) || ll(e2, cl))));
      }
      var dl = Object.defineProperty({ isIdentifierStart: tl, isIdentifierChar: nl, isIdentifierName: rl }, "__esModule", { value: true }), hl = Fl, gl = xl, ml = Sl, yl = function(e2, t2) {
        return xl(e2, t2) || Sl(e2);
      }, Dl = function(e2) {
        return bl.has(e2);
      };
      const El = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], Cl = ["eval", "arguments"], bl = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), Al = new Set(El), vl = new Set(Cl);
      function Fl(e2, t2) {
        return t2 && e2 === "await" || e2 === "enum";
      }
      function xl(e2, t2) {
        return Fl(e2, t2) || Al.has(e2);
      }
      function Sl(e2) {
        return vl.has(e2);
      }
      var wl = Object.defineProperty({ isReservedWord: hl, isStrictReservedWord: gl, isStrictBindOnlyReservedWord: ml, isStrictBindReservedWord: yl, isKeyword: Dl }, "__esModule", { value: true }), Tl = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "isIdentifierName", { enumerable: true, get: function() {
          return dl.isIdentifierName;
        } }), Object.defineProperty(t2, "isIdentifierChar", { enumerable: true, get: function() {
          return dl.isIdentifierChar;
        } }), Object.defineProperty(t2, "isIdentifierStart", { enumerable: true, get: function() {
          return dl.isIdentifierStart;
        } }), Object.defineProperty(t2, "isReservedWord", { enumerable: true, get: function() {
          return wl.isReservedWord;
        } }), Object.defineProperty(t2, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
          return wl.isStrictBindOnlyReservedWord;
        } }), Object.defineProperty(t2, "isStrictBindReservedWord", { enumerable: true, get: function() {
          return wl.isStrictBindReservedWord;
        } }), Object.defineProperty(t2, "isStrictReservedWord", { enumerable: true, get: function() {
          return wl.isStrictReservedWord;
        } }), Object.defineProperty(t2, "isKeyword", { enumerable: true, get: function() {
          return wl.isKeyword;
        } });
      }), Bl = /[|\\{}()[\]^$+*?.]/g, Nl = function(e2) {
        if (typeof e2 != "string")
          throw new TypeError("Expected a string");
        return e2.replace(Bl, "\\$&");
      }, kl = r(function(e2) {
        const t2 = (e3, t3) => function() {
          const n3 = e3.apply(Ho, arguments);
          return `[${n3 + t3}m`;
        }, n2 = (e3, t3) => function() {
          const n3 = e3.apply(Ho, arguments);
          return `[${38 + t3};5;${n3}m`;
        }, r2 = (e3, t3) => function() {
          const n3 = e3.apply(Ho, arguments);
          return `[${38 + t3};2;${n3[0]};${n3[1]};${n3[2]}m`;
        };
        Object.defineProperty(e2, "exports", { enumerable: true, get: function() {
          const e3 = new Map(), i2 = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], gray: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
          i2.color.grey = i2.color.gray;
          for (const t3 of Object.keys(i2)) {
            const n3 = i2[t3];
            for (const t4 of Object.keys(n3)) {
              const r3 = n3[t4];
              i2[t4] = { open: `[${r3[0]}m`, close: `[${r3[1]}m` }, n3[t4] = i2[t4], e3.set(r3[0], r3[1]);
            }
            Object.defineProperty(i2, t3, { value: n3, enumerable: false }), Object.defineProperty(i2, "codes", { value: e3, enumerable: false });
          }
          const u2 = (e4) => e4, o2 = (e4, t3, n3) => [e4, t3, n3];
          i2.color.close = "[39m", i2.bgColor.close = "[49m", i2.color.ansi = { ansi: t2(u2, 0) }, i2.color.ansi256 = { ansi256: n2(u2, 0) }, i2.color.ansi16m = { rgb: r2(o2, 0) }, i2.bgColor.ansi = { ansi: t2(u2, 10) }, i2.bgColor.ansi256 = { ansi256: n2(u2, 10) }, i2.bgColor.ansi16m = { rgb: r2(o2, 10) };
          for (let e4 of Object.keys(Ho)) {
            if (typeof Ho[e4] != "object")
              continue;
            const u3 = Ho[e4];
            e4 === "ansi16" && (e4 = "ansi"), "ansi16" in u3 && (i2.color.ansi[e4] = t2(u3.ansi16, 0), i2.bgColor.ansi[e4] = t2(u3.ansi16, 10)), "ansi256" in u3 && (i2.color.ansi256[e4] = n2(u3.ansi256, 0), i2.bgColor.ansi256[e4] = n2(u3.ansi256, 10)), "rgb" in u3 && (i2.color.ansi16m[e4] = r2(u3.rgb, 0), i2.bgColor.ansi16m[e4] = r2(u3.rgb, 10));
          }
          return i2;
        } });
      }), Pl = (e2, t2) => {
        t2 = t2 || Tr.argv;
        const n2 = e2.startsWith("-") ? "" : e2.length === 1 ? "-" : "--", r2 = t2.indexOf(n2 + e2), i2 = t2.indexOf("--");
        return r2 !== -1 && (i2 === -1 || r2 < i2);
      };
      const Ol = Tr.env;
      let Il;
      function Ll(e2) {
        return function(e3) {
          return e3 !== 0 && { level: e3, hasBasic: true, has256: e3 >= 2, has16m: e3 >= 3 };
        }(function(e3) {
          if (Il === false)
            return 0;
          if (Pl("color=16m") || Pl("color=full") || Pl("color=truecolor"))
            return 3;
          if (Pl("color=256"))
            return 2;
          if (e3 && !e3.isTTY && Il !== true)
            return 0;
          const t2 = Il ? 1 : 0;
          if (Tr.platform === "win32") {
            const e4 = fs.release().split(".");
            return Number(Tr.versions.node.split(".")[0]) >= 8 && Number(e4[0]) >= 10 && Number(e4[2]) >= 10586 ? Number(e4[2]) >= 14931 ? 3 : 2 : 1;
          }
          if ("CI" in Ol)
            return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((e4) => e4 in Ol) || Ol.CI_NAME === "codeship" ? 1 : t2;
          if ("TEAMCITY_VERSION" in Ol)
            return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Ol.TEAMCITY_VERSION) ? 1 : 0;
          if (Ol.COLORTERM === "truecolor")
            return 3;
          if ("TERM_PROGRAM" in Ol) {
            const e4 = parseInt((Ol.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
            switch (Ol.TERM_PROGRAM) {
              case "iTerm.app":
                return e4 >= 3 ? 3 : 2;
              case "Apple_Terminal":
                return 2;
            }
          }
          return /-256(color)?$/i.test(Ol.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Ol.TERM) || "COLORTERM" in Ol ? 1 : (Ol.TERM, t2);
        }(e2));
      }
      Pl("no-color") || Pl("no-colors") || Pl("color=false") ? Il = false : (Pl("color") || Pl("colors") || Pl("color=true") || Pl("color=always")) && (Il = true), "FORCE_COLOR" in Ol && (Il = Ol.FORCE_COLOR.length === 0 || parseInt(Ol.FORCE_COLOR, 10) !== 0);
      var jl = { supportsColor: Ll, stdout: Ll(Tr.stdout), stderr: Ll(Tr.stderr) };
      const _l = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi, Ml = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g, Rl = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/, $l = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi, Vl = new Map([["n", "\n"], ["r", "\r"], ["t", "	"], ["b", "\b"], ["f", "\f"], ["v", "\v"], ["0", "\0"], ["\\", "\\"], ["e", ""], ["a", "\x07"]]);
      function Wl(e2) {
        return e2[0] === "u" && e2.length === 5 || e2[0] === "x" && e2.length === 3 ? String.fromCharCode(parseInt(e2.slice(1), 16)) : Vl.get(e2) || e2;
      }
      function ql(e2, t2) {
        const n2 = [], r2 = t2.trim().split(/\s*,\s*/g);
        let i2;
        for (const t3 of r2)
          if (isNaN(t3)) {
            if (!(i2 = t3.match(Rl)))
              throw new Error(`Invalid Chalk template style argument: ${t3} (in style '${e2}')`);
            n2.push(i2[2].replace($l, (e3, t4, n3) => t4 ? Wl(t4) : n3));
          } else
            n2.push(Number(t3));
        return n2;
      }
      function Ul(e2) {
        Ml.lastIndex = 0;
        const t2 = [];
        let n2;
        for (; (n2 = Ml.exec(e2)) !== null; ) {
          const e3 = n2[1];
          if (n2[2]) {
            const r2 = ql(e3, n2[2]);
            t2.push([e3].concat(r2));
          } else
            t2.push([e3]);
        }
        return t2;
      }
      function zl(e2, t2) {
        const n2 = {};
        for (const e3 of t2)
          for (const t3 of e3.styles)
            n2[t3[0]] = e3.inverse ? null : t3.slice(1);
        let r2 = e2;
        for (const e3 of Object.keys(n2))
          if (Array.isArray(n2[e3])) {
            if (!(e3 in r2))
              throw new Error(`Unknown Chalk style: ${e3}`);
            r2 = n2[e3].length > 0 ? r2[e3].apply(r2, n2[e3]) : r2[e3];
          }
        return r2;
      }
      var Gl = (e2, t2) => {
        const n2 = [], r2 = [];
        let i2 = [];
        if (t2.replace(_l, (t3, u2, o2, s2, a2, c2) => {
          if (u2)
            i2.push(Wl(u2));
          else if (s2) {
            const t4 = i2.join("");
            i2 = [], r2.push(n2.length === 0 ? t4 : zl(e2, n2)(t4)), n2.push({ inverse: o2, styles: Ul(s2) });
          } else if (a2) {
            if (n2.length === 0)
              throw new Error("Found extraneous } in Chalk template literal");
            r2.push(zl(e2, n2)(i2.join(""))), i2 = [], n2.pop();
          } else
            i2.push(c2);
        }), r2.push(i2.join("")), n2.length > 0) {
          const e3 = `Chalk template literal is missing ${n2.length} closing bracket${n2.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(e3);
        }
        return r2.join("");
      }, Hl = r(function(e2) {
        const t2 = jl.stdout, n2 = Tr.platform === "win32" && !(Tr.env.TERM || "").toLowerCase().startsWith("xterm"), r2 = ["ansi", "ansi", "ansi256", "ansi16m"], i2 = new Set(["gray"]), u2 = Object.create(null);
        function o2(e3, n3) {
          n3 = n3 || {};
          const r3 = t2 ? t2.level : 0;
          e3.level = n3.level === void 0 ? r3 : n3.level, e3.enabled = "enabled" in n3 ? n3.enabled : e3.level > 0;
        }
        function s2(e3) {
          if (!this || !(this instanceof s2) || this.template) {
            const t3 = {};
            return o2(t3, e3), t3.template = function() {
              const e4 = [].slice.call(arguments);
              return p2.apply(null, [t3.template].concat(e4));
            }, Object.setPrototypeOf(t3, s2.prototype), Object.setPrototypeOf(t3.template, t3), t3.template.constructor = s2, t3.template;
          }
          o2(this, e3);
        }
        n2 && (kl.blue.open = "[94m");
        for (const e3 of Object.keys(kl))
          kl[e3].closeRe = new RegExp(Nl(kl[e3].close), "g"), u2[e3] = { get() {
            const t3 = kl[e3];
            return c2.call(this, this._styles ? this._styles.concat(t3) : [t3], this._empty, e3);
          } };
        u2.visible = { get() {
          return c2.call(this, this._styles || [], true, "visible");
        } }, kl.color.closeRe = new RegExp(Nl(kl.color.close), "g");
        for (const e3 of Object.keys(kl.color.ansi))
          i2.has(e3) || (u2[e3] = { get() {
            const t3 = this.level;
            return function() {
              const n3 = kl.color[r2[t3]][e3].apply(null, arguments), i3 = { open: n3, close: kl.color.close, closeRe: kl.color.closeRe };
              return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e3);
            };
          } });
        kl.bgColor.closeRe = new RegExp(Nl(kl.bgColor.close), "g");
        for (const e3 of Object.keys(kl.bgColor.ansi)) {
          if (i2.has(e3))
            continue;
          u2["bg" + e3[0].toUpperCase() + e3.slice(1)] = { get() {
            const t3 = this.level;
            return function() {
              const n3 = kl.bgColor[r2[t3]][e3].apply(null, arguments), i3 = { open: n3, close: kl.bgColor.close, closeRe: kl.bgColor.closeRe };
              return c2.call(this, this._styles ? this._styles.concat(i3) : [i3], this._empty, e3);
            };
          } };
        }
        const a2 = Object.defineProperties(() => {
        }, u2);
        function c2(e3, t3, n3) {
          const r3 = function() {
            return l2.apply(r3, arguments);
          };
          r3._styles = e3, r3._empty = t3;
          const i3 = this;
          return Object.defineProperty(r3, "level", { enumerable: true, get: () => i3.level, set(e4) {
            i3.level = e4;
          } }), Object.defineProperty(r3, "enabled", { enumerable: true, get: () => i3.enabled, set(e4) {
            i3.enabled = e4;
          } }), r3.hasGrey = this.hasGrey || n3 === "gray" || n3 === "grey", r3.__proto__ = a2, r3;
        }
        function l2() {
          const e3 = arguments, t3 = e3.length;
          let r3 = String(arguments[0]);
          if (t3 === 0)
            return "";
          if (t3 > 1)
            for (let n3 = 1; n3 < t3; n3++)
              r3 += " " + e3[n3];
          if (!this.enabled || this.level <= 0 || !r3)
            return this._empty ? "" : r3;
          const i3 = kl.dim.open;
          n2 && this.hasGrey && (kl.dim.open = "");
          for (const e4 of this._styles.slice().reverse())
            r3 = e4.open + r3.replace(e4.closeRe, e4.open) + e4.close, r3 = r3.replace(/\r?\n/g, `${e4.close}$&${e4.open}`);
          return kl.dim.open = i3, r3;
        }
        function p2(e3, t3) {
          if (!Array.isArray(t3))
            return [].slice.call(arguments, 1).join(" ");
          const n3 = [].slice.call(arguments, 2), r3 = [t3.raw[0]];
          for (let e4 = 1; e4 < t3.length; e4++)
            r3.push(String(n3[e4 - 1]).replace(/[{}\\]/g, "\\$&")), r3.push(String(t3.raw[e4]));
          return Gl(e3, r3.join(""));
        }
        Object.defineProperties(s2.prototype, u2), e2.exports = s2(), e2.exports.supportsColor = t2, e2.exports.default = e2.exports;
      }), Jl = tp, Xl = np, Yl = function(e2, t2 = {}) {
        if (tp(t2)) {
          const n2 = np(t2);
          return function(e3, t3) {
            let n3 = "";
            for (const { type: r2, value: i2 } of ep(t3)) {
              const t4 = e3[r2];
              n3 += t4 ? i2.split(Ql).map((e4) => t4(e4)).join("\n") : i2;
            }
            return n3;
          }(function(e3) {
            return { keyword: e3.cyan, capitalized: e3.yellow, jsxIdentifier: e3.yellow, punctuator: e3.yellow, number: e3.magenta, string: e3.green, regex: e3.magenta, comment: e3.grey, invalid: e3.white.bgRed.bold };
          }(n2), e2);
        }
        return e2;
      };
      const Kl = new Set(["as", "async", "from", "get", "of", "set"]);
      const Ql = /\r\n|[\n\r\u2028\u2029]/, Zl = /^[()[\]{}]$/;
      let ep;
      {
        const e2 = /^[a-z][\w-]*$/i, t2 = function(t3, n2, r2) {
          if (t3.type === "name") {
            if ((0, Tl.isKeyword)(t3.value) || (0, Tl.isStrictReservedWord)(t3.value, true) || Kl.has(t3.value))
              return "keyword";
            if (e2.test(t3.value) && (r2[n2 - 1] === "<" || r2.substr(n2 - 2, 2) == "</"))
              return "jsxIdentifier";
            if (t3.value[0] !== t3.value[0].toLowerCase())
              return "capitalized";
          }
          return t3.type === "punctuator" && Zl.test(t3.value) ? "bracket" : t3.type !== "invalid" || t3.value !== "@" && t3.value !== "#" ? t3.type : "punctuator";
        };
        ep = function* (e3) {
          let n2;
          for (; n2 = el.default.exec(e3); ) {
            const r2 = el.matchToToken(n2);
            yield { type: t2(r2, n2.index, e3), value: r2.value };
          }
        };
      }
      function tp(e2) {
        return !!Hl.supportsColor || e2.forceColor;
      }
      function np(e2) {
        return e2.forceColor ? new Hl.constructor({ enabled: true, level: 1 }) : Hl;
      }
      var rp = Object.defineProperty({ shouldHighlight: Jl, getChalk: Xl, default: Yl }, "__esModule", { value: true }), ip = ap, up = function(e2, t2, n2, r2 = {}) {
        if (!op) {
          op = true;
          const e3 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
          if (Tr.emitWarning)
            Tr.emitWarning(e3, "DeprecationWarning");
          else {
            new Error(e3).name = "DeprecationWarning", console.warn(new Error(e3));
          }
        }
        n2 = Math.max(n2, 0);
        return ap(e2, { start: { column: n2, line: t2 } }, r2);
      };
      let op = false;
      const sp = /\r\n|[\n\r\u2028\u2029]/;
      function ap(e2, t2, n2 = {}) {
        const r2 = (n2.highlightCode || n2.forceColor) && (0, rp.shouldHighlight)(n2), i2 = (0, rp.getChalk)(n2), u2 = function(e3) {
          return { gutter: e3.grey, marker: e3.red.bold, message: e3.red.bold };
        }(i2), o2 = (e3, t3) => r2 ? e3(t3) : t3, s2 = e2.split(sp), { start: a2, end: c2, markerLines: l2 } = function(e3, t3, n3) {
          const r3 = Object.assign({ column: 0, line: -1 }, e3.start), i3 = Object.assign({}, r3, e3.end), { linesAbove: u3 = 2, linesBelow: o3 = 3 } = n3 || {}, s3 = r3.line, a3 = r3.column, c3 = i3.line, l3 = i3.column;
          let p3 = Math.max(s3 - (u3 + 1), 0), f3 = Math.min(t3.length, c3 + o3);
          s3 === -1 && (p3 = 0), c3 === -1 && (f3 = t3.length);
          const d3 = c3 - s3, h2 = {};
          if (d3)
            for (let e4 = 0; e4 <= d3; e4++) {
              const n4 = e4 + s3;
              if (a3)
                if (e4 === 0) {
                  const e5 = t3[n4 - 1].length;
                  h2[n4] = [a3, e5 - a3 + 1];
                } else if (e4 === d3)
                  h2[n4] = [0, l3];
                else {
                  const r4 = t3[n4 - e4].length;
                  h2[n4] = [0, r4];
                }
              else
                h2[n4] = true;
            }
          else
            h2[s3] = a3 === l3 ? !a3 || [a3, 0] : [a3, l3 - a3];
          return { start: p3, end: f3, markerLines: h2 };
        }(t2, s2, n2), p2 = t2.start && typeof t2.start.column == "number", f2 = String(c2).length;
        let d2 = (r2 ? (0, rp.default)(e2, n2) : e2).split(sp).slice(a2, c2).map((e3, t3) => {
          const r3 = a2 + 1 + t3, i3 = ` ${` ${r3}`.slice(-f2)} |`, s3 = l2[r3], c3 = !l2[r3 + 1];
          if (s3) {
            let t4 = "";
            if (Array.isArray(s3)) {
              const r4 = e3.slice(0, Math.max(s3[0] - 1, 0)).replace(/[^\t]/g, " "), a3 = s3[1] || 1;
              t4 = ["\n ", o2(u2.gutter, i3.replace(/\d/g, " ")), " ", r4, o2(u2.marker, "^").repeat(a3)].join(""), c3 && n2.message && (t4 += " " + o2(u2.message, n2.message));
            }
            return [o2(u2.marker, ">"), o2(u2.gutter, i3), e3.length > 0 ? ` ${e3}` : "", t4].join("");
          }
          return ` ${o2(u2.gutter, i3)}${e3.length > 0 ? ` ${e3}` : ""}`;
        }).join("\n");
        return n2.message && !p2 && (d2 = `${" ".repeat(f2 + 1)}${n2.message}
${d2}`), r2 ? i2.reset(d2) : d2;
      }
      var cp = Object.defineProperty({ codeFrameColumns: ip, default: up }, "__esModule", { value: true }), lp = n(vu);
      const { ConfigError: pp } = Bo, { locStart: fp, locEnd: dp } = Zc, hp = Object.getOwnPropertyNames, gp = Object.getOwnPropertyDescriptor;
      function mp(e2) {
        const t2 = {};
        for (const n2 of e2.plugins)
          if (n2.parsers)
            for (const e3 of hp(n2.parsers))
              Object.defineProperty(t2, e3, gp(n2.parsers, e3));
        return t2;
      }
      function yp(e2, t2 = mp(e2)) {
        if (typeof e2.parser == "function")
          return { parse: e2.parser, astFormat: "estree", locStart: fp, locEnd: dp };
        if (typeof e2.parser == "string") {
          if (Object.prototype.hasOwnProperty.call(t2, e2.parser))
            return t2[e2.parser];
          throw new pp(`Couldn't resolve parser "${e2.parser}". Parsers must be explicitly added to the standalone bundle.`);
        }
      }
      var Dp = { parse: function(e2, t2) {
        const n2 = mp(t2), r2 = Object.defineProperties({}, Object.fromEntries(Object.keys(n2).map((e3) => [e3, { enumerable: true, get: () => n2[e3].parse }]))), i2 = yp(t2, n2);
        try {
          return i2.preprocess && (e2 = i2.preprocess(e2, t2)), { text: e2, ast: i2.parse(e2, r2, t2) };
        } catch (t3) {
          const { loc: n3 } = t3;
          if (n3) {
            const { codeFrameColumns: r3 } = cp;
            throw t3.codeFrame = r3(e2, n3, { highlightCode: true }), t3.message += "\n" + t3.codeFrame, t3;
          }
          throw t3.stack;
        }
      }, resolveParser: yp };
      const { UndefinedParserError: Ep } = Bo, { getSupportInfo: Cp } = ui, { resolveParser: bp } = Dp, Ap = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
      function vp(e2, t2) {
        const n2 = lp.basename(e2).toLowerCase(), r2 = Cp({ plugins: t2 }).languages.filter((e3) => e3.since !== null);
        let i2 = r2.find((e3) => e3.extensions && e3.extensions.some((e4) => n2.endsWith(e4)) || e3.filenames && e3.filenames.some((e4) => e4.toLowerCase() === n2));
        if (!i2 && !n2.includes(".")) {
          const t3 = function(e3) {
            if (typeof e3 != "string")
              return "";
            let t4;
            try {
              t4 = vo.openSync(e3, "r");
            } catch {
              return "";
            }
            try {
              const e4 = new Fo(t4).next().toString("utf8"), n3 = e4.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);
              if (n3)
                return n3[1];
              const r3 = e4.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);
              return r3 ? r3[1] : "";
            } catch {
              return "";
            } finally {
              try {
                vo.closeSync(t4);
              } catch {
              }
            }
          }(e2);
          i2 = r2.find((e3) => e3.interpreters && e3.interpreters.includes(t3));
        }
        return i2 && i2.parsers[0];
      }
      var Fp = { normalize: function(e2, t2 = {}) {
        const n2 = Object.assign({}, e2), r2 = Cp({ plugins: e2.plugins, showUnreleased: true, showDeprecated: true }).options, i2 = Object.assign(Object.assign({}, Ap), Object.fromEntries(r2.filter((e3) => e3.default !== void 0).map((e3) => [e3.name, e3.default])));
        if (!n2.parser)
          if (n2.filepath) {
            if (n2.parser = vp(n2.filepath, n2.plugins), !n2.parser)
              throw new Ep(`No parser could be inferred for file: ${n2.filepath}`);
          } else {
            (t2.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), n2.parser = "babel";
          }
        const u2 = bp(Jc.normalizeApiOptions(n2, [r2.find((e3) => e3.name === "parser")], { passThrough: true, logger: false }));
        n2.astFormat = u2.astFormat, n2.locEnd = u2.locEnd, n2.locStart = u2.locStart;
        const o2 = function(e3) {
          const { astFormat: t3 } = e3;
          if (!t3)
            throw new Error("getPlugin() requires astFormat to be set");
          const n3 = e3.plugins.find((e4) => e4.printers && e4.printers[t3]);
          if (!n3)
            throw new Error(`Couldn't find plugin for AST format "${t3}"`);
          return n3;
        }(n2);
        n2.printer = o2.printers[n2.astFormat];
        const s2 = Object.fromEntries(r2.filter((e3) => e3.pluginDefaults && e3.pluginDefaults[o2.name] !== void 0).map((e3) => [e3.name, e3.pluginDefaults[o2.name]])), a2 = Object.assign(Object.assign({}, i2), s2);
        for (const [e3, t3] of Object.entries(a2))
          n2[e3] !== null && n2[e3] !== void 0 || (n2[e3] = t3);
        return n2.parser === "json" && (n2.trailingComma = "none"), Jc.normalizeApiOptions(n2, r2, Object.assign({ passThrough: Object.keys(Ap) }, t2));
      }, hiddenDefaults: Ap, inferParser: vp };
      var xp = function e2(t2, n2, r2) {
        if (Array.isArray(t2))
          return t2.map((t3) => e2(t3, n2, r2)).filter(Boolean);
        if (!t2 || typeof t2 != "object")
          return t2;
        const i2 = n2.printer.massageAstNode;
        let u2;
        u2 = i2 && i2.ignoredProperties ? i2.ignoredProperties : new Set();
        const o2 = {};
        for (const [r3, i3] of Object.entries(t2))
          u2.has(r3) || typeof i3 == "function" || (o2[r3] = e2(i3, n2, t2));
        if (i2) {
          const e3 = i2(t2, o2, r2);
          if (e3 === null)
            return;
          if (e3)
            return e3;
        }
        return o2;
      }, Sp = typeof Object.create == "function" ? function(e2, t2) {
        e2.super_ = t2, e2.prototype = Object.create(t2.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } });
      } : function(e2, t2) {
        e2.super_ = t2;
        var n2 = function() {
        };
        n2.prototype = t2.prototype, e2.prototype = new n2(), e2.prototype.constructor = e2;
      };
      function wp(e2, t2) {
        var n2 = { seen: [], stylize: Bp };
        return arguments.length >= 3 && (n2.depth = arguments[2]), arguments.length >= 4 && (n2.colors = arguments[3]), Op(t2) ? n2.showHidden = t2 : t2 && Up(n2, t2), jp(n2.showHidden) && (n2.showHidden = false), jp(n2.depth) && (n2.depth = 2), jp(n2.colors) && (n2.colors = false), jp(n2.customInspect) && (n2.customInspect = true), n2.colors && (n2.stylize = Tp), Np(n2, e2, n2.depth);
      }
      function Tp(e2, t2) {
        var n2 = wp.styles[t2];
        return n2 ? "[" + wp.colors[n2][0] + "m" + e2 + "[" + wp.colors[n2][1] + "m" : e2;
      }
      function Bp(e2, t2) {
        return e2;
      }
      function Np(e2, t2, n2) {
        if (e2.customInspect && t2 && Vp(t2.inspect) && t2.inspect !== wp && (!t2.constructor || t2.constructor.prototype !== t2)) {
          var r2 = t2.inspect(n2, e2);
          return Lp(r2) || (r2 = Np(e2, r2, n2)), r2;
        }
        var i2 = function(e3, t3) {
          if (jp(t3))
            return e3.stylize("undefined", "undefined");
          if (Lp(t3)) {
            var n3 = "'" + JSON.stringify(t3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return e3.stylize(n3, "string");
          }
          if (r3 = t3, typeof r3 == "number")
            return e3.stylize("" + t3, "number");
          var r3;
          if (Op(t3))
            return e3.stylize("" + t3, "boolean");
          if (Ip(t3))
            return e3.stylize("null", "null");
        }(e2, t2);
        if (i2)
          return i2;
        var u2 = Object.keys(t2), o2 = function(e3) {
          var t3 = {};
          return e3.forEach(function(e4, n3) {
            t3[e4] = true;
          }), t3;
        }(u2);
        if (e2.showHidden && (u2 = Object.getOwnPropertyNames(t2)), $p(t2) && (u2.indexOf("message") >= 0 || u2.indexOf("description") >= 0))
          return kp(t2);
        if (u2.length === 0) {
          if (Vp(t2)) {
            var s2 = t2.name ? ": " + t2.name : "";
            return e2.stylize("[Function" + s2 + "]", "special");
          }
          if (_p(t2))
            return e2.stylize(RegExp.prototype.toString.call(t2), "regexp");
          if (Rp(t2))
            return e2.stylize(Date.prototype.toString.call(t2), "date");
          if ($p(t2))
            return kp(t2);
        }
        var a2, c2, l2 = "", p2 = false, f2 = ["{", "}"];
        (a2 = t2, Array.isArray(a2) && (p2 = true, f2 = ["[", "]"]), Vp(t2)) && (l2 = " [Function" + (t2.name ? ": " + t2.name : "") + "]");
        return _p(t2) && (l2 = " " + RegExp.prototype.toString.call(t2)), Rp(t2) && (l2 = " " + Date.prototype.toUTCString.call(t2)), $p(t2) && (l2 = " " + kp(t2)), u2.length !== 0 || p2 && t2.length != 0 ? n2 < 0 ? _p(t2) ? e2.stylize(RegExp.prototype.toString.call(t2), "regexp") : e2.stylize("[Object]", "special") : (e2.seen.push(t2), c2 = p2 ? function(e3, t3, n3, r3, i3) {
          for (var u3 = [], o3 = 0, s3 = t3.length; o3 < s3; ++o3)
            zp(t3, String(o3)) ? u3.push(Pp(e3, t3, n3, r3, String(o3), true)) : u3.push("");
          return i3.forEach(function(i4) {
            i4.match(/^\d+$/) || u3.push(Pp(e3, t3, n3, r3, i4, true));
          }), u3;
        }(e2, t2, n2, o2, u2) : u2.map(function(r3) {
          return Pp(e2, t2, n2, o2, r3, p2);
        }), e2.seen.pop(), function(e3, t3, n3) {
          if (e3.reduce(function(e4, t4) {
            return t4.indexOf("\n"), e4 + t4.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0) > 60)
            return n3[0] + (t3 === "" ? "" : t3 + "\n ") + " " + e3.join(",\n  ") + " " + n3[1];
          return n3[0] + t3 + " " + e3.join(", ") + " " + n3[1];
        }(c2, l2, f2)) : f2[0] + l2 + f2[1];
      }
      function kp(e2) {
        return "[" + Error.prototype.toString.call(e2) + "]";
      }
      function Pp(e2, t2, n2, r2, i2, u2) {
        var o2, s2, a2;
        if ((a2 = Object.getOwnPropertyDescriptor(t2, i2) || { value: t2[i2] }).get ? s2 = a2.set ? e2.stylize("[Getter/Setter]", "special") : e2.stylize("[Getter]", "special") : a2.set && (s2 = e2.stylize("[Setter]", "special")), zp(r2, i2) || (o2 = "[" + i2 + "]"), s2 || (e2.seen.indexOf(a2.value) < 0 ? (s2 = Ip(n2) ? Np(e2, a2.value, null) : Np(e2, a2.value, n2 - 1)).indexOf("\n") > -1 && (s2 = u2 ? s2.split("\n").map(function(e3) {
          return "  " + e3;
        }).join("\n").substr(2) : "\n" + s2.split("\n").map(function(e3) {
          return "   " + e3;
        }).join("\n")) : s2 = e2.stylize("[Circular]", "special")), jp(o2)) {
          if (u2 && i2.match(/^\d+$/))
            return s2;
          (o2 = JSON.stringify("" + i2)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o2 = o2.substr(1, o2.length - 2), o2 = e2.stylize(o2, "name")) : (o2 = o2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o2 = e2.stylize(o2, "string"));
        }
        return o2 + ": " + s2;
      }
      function Op(e2) {
        return typeof e2 == "boolean";
      }
      function Ip(e2) {
        return e2 === null;
      }
      function Lp(e2) {
        return typeof e2 == "string";
      }
      function jp(e2) {
        return e2 === void 0;
      }
      function _p(e2) {
        return Mp(e2) && qp(e2) === "[object RegExp]";
      }
      function Mp(e2) {
        return typeof e2 == "object" && e2 !== null;
      }
      function Rp(e2) {
        return Mp(e2) && qp(e2) === "[object Date]";
      }
      function $p(e2) {
        return Mp(e2) && (qp(e2) === "[object Error]" || e2 instanceof Error);
      }
      function Vp(e2) {
        return typeof e2 == "function";
      }
      function Wp(e2) {
        return e2 === null || typeof e2 == "boolean" || typeof e2 == "number" || typeof e2 == "string" || typeof e2 == "symbol" || e2 === void 0;
      }
      function qp(e2) {
        return Object.prototype.toString.call(e2);
      }
      function Up(e2, t2) {
        if (!t2 || !Mp(t2))
          return e2;
        for (var n2 = Object.keys(t2), r2 = n2.length; r2--; )
          e2[n2[r2]] = t2[n2[r2]];
        return e2;
      }
      function zp(e2, t2) {
        return Object.prototype.hasOwnProperty.call(e2, t2);
      }
      function Gp(e2, t2) {
        if (e2 === t2)
          return 0;
        for (var n2 = e2.length, r2 = t2.length, i2 = 0, u2 = Math.min(n2, r2); i2 < u2; ++i2)
          if (e2[i2] !== t2[i2]) {
            n2 = e2[i2], r2 = t2[i2];
            break;
          }
        return n2 < r2 ? -1 : r2 < n2 ? 1 : 0;
      }
      wp.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, wp.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
      var Hp, Jp = Object.prototype.hasOwnProperty, Xp = Object.keys || function(e2) {
        var t2 = [];
        for (var n2 in e2)
          Jp.call(e2, n2) && t2.push(n2);
        return t2;
      }, Yp = Array.prototype.slice;
      function Kp() {
        return Hp !== void 0 ? Hp : Hp = function() {
        }.name === "foo";
      }
      function Qp(e2) {
        return Object.prototype.toString.call(e2);
      }
      function Zp(e2) {
        return !bo(e2) && (typeof ir.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e2) : !!e2 && (e2 instanceof DataView || !!(e2.buffer && e2.buffer instanceof ArrayBuffer))));
      }
      function ef(e2, t2) {
        e2 || sf(e2, true, t2, "==", af);
      }
      var tf = /\s*function\s+([^\(\s]*)\s*/;
      function nf(e2) {
        if (Vp(e2)) {
          if (Kp())
            return e2.name;
          var t2 = e2.toString().match(tf);
          return t2 && t2[1];
        }
      }
      function rf(e2) {
        this.name = "AssertionError", this.actual = e2.actual, this.expected = e2.expected, this.operator = e2.operator, e2.message ? (this.message = e2.message, this.generatedMessage = false) : (this.message = function(e3) {
          return uf(of(e3.actual), 128) + " " + e3.operator + " " + uf(of(e3.expected), 128);
        }(this), this.generatedMessage = true);
        var t2 = e2.stackStartFunction || sf;
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, t2);
        else {
          var n2 = new Error();
          if (n2.stack) {
            var r2 = n2.stack, i2 = nf(t2), u2 = r2.indexOf("\n" + i2);
            if (u2 >= 0) {
              var o2 = r2.indexOf("\n", u2 + 1);
              r2 = r2.substring(o2 + 1);
            }
            this.stack = r2;
          }
        }
      }
      function uf(e2, t2) {
        return typeof e2 == "string" ? e2.length < t2 ? e2 : e2.slice(0, t2) : e2;
      }
      function of(e2) {
        if (Kp() || !Vp(e2))
          return wp(e2);
        var t2 = nf(e2);
        return "[Function" + (t2 ? ": " + t2 : "") + "]";
      }
      function sf(e2, t2, n2, r2, i2) {
        throw new rf({ message: n2, actual: e2, expected: t2, operator: r2, stackStartFunction: i2 });
      }
      function af(e2, t2) {
        e2 || sf(e2, true, t2, "==", af);
      }
      function cf(e2, t2, n2) {
        e2 != t2 && sf(e2, t2, n2, "==", cf);
      }
      function lf(e2, t2, n2) {
        e2 == t2 && sf(e2, t2, n2, "!=", lf);
      }
      function pf(e2, t2, n2) {
        df(e2, t2, false) || sf(e2, t2, n2, "deepEqual", pf);
      }
      function ff(e2, t2, n2) {
        df(e2, t2, true) || sf(e2, t2, n2, "deepStrictEqual", ff);
      }
      function df(e2, t2, n2, r2) {
        if (e2 === t2)
          return true;
        if (bo(e2) && bo(t2))
          return Gp(e2, t2) === 0;
        if (Rp(e2) && Rp(t2))
          return e2.getTime() === t2.getTime();
        if (_p(e2) && _p(t2))
          return e2.source === t2.source && e2.global === t2.global && e2.multiline === t2.multiline && e2.lastIndex === t2.lastIndex && e2.ignoreCase === t2.ignoreCase;
        if (e2 !== null && typeof e2 == "object" || t2 !== null && typeof t2 == "object") {
          if (Zp(e2) && Zp(t2) && Qp(e2) === Qp(t2) && !(e2 instanceof Float32Array || e2 instanceof Float64Array))
            return Gp(new Uint8Array(e2.buffer), new Uint8Array(t2.buffer)) === 0;
          if (bo(e2) !== bo(t2))
            return false;
          var i2 = (r2 = r2 || { actual: [], expected: [] }).actual.indexOf(e2);
          return i2 !== -1 && i2 === r2.expected.indexOf(t2) || (r2.actual.push(e2), r2.expected.push(t2), function(e3, t3, n3, r3) {
            if (e3 == null || t3 == null)
              return false;
            if (Wp(e3) || Wp(t3))
              return e3 === t3;
            if (n3 && Object.getPrototypeOf(e3) !== Object.getPrototypeOf(t3))
              return false;
            var i3 = hf(e3), u2 = hf(t3);
            if (i3 && !u2 || !i3 && u2)
              return false;
            if (i3)
              return df(e3 = Yp.call(e3), t3 = Yp.call(t3), n3);
            var o2, s2, a2 = Xp(e3), c2 = Xp(t3);
            if (a2.length !== c2.length)
              return false;
            for (a2.sort(), c2.sort(), s2 = a2.length - 1; s2 >= 0; s2--)
              if (a2[s2] !== c2[s2])
                return false;
            for (s2 = a2.length - 1; s2 >= 0; s2--)
              if (!df(e3[o2 = a2[s2]], t3[o2], n3, r3))
                return false;
            return true;
          }(e2, t2, n2, r2));
        }
        return n2 ? e2 === t2 : e2 == t2;
      }
      function hf(e2) {
        return Object.prototype.toString.call(e2) == "[object Arguments]";
      }
      function gf(e2, t2, n2) {
        df(e2, t2, false) && sf(e2, t2, n2, "notDeepEqual", gf);
      }
      function mf(e2, t2, n2) {
        df(e2, t2, true) && sf(e2, t2, n2, "notDeepStrictEqual", mf);
      }
      function yf(e2, t2, n2) {
        e2 !== t2 && sf(e2, t2, n2, "===", yf);
      }
      function Df(e2, t2, n2) {
        e2 === t2 && sf(e2, t2, n2, "!==", Df);
      }
      function Ef(e2, t2) {
        if (!e2 || !t2)
          return false;
        if (Object.prototype.toString.call(t2) == "[object RegExp]")
          return t2.test(e2);
        try {
          if (e2 instanceof t2)
            return true;
        } catch (e3) {
        }
        return !Error.isPrototypeOf(t2) && t2.call({}, e2) === true;
      }
      function Cf(e2, t2, n2, r2) {
        var i2;
        if (typeof t2 != "function")
          throw new TypeError('"block" argument must be a function');
        typeof n2 == "string" && (r2 = n2, n2 = null), i2 = function(e3) {
          var t3;
          try {
            e3();
          } catch (e4) {
            t3 = e4;
          }
          return t3;
        }(t2), r2 = (n2 && n2.name ? " (" + n2.name + ")." : ".") + (r2 ? " " + r2 : "."), e2 && !i2 && sf(i2, n2, "Missing expected exception" + r2);
        var u2 = typeof r2 == "string", o2 = !e2 && i2 && !n2;
        if ((!e2 && $p(i2) && u2 && Ef(i2, n2) || o2) && sf(i2, n2, "Got unwanted exception" + r2), e2 && i2 && n2 && !Ef(i2, n2) || !e2 && i2)
          throw i2;
      }
      function bf(e2, t2, n2) {
        Cf(true, e2, t2, n2);
      }
      function Af(e2, t2, n2) {
        Cf(false, e2, t2, n2);
      }
      function vf(e2) {
        if (e2)
          throw e2;
      }
      ef.AssertionError = rf, Sp(rf, Error), ef.fail = sf, ef.ok = af, ef.equal = cf, ef.notEqual = lf, ef.deepEqual = pf, ef.deepStrictEqual = ff, ef.notDeepEqual = gf, ef.notDeepStrictEqual = mf, ef.strictEqual = yf, ef.notStrictEqual = Df, ef.throws = bf, ef.doesNotThrow = Af, ef.ifError = vf;
      var Ff = n(Object.freeze({ __proto__: null, default: ef, AssertionError: rf, fail: sf, ok: af, assert: af, equal: cf, notEqual: lf, deepEqual: pf, deepStrictEqual: ff, notDeepEqual: gf, notDeepStrictEqual: mf, strictEqual: yf, notStrictEqual: Df, throws: bf, doesNotThrow: Af, ifError: vf }));
      const { builders: { line: xf, hardline: Sf, breakParent: wf, indent: Tf, lineSuffix: Bf, join: Nf, cursor: kf } } = su, { hasNewline: Pf, skipNewline: Of, skipSpaces: If, isPreviousLineEmpty: Lf, addLeadingComment: jf, addDanglingComment: _f, addTrailingComment: Mf } = Fi, Rf = new WeakMap();
      function $f(e2, t2, n2) {
        if (!e2)
          return;
        const { printer: r2, locStart: i2, locEnd: u2 } = t2;
        if (n2) {
          if (r2.canAttachComment && r2.canAttachComment(e2)) {
            let t3;
            for (t3 = n2.length - 1; t3 >= 0 && !(i2(n2[t3]) <= i2(e2) && u2(n2[t3]) <= u2(e2)); --t3)
              ;
            return void n2.splice(t3 + 1, 0, e2);
          }
        } else if (Rf.has(e2))
          return Rf.get(e2);
        const o2 = r2.getCommentChildNodes && r2.getCommentChildNodes(e2, t2) || typeof e2 == "object" && Object.entries(e2).filter(([e3]) => e3 !== "enclosingNode" && e3 !== "precedingNode" && e3 !== "followingNode" && e3 !== "tokens" && e3 !== "comments").map(([, e3]) => e3);
        if (o2) {
          n2 || (n2 = [], Rf.set(e2, n2));
          for (const e3 of o2)
            $f(e3, t2, n2);
          return n2;
        }
      }
      function Vf(e2, t2, n2, r2) {
        const { locStart: i2, locEnd: u2 } = n2, o2 = i2(t2), s2 = u2(t2), a2 = $f(e2, n2);
        let c2, l2, p2 = 0, f2 = a2.length;
        for (; p2 < f2; ) {
          const e3 = p2 + f2 >> 1, r3 = a2[e3], d2 = i2(r3), h2 = u2(r3);
          if (d2 <= o2 && s2 <= h2)
            return Vf(r3, t2, n2, r3);
          if (h2 <= o2)
            c2 = r3, p2 = e3 + 1;
          else {
            if (!(s2 <= d2))
              throw new Error("Comment location overlaps with node location");
            l2 = r3, f2 = e3;
          }
        }
        if (r2 && r2.type === "TemplateLiteral") {
          const { quasis: e3 } = r2, i3 = Jf(e3, t2, n2);
          c2 && Jf(e3, c2, n2) !== i3 && (c2 = null), l2 && Jf(e3, l2, n2) !== i3 && (l2 = null);
        }
        return { enclosingNode: r2, precedingNode: c2, followingNode: l2 };
      }
      const Wf = () => false;
      const qf = (e2) => !/[\S\n\u2028\u2029]/.test(e2);
      function Uf(e2, t2, n2, r2) {
        const { comment: i2, precedingNode: u2 } = n2[r2], { locStart: o2, locEnd: s2 } = t2;
        let a2 = o2(i2);
        if (u2)
          for (let t3 = r2 - 1; t3 >= 0; t3--) {
            const { comment: r3, precedingNode: i3 } = n2[t3];
            if (i3 !== u2 || !qf(e2.slice(s2(r3), a2)))
              break;
            a2 = o2(r3);
          }
        return Pf(e2, a2, { backwards: true });
      }
      function zf(e2, t2, n2, r2) {
        const { comment: i2, followingNode: u2 } = n2[r2], { locStart: o2, locEnd: s2 } = t2;
        let a2 = s2(i2);
        if (u2)
          for (let t3 = r2 + 1; t3 < n2.length; t3++) {
            const { comment: r3, followingNode: i3 } = n2[t3];
            if (i3 !== u2 || !qf(e2.slice(a2, o2(r3))))
              break;
            a2 = s2(r3);
          }
        return Pf(e2, a2);
      }
      function Gf(e2, t2, n2) {
        const r2 = e2.length;
        if (r2 === 0)
          return;
        const { precedingNode: i2, followingNode: u2, enclosingNode: o2 } = e2[0], s2 = n2.printer.getGapRegex && n2.printer.getGapRegex(o2) || /^[\s(]*$/;
        let a2, c2 = n2.locStart(u2);
        for (a2 = r2; a2 > 0; --a2) {
          const { comment: r3, precedingNode: o3, followingNode: l2 } = e2[a2 - 1];
          Ff.strictEqual(o3, i2), Ff.strictEqual(l2, u2);
          const p2 = t2.slice(n2.locEnd(r3), c2);
          if (!s2.test(p2))
            break;
          c2 = n2.locStart(r3);
        }
        for (const [t3, { comment: n3 }] of e2.entries())
          t3 < a2 ? Mf(i2, n3) : jf(u2, n3);
        for (const e3 of [i2, u2])
          e3.comments && e3.comments.length > 1 && e3.comments.sort((e4, t3) => n2.locStart(e4) - n2.locStart(t3));
        e2.length = 0;
      }
      function Hf(e2, t2) {
        return e2.getValue().printed = true, t2.printer.printComment(e2, t2);
      }
      function Jf(e2, t2, n2) {
        const r2 = n2.locStart(t2) - 1;
        for (let t3 = 1; t3 < e2.length; ++t3)
          if (r2 < n2.locStart(e2[t3]))
            return t3 - 1;
        return 0;
      }
      function Xf(e2, t2, n2) {
        const r2 = e2.getValue();
        if (!r2)
          return {};
        let i2 = r2.comments || [];
        n2 && (i2 = i2.filter((e3) => !n2.has(e3)));
        const u2 = r2 === t2.cursorNode;
        if (i2.length === 0) {
          const e3 = u2 ? kf : "";
          return { leading: e3, trailing: e3 };
        }
        const o2 = [], s2 = [];
        return e2.each(() => {
          const r3 = e2.getValue();
          if (n2 && n2.has(r3))
            return;
          const { leading: i3, trailing: u3 } = r3;
          i3 ? o2.push(function(e3, t3) {
            const n3 = e3.getValue(), r4 = [Hf(e3, t3)], { printer: i4, originalText: u4, locStart: o3, locEnd: s3 } = t3;
            if (i4.isBlockComment && i4.isBlockComment(n3)) {
              const e4 = Pf(u4, s3(n3)) ? Pf(u4, o3(n3), { backwards: true }) ? Sf : xf : " ";
              r4.push(e4);
            } else
              r4.push(Sf);
            const a2 = Of(u4, If(u4, s3(n3)));
            return a2 !== false && Pf(u4, a2) && r4.push(Sf), r4;
          }(e2, t2)) : u3 && s2.push(function(e3, t3) {
            const n3 = e3.getValue(), r4 = Hf(e3, t3), { printer: i4, originalText: u4, locStart: o3 } = t3, s3 = i4.isBlockComment && i4.isBlockComment(n3);
            if (Pf(u4, o3(n3), { backwards: true })) {
              const e4 = Lf(u4, n3, o3);
              return Bf([Sf, e4 ? Sf : "", r4]);
            }
            let a2 = [" ", r4];
            return s3 || (a2 = [Bf(a2), wf]), a2;
          }(e2, t2));
        }, "comments"), u2 && (o2.unshift(kf), s2.push(kf)), { leading: o2, trailing: s2 };
      }
      var Yf = { attach: function(e2, t2, n2, r2) {
        if (!Array.isArray(e2))
          return;
        const i2 = [], { locStart: u2, locEnd: o2, printer: { handleComments: s2 = {} } } = r2, { avoidAstMutation: a2, ownLine: c2 = Wf, endOfLine: l2 = Wf, remaining: p2 = Wf } = s2, f2 = e2.map((i3, u3) => Object.assign(Object.assign({}, Vf(t2, i3, r2)), {}, { comment: i3, text: n2, options: r2, ast: t2, isLastComment: e2.length - 1 === u3 }));
        for (const [e3, t3] of f2.entries()) {
          const { comment: n3, precedingNode: r3, enclosingNode: s3, followingNode: d2, text: h2, options: g2, ast: m2, isLastComment: y2 } = t3;
          if (g2.parser === "json" || g2.parser === "json5" || g2.parser === "__js_expression" || g2.parser === "__vue_expression") {
            if (u2(n3) - u2(m2) <= 0) {
              jf(m2, n3);
              continue;
            }
            if (o2(n3) - o2(m2) >= 0) {
              Mf(m2, n3);
              continue;
            }
          }
          let D2;
          if (a2 ? D2 = [t3] : (n3.enclosingNode = s3, n3.precedingNode = r3, n3.followingNode = d2, D2 = [n3, h2, g2, m2, y2]), Uf(h2, g2, f2, e3))
            n3.placement = "ownLine", c2(...D2) || (d2 ? jf(d2, n3) : r3 ? Mf(r3, n3) : _f(s3 || m2, n3));
          else if (zf(h2, g2, f2, e3))
            n3.placement = "endOfLine", l2(...D2) || (r3 ? Mf(r3, n3) : d2 ? jf(d2, n3) : _f(s3 || m2, n3));
          else if (n3.placement = "remaining", p2(...D2))
            ;
          else if (r3 && d2) {
            const e4 = i2.length;
            if (e4 > 0) {
              i2[e4 - 1].followingNode !== d2 && Gf(i2, h2, g2);
            }
            i2.push(t3);
          } else
            r3 ? Mf(r3, n3) : d2 ? jf(d2, n3) : _f(s3 || m2, n3);
        }
        if (Gf(i2, n2, r2), !a2)
          for (const t3 of e2)
            delete t3.precedingNode, delete t3.enclosingNode, delete t3.followingNode;
      }, printComments: function(e2, t2, n2, r2) {
        const { leading: i2, trailing: u2 } = Xf(e2, n2, r2);
        return i2 || u2 ? [i2, t2, u2] : t2;
      }, printCommentsSeparately: Xf, printDanglingComments: function(e2, t2, n2, r2) {
        const i2 = [], u2 = e2.getValue();
        return u2 && u2.comments ? (e2.each(() => {
          const n3 = e2.getValue();
          n3.leading || n3.trailing || r2 && !r2(n3) || i2.push(Hf(e2, t2));
        }, "comments"), i2.length === 0 ? "" : n2 ? Nf(Sf, i2) : Tf([Sf, Nf(Sf, i2)])) : "";
      }, getSortedChildNodes: $f, ensureAllCommentsPrinted: function(e2) {
        if (e2)
          for (const t2 of e2) {
            if (!t2.printed)
              throw new Error('Comment "' + t2.value.trim() + '" was not printed. Please report this error!');
            delete t2.printed;
          }
      } };
      function Kf(e2, t2) {
        const n2 = Qf(e2.stack, t2);
        return n2 === -1 ? null : e2.stack[n2];
      }
      function Qf(e2, t2) {
        for (let n2 = e2.length - 1; n2 >= 0; n2 -= 2) {
          const r2 = e2[n2];
          if (r2 && !Array.isArray(r2) && --t2 < 0)
            return n2;
        }
        return -1;
      }
      var Zf = class {
        constructor(e2) {
          this.stack = [e2];
        }
        getName() {
          const { stack: e2 } = this, { length: t2 } = e2;
          return t2 > 1 ? e2[t2 - 2] : null;
        }
        getValue() {
          return _n(this.stack);
        }
        getNode(e2 = 0) {
          return Kf(this, e2);
        }
        getParentNode(e2 = 0) {
          return Kf(this, e2 + 1);
        }
        call(e2, ...t2) {
          const { stack: n2 } = this, { length: r2 } = n2;
          let i2 = _n(n2);
          for (const e3 of t2)
            i2 = i2[e3], n2.push(e3, i2);
          const u2 = e2(this);
          return n2.length = r2, u2;
        }
        callParent(e2, t2 = 0) {
          const n2 = Qf(this.stack, t2 + 1), r2 = this.stack.splice(n2 + 1), i2 = e2(this);
          return this.stack.push(...r2), i2;
        }
        each(e2, ...t2) {
          const { stack: n2 } = this, { length: r2 } = n2;
          let i2 = _n(n2);
          for (const e3 of t2)
            i2 = i2[e3], n2.push(e3, i2);
          for (let t3 = 0; t3 < i2.length; ++t3)
            n2.push(t3, i2[t3]), e2(this, t3, i2), n2.length -= 2;
          n2.length = r2;
        }
        map(e2, ...t2) {
          const n2 = [];
          return this.each((t3, r2, i2) => {
            n2[r2] = e2(t3, r2, i2);
          }, ...t2), n2;
        }
        try(e2) {
          const { stack: t2 } = this, n2 = [...t2];
          try {
            return e2();
          } finally {
            t2.length = 0, t2.push(...n2);
          }
        }
        match(...e2) {
          let t2 = this.stack.length - 1, n2 = null, r2 = this.stack[t2--];
          for (const i2 of e2) {
            if (r2 === void 0)
              return false;
            let e3 = null;
            if (typeof n2 == "number" && (e3 = n2, n2 = this.stack[t2--], r2 = this.stack[t2--]), i2 && !i2(r2, n2, e3))
              return false;
            n2 = this.stack[t2--], r2 = this.stack[t2--];
          }
          return true;
        }
        findAncestor(e2) {
          let t2 = this.stack.length - 1, n2 = null, r2 = this.stack[t2--];
          for (; r2; ) {
            let i2 = null;
            if (typeof n2 == "number" && (i2 = n2, n2 = this.stack[t2--], r2 = this.stack[t2--]), n2 !== null && e2(r2, n2, i2))
              return r2;
            n2 = this.stack[t2--], r2 = this.stack[t2--];
          }
        }
      };
      const { utils: { stripTrailingHardline: ed } } = su, { normalize: td } = Fp;
      var nd = { printSubtree: function(e2, t2, n2, r2) {
        if (n2.printer.embed && n2.embeddedLanguageFormatting === "auto")
          return n2.printer.embed(e2, t2, (e3, t3, i2) => function(e4, t4, n3, r3, { stripTrailingHardline: i3 = false } = {}) {
            const u2 = td(Object.assign(Object.assign(Object.assign({}, n3), t4), {}, { parentParser: n3.parser, originalText: e4 }), { passThrough: true }), o2 = Dp.parse(e4, u2), { ast: s2 } = o2;
            e4 = o2.text;
            const a2 = s2.comments;
            delete s2.comments, Yf.attach(a2, s2, e4, u2), u2[Symbol.for("comments")] = a2 || [], u2[Symbol.for("tokens")] = s2.tokens || [];
            const c2 = r3(s2, u2);
            if (Yf.ensureAllCommentsPrinted(a2), i3)
              return typeof c2 == "string" ? c2.replace(/(?:\r?\n)*$/, "") : ed(c2);
            return c2;
          }(e3, t3, n2, r2, i2), n2);
      } };
      const { builders: { hardline: rd, addAlignmentToDoc: id }, utils: { propagateBreaks: ud } } = su, { printComments: od } = Yf;
      function sd(e2, n2, r2 = 0) {
        const { printer: i2 } = n2;
        i2.preprocess && (e2 = i2.preprocess(e2, n2));
        const u2 = new Map(), o2 = new Zf(e2);
        let s2 = a2();
        return r2 > 0 && (s2 = id([rd, s2], r2, n2.tabWidth)), ud(s2), s2;
        function a2(e3, t2) {
          return e3 === void 0 || e3 === o2 ? c2(t2) : Array.isArray(e3) ? o2.call(() => c2(t2), ...e3) : o2.call(() => c2(t2), e3);
        }
        function c2(e3) {
          const r3 = o2.getValue(), i3 = r3 && typeof r3 == "object" && e3 === void 0;
          if (i3 && u2.has(r3))
            return u2.get(r3);
          const s3 = function(e4, n3, r4, i4) {
            const u3 = e4.getValue(), { printer: o3 } = n3;
            let s4, a3;
            if (o3.hasPrettierIgnore && o3.hasPrettierIgnore(e4))
              ({ doc: s4, printedComments: a3 } = function(e5, t2) {
                const { originalText: n4, [Symbol.for("comments")]: r5, locStart: i5, locEnd: u4 } = t2, o4 = i5(e5), s5 = u4(e5), a4 = new Set();
                for (const e6 of r5)
                  i5(e6) >= o4 && u4(e6) <= s5 && (e6.printed = true, a4.add(e6));
                return { doc: n4.slice(o4, s5), printedComments: a4 };
              }(u3, n3));
            else {
              if (u3)
                try {
                  s4 = nd.printSubtree(e4, r4, n3, sd);
                } catch (e5) {
                  if (t.PRETTIER_DEBUG)
                    throw e5;
                }
              s4 || (s4 = o3.print(e4, n3, r4, i4));
            }
            o3.willPrintOwnComments && o3.willPrintOwnComments(e4, n3) || (s4 = od(e4, s4, n3, a3));
            return s4;
          }(o2, n2, a2, e3);
          return i3 && u2.set(r3, s3), s3;
        }
      }
      var ad = sd;
      function cd(e2) {
        let t2 = e2.length - 1;
        for (; ; ) {
          const n2 = e2[t2];
          if (!n2 || n2.type !== "Program" && n2.type !== "File")
            break;
          t2--;
        }
        return e2.slice(0, t2 + 1);
      }
      function ld(e2, t2, n2, r2, i2 = [], u2) {
        const { locStart: o2, locEnd: s2 } = n2, a2 = o2(e2), c2 = s2(e2);
        if (!(t2 > c2 || t2 < a2 || u2 === "rangeEnd" && t2 === a2 || u2 === "rangeStart" && t2 === c2)) {
          for (const o3 of Yf.getSortedChildNodes(e2, n2)) {
            const s3 = ld(o3, t2, n2, r2, [e2, ...i2], u2);
            if (s3)
              return s3;
          }
          return !r2 || r2(e2, i2[0]) ? { node: e2, parentNodes: i2 } : void 0;
        }
      }
      const pd = new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), fd = new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
      function dd(e2, t2, n2) {
        if (!t2)
          return false;
        switch (e2.parser) {
          case "flow":
          case "babel":
          case "babel-flow":
          case "babel-ts":
          case "typescript":
          case "espree":
          case "meriyah":
          case "__babel_estree":
            return function(e3, t3) {
              return t3 !== "DeclareExportDeclaration" && e3 !== "TypeParameterDeclaration" && (e3 === "Directive" || e3 === "TypeAlias" || e3 === "TSExportAssignment" || e3.startsWith("Declare") || e3.startsWith("TSDeclare") || e3.endsWith("Statement") || e3.endsWith("Declaration"));
            }(t2.type, n2 && n2.type);
          case "json":
          case "json5":
          case "json-stringify":
            return pd.has(t2.type);
          case "graphql":
            return fd.has(t2.kind);
          case "vue":
            return t2.tag !== "root";
        }
        return false;
      }
      var hd = { calculateRange: function(e2, t2, n2) {
        let { rangeStart: r2, rangeEnd: i2, locStart: u2, locEnd: o2 } = t2;
        Ff.ok(i2 > r2);
        const s2 = e2.slice(r2, i2).search(/\S/), a2 = s2 === -1;
        if (!a2)
          for (r2 += s2; i2 > r2 && !/\S/.test(e2[i2 - 1]); --i2)
            ;
        const c2 = ld(n2, r2, t2, (e3, n3) => dd(t2, e3, n3), [], "rangeStart"), l2 = a2 ? c2 : ld(n2, i2, t2, (e3) => dd(t2, e3), [], "rangeEnd");
        if (!c2 || !l2)
          return { rangeStart: 0, rangeEnd: 0 };
        let p2, f2;
        if ((({ parser: e3 }) => e3 === "json" || e3 === "json5" || e3 === "json-stringify")(t2)) {
          const e3 = function(e4, t3) {
            const n3 = [e4.node, ...e4.parentNodes], r3 = new Set([t3.node, ...t3.parentNodes]);
            return n3.find((e5) => pd.has(e5.type) && r3.has(e5));
          }(c2, l2);
          p2 = e3, f2 = e3;
        } else
          ({ startNode: p2, endNode: f2 } = function(e3, t3, { locStart: n3, locEnd: r3 }) {
            let i3 = e3.node, u3 = t3.node;
            if (i3 === u3)
              return { startNode: i3, endNode: u3 };
            const o3 = n3(e3.node);
            for (const e4 of cd(t3.parentNodes)) {
              if (!(n3(e4) >= o3))
                break;
              u3 = e4;
            }
            const s3 = r3(t3.node);
            for (const t4 of cd(e3.parentNodes)) {
              if (!(r3(t4) <= s3))
                break;
              i3 = t4;
            }
            return { startNode: i3, endNode: u3 };
          }(c2, l2, t2));
        return { rangeStart: Math.min(u2(p2), u2(f2)), rangeEnd: Math.max(o2(p2), o2(f2)) };
      }, findNodeAtOffset: ld };
      const { printer: { printDocToString: gd }, debug: { printDocToDebug: md } } = su, { getAlignmentSize: yd } = Fi, { guessEndOfLine: Dd, convertEndOfLineToChars: Ed, countEndOfLineChars: Cd, normalizeEndOfLine: bd } = xi, Ad = Fp.normalize, vd = Symbol("cursor");
      function Fd(e2, t2, n2) {
        const r2 = t2.comments;
        return r2 && (delete t2.comments, Yf.attach(r2, t2, e2, n2)), n2[Symbol.for("comments")] = r2 || [], n2[Symbol.for("tokens")] = t2.tokens || [], n2.originalText = e2, r2;
      }
      function xd(e2, t2, n2 = 0) {
        if (!e2 || e2.trim().length === 0)
          return { formatted: "", cursorOffset: -1, comments: [] };
        const { ast: r2, text: i2 } = Dp.parse(e2, t2);
        if (t2.cursorOffset >= 0) {
          const e3 = hd.findNodeAtOffset(r2, t2.cursorOffset, t2);
          e3 && e3.node && (t2.cursorNode = e3.node);
        }
        const u2 = Fd(i2, r2, t2), o2 = ad(r2, t2, n2), s2 = gd(o2, t2);
        if (Yf.ensureAllCommentsPrinted(u2), n2 > 0) {
          const e3 = s2.formatted.trim();
          s2.cursorNodeStart !== void 0 && (s2.cursorNodeStart -= s2.formatted.indexOf(e3)), s2.formatted = e3 + Ed(t2.endOfLine);
        }
        if (t2.cursorOffset >= 0) {
          let e3, n3, r3, o3, a2;
          if (t2.cursorNode && s2.cursorNodeText ? (e3 = t2.locStart(t2.cursorNode), n3 = i2.slice(e3, t2.locEnd(t2.cursorNode)), r3 = t2.cursorOffset - e3, o3 = s2.cursorNodeStart, a2 = s2.cursorNodeText) : (e3 = 0, n3 = i2, r3 = t2.cursorOffset, o3 = 0, a2 = s2.formatted), n3 === a2)
            return { formatted: s2.formatted, cursorOffset: o3 + r3, comments: u2 };
          const c2 = [...n3];
          c2.splice(r3, 0, vd);
          const l2 = [...a2], p2 = Dn.diffArrays(c2, l2);
          let f2 = o3;
          for (const e4 of p2)
            if (e4.removed) {
              if (e4.value.includes(vd))
                break;
            } else
              f2 += e4.count;
          return { formatted: s2.formatted, cursorOffset: f2, comments: u2 };
        }
        return { formatted: s2.formatted, cursorOffset: -1, comments: u2 };
      }
      function Sd(e2, t2, n2) {
        return typeof t2 != "number" || Number.isNaN(t2) || t2 < 0 || t2 > e2.length ? n2 : t2;
      }
      function wd(e2, t2) {
        let { cursorOffset: n2, rangeStart: r2, rangeEnd: i2 } = t2;
        return n2 = Sd(e2, n2, -1), r2 = Sd(e2, r2, 0), i2 = Sd(e2, i2, e2.length), Object.assign(Object.assign({}, t2), {}, { cursorOffset: n2, rangeStart: r2, rangeEnd: i2 });
      }
      function Td(e2, t2) {
        let { cursorOffset: n2, rangeStart: r2, rangeEnd: i2, endOfLine: u2 } = wd(e2, t2);
        const o2 = e2.charAt(0) === "\uFEFF";
        if (o2 && (e2 = e2.slice(1), n2--, r2--, i2--), u2 === "auto" && (u2 = Dd(e2)), e2.includes("\r")) {
          const t3 = (t4) => Cd(e2.slice(0, Math.max(t4, 0)), "\r\n");
          n2 -= t3(n2), r2 -= t3(r2), i2 -= t3(i2), e2 = bd(e2);
        }
        return { hasBOM: o2, text: e2, options: wd(e2, Object.assign(Object.assign({}, t2), {}, { cursorOffset: n2, rangeStart: r2, rangeEnd: i2, endOfLine: u2 })) };
      }
      function Bd(e2, t2) {
        const n2 = Dp.resolveParser(t2);
        return !n2.hasPragma || n2.hasPragma(e2);
      }
      function Nd(e2, t2) {
        let n2, { hasBOM: r2, text: i2, options: u2 } = Td(e2, Ad(t2));
        return u2.rangeStart >= u2.rangeEnd && i2 !== "" || u2.requirePragma && !Bd(i2, u2) ? { formatted: e2, cursorOffset: t2.cursorOffset, comments: [] } : (u2.rangeStart > 0 || u2.rangeEnd < i2.length ? n2 = function(e3, t3) {
          const { ast: n3, text: r3 } = Dp.parse(e3, t3), { rangeStart: i3, rangeEnd: u3 } = hd.calculateRange(r3, t3, n3), o2 = r3.slice(i3, u3), s2 = Math.min(i3, r3.lastIndexOf("\n", i3) + 1), a2 = r3.slice(s2, i3).match(/^\s*/)[0], c2 = yd(a2, t3.tabWidth), l2 = xd(o2, Object.assign(Object.assign({}, t3), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t3.cursorOffset > i3 && t3.cursorOffset <= u3 ? t3.cursorOffset - i3 : -1, endOfLine: "lf" }), c2), p2 = l2.formatted.trimEnd();
          let { cursorOffset: f2 } = t3;
          f2 > u3 ? f2 += p2.length - o2.length : l2.cursorOffset >= 0 && (f2 = l2.cursorOffset + i3);
          let d2 = r3.slice(0, i3) + p2 + r3.slice(u3);
          if (t3.endOfLine !== "lf") {
            const e4 = Ed(t3.endOfLine);
            f2 >= 0 && e4 === "\r\n" && (f2 += Cd(d2.slice(0, f2), "\n")), d2 = d2.replace(/\n/g, e4);
          }
          return { formatted: d2, cursorOffset: f2, comments: l2.comments };
        }(i2, u2) : (!u2.requirePragma && u2.insertPragma && u2.printer.insertPragma && !Bd(i2, u2) && (i2 = u2.printer.insertPragma(i2)), n2 = xd(i2, u2)), r2 && (n2.formatted = "\uFEFF" + n2.formatted, n2.cursorOffset >= 0 && n2.cursorOffset++), n2);
      }
      var kd = { formatWithCursor: Nd, parse(e2, t2, n2) {
        const { text: r2, options: i2 } = Td(e2, Ad(t2)), u2 = Dp.parse(r2, i2);
        return n2 && (u2.ast = xp(u2.ast, i2)), u2;
      }, formatAST(e2, t2) {
        t2 = Ad(t2);
        const n2 = ad(e2, t2);
        return gd(n2, t2);
      }, formatDoc: (e2, t2) => Nd(md(e2), Object.assign(Object.assign({}, t2), {}, { parser: "__js_expression" })).formatted, printToDoc(e2, t2) {
        t2 = Ad(t2);
        const { ast: n2, text: r2 } = Dp.parse(e2, t2);
        return Fd(r2, n2, t2), ad(n2, t2);
      }, printDocToString: (e2, t2) => gd(e2, Ad(t2)) };
      const { getMaxContinuousCount: Pd, getStringWidth: Od, getAlignmentSize: Id, getIndentSize: Ld, skip: jd, skipWhitespace: _d, skipSpaces: Md, skipNewline: Rd, skipToLineEnd: $d, skipEverythingButNewLine: Vd, skipInlineComment: Wd, skipTrailingComment: qd, hasNewline: Ud, hasNewlineInRange: zd, hasSpaces: Gd, isNextLineEmpty: Hd, isNextLineEmptyAfterIndex: Jd, isPreviousLineEmpty: Xd, getNextNonSpaceNonCommentCharacterIndex: Yd, makeString: Kd, addLeadingComment: Qd, addDanglingComment: Zd, addTrailingComment: eh } = Fi;
      var th = { getMaxContinuousCount: Pd, getStringWidth: Od, getAlignmentSize: Id, getIndentSize: Ld, skip: jd, skipWhitespace: _d, skipSpaces: Md, skipNewline: Rd, skipToLineEnd: $d, skipEverythingButNewLine: Vd, skipInlineComment: Wd, skipTrailingComment: qd, hasNewline: Ud, hasNewlineInRange: zd, hasSpaces: Gd, isNextLineEmpty: Hd, isNextLineEmptyAfterIndex: Jd, isPreviousLineEmpty: Xd, getNextNonSpaceNonCommentCharacterIndex: Yd, makeString: Kd, addLeadingComment: Qd, addDanglingComment: Zd, addTrailingComment: eh };
      const nh = ["languageId"];
      var rh = function(e2, t2) {
        const { languageId: n2 } = e2, r2 = Mn(e2, nh);
        return Object.assign(Object.assign({ linguistLanguageId: n2 }, r2), t2(e2));
      }, ih = r(function(e2) {
        !function() {
          function t2(e3) {
            if (e3 == null)
              return false;
            switch (e3.type) {
              case "BlockStatement":
              case "BreakStatement":
              case "ContinueStatement":
              case "DebuggerStatement":
              case "DoWhileStatement":
              case "EmptyStatement":
              case "ExpressionStatement":
              case "ForInStatement":
              case "ForStatement":
              case "IfStatement":
              case "LabeledStatement":
              case "ReturnStatement":
              case "SwitchStatement":
              case "ThrowStatement":
              case "TryStatement":
              case "VariableDeclaration":
              case "WhileStatement":
              case "WithStatement":
                return true;
            }
            return false;
          }
          function n2(e3) {
            switch (e3.type) {
              case "IfStatement":
                return e3.alternate != null ? e3.alternate : e3.consequent;
              case "LabeledStatement":
              case "ForStatement":
              case "ForInStatement":
              case "WhileStatement":
              case "WithStatement":
                return e3.body;
            }
            return null;
          }
          e2.exports = { isExpression: function(e3) {
            if (e3 == null)
              return false;
            switch (e3.type) {
              case "ArrayExpression":
              case "AssignmentExpression":
              case "BinaryExpression":
              case "CallExpression":
              case "ConditionalExpression":
              case "FunctionExpression":
              case "Identifier":
              case "Literal":
              case "LogicalExpression":
              case "MemberExpression":
              case "NewExpression":
              case "ObjectExpression":
              case "SequenceExpression":
              case "ThisExpression":
              case "UnaryExpression":
              case "UpdateExpression":
                return true;
            }
            return false;
          }, isStatement: t2, isIterationStatement: function(e3) {
            if (e3 == null)
              return false;
            switch (e3.type) {
              case "DoWhileStatement":
              case "ForInStatement":
              case "ForStatement":
              case "WhileStatement":
                return true;
            }
            return false;
          }, isSourceElement: function(e3) {
            return t2(e3) || e3 != null && e3.type === "FunctionDeclaration";
          }, isProblematicIfStatement: function(e3) {
            var t3;
            if (e3.type !== "IfStatement")
              return false;
            if (e3.alternate == null)
              return false;
            t3 = e3.consequent;
            do {
              if (t3.type === "IfStatement" && t3.alternate == null)
                return true;
              t3 = n2(t3);
            } while (t3);
            return false;
          }, trailingStatement: n2 };
        }();
      }), uh = r(function(e2) {
        !function() {
          var t2, n2, r2, i2, u2, o2;
          function s2(e3) {
            return e3 <= 65535 ? String.fromCharCode(e3) : String.fromCharCode(Math.floor((e3 - 65536) / 1024) + 55296) + String.fromCharCode((e3 - 65536) % 1024 + 56320);
          }
          for (n2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, r2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], i2 = new Array(128), o2 = 0; o2 < 128; ++o2)
            i2[o2] = o2 >= 97 && o2 <= 122 || o2 >= 65 && o2 <= 90 || o2 === 36 || o2 === 95;
          for (u2 = new Array(128), o2 = 0; o2 < 128; ++o2)
            u2[o2] = o2 >= 97 && o2 <= 122 || o2 >= 65 && o2 <= 90 || o2 >= 48 && o2 <= 57 || o2 === 36 || o2 === 95;
          e2.exports = { isDecimalDigit: function(e3) {
            return 48 <= e3 && e3 <= 57;
          }, isHexDigit: function(e3) {
            return 48 <= e3 && e3 <= 57 || 97 <= e3 && e3 <= 102 || 65 <= e3 && e3 <= 70;
          }, isOctalDigit: function(e3) {
            return e3 >= 48 && e3 <= 55;
          }, isWhiteSpace: function(e3) {
            return e3 === 32 || e3 === 9 || e3 === 11 || e3 === 12 || e3 === 160 || e3 >= 5760 && r2.indexOf(e3) >= 0;
          }, isLineTerminator: function(e3) {
            return e3 === 10 || e3 === 13 || e3 === 8232 || e3 === 8233;
          }, isIdentifierStartES5: function(e3) {
            return e3 < 128 ? i2[e3] : n2.NonAsciiIdentifierStart.test(s2(e3));
          }, isIdentifierPartES5: function(e3) {
            return e3 < 128 ? u2[e3] : n2.NonAsciiIdentifierPart.test(s2(e3));
          }, isIdentifierStartES6: function(e3) {
            return e3 < 128 ? i2[e3] : t2.NonAsciiIdentifierStart.test(s2(e3));
          }, isIdentifierPartES6: function(e3) {
            return e3 < 128 ? u2[e3] : t2.NonAsciiIdentifierPart.test(s2(e3));
          } };
        }();
      }), oh = r(function(e2) {
        !function() {
          var t2 = uh;
          function n2(e3, t3) {
            return !(!t3 && e3 === "yield") && r2(e3, t3);
          }
          function r2(e3, t3) {
            if (t3 && function(e4) {
              switch (e4) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }(e3))
              return true;
            switch (e3.length) {
              case 2:
                return e3 === "if" || e3 === "in" || e3 === "do";
              case 3:
                return e3 === "var" || e3 === "for" || e3 === "new" || e3 === "try";
              case 4:
                return e3 === "this" || e3 === "else" || e3 === "case" || e3 === "void" || e3 === "with" || e3 === "enum";
              case 5:
                return e3 === "while" || e3 === "break" || e3 === "catch" || e3 === "throw" || e3 === "const" || e3 === "yield" || e3 === "class" || e3 === "super";
              case 6:
                return e3 === "return" || e3 === "typeof" || e3 === "delete" || e3 === "switch" || e3 === "export" || e3 === "import";
              case 7:
                return e3 === "default" || e3 === "finally" || e3 === "extends";
              case 8:
                return e3 === "function" || e3 === "continue" || e3 === "debugger";
              case 10:
                return e3 === "instanceof";
              default:
                return false;
            }
          }
          function i2(e3, t3) {
            return e3 === "null" || e3 === "true" || e3 === "false" || n2(e3, t3);
          }
          function u2(e3, t3) {
            return e3 === "null" || e3 === "true" || e3 === "false" || r2(e3, t3);
          }
          function o2(e3) {
            var n3, r3, i3;
            if (e3.length === 0)
              return false;
            if (i3 = e3.charCodeAt(0), !t2.isIdentifierStartES5(i3))
              return false;
            for (n3 = 1, r3 = e3.length; n3 < r3; ++n3)
              if (i3 = e3.charCodeAt(n3), !t2.isIdentifierPartES5(i3))
                return false;
            return true;
          }
          function s2(e3) {
            var n3, r3, i3, u3, o3;
            if (e3.length === 0)
              return false;
            for (o3 = t2.isIdentifierStartES6, n3 = 0, r3 = e3.length; n3 < r3; ++n3) {
              if (55296 <= (i3 = e3.charCodeAt(n3)) && i3 <= 56319) {
                if (++n3 >= r3)
                  return false;
                if (!(56320 <= (u3 = e3.charCodeAt(n3)) && u3 <= 57343))
                  return false;
                i3 = 1024 * (i3 - 55296) + (u3 - 56320) + 65536;
              }
              if (!o3(i3))
                return false;
              o3 = t2.isIdentifierPartES6;
            }
            return true;
          }
          e2.exports = { isKeywordES5: n2, isKeywordES6: r2, isReservedWordES5: i2, isReservedWordES6: u2, isRestrictedWord: function(e3) {
            return e3 === "eval" || e3 === "arguments";
          }, isIdentifierNameES5: o2, isIdentifierNameES6: s2, isIdentifierES5: function(e3, t3) {
            return o2(e3) && !i2(e3, t3);
          }, isIdentifierES6: function(e3, t3) {
            return s2(e3) && !u2(e3, t3);
          } };
        }();
      });
      const sh = r(function(e2, t2) {
        t2.ast = ih, t2.code = uh, t2.keyword = oh;
      }).keyword.isIdentifierNameES5, { getLast: ah, hasNewline: ch, skipWhitespace: lh, isNonEmptyArray: ph, isNextLineEmptyAfterIndex: fh, getStringWidth: dh } = Fi, { locStart: hh, locEnd: gh, hasSameLocStart: mh } = Zc, yh = new RegExp("^(?:(?=.)\\s)*:"), Dh = new RegExp("^(?:(?=.)\\s)*::");
      function Eh(e2) {
        return e2.type === "Block" || e2.type === "CommentBlock" || e2.type === "MultiLine";
      }
      function Ch(e2) {
        return e2.type === "Line" || e2.type === "CommentLine" || e2.type === "SingleLine" || e2.type === "HashbangComment" || e2.type === "HTMLOpen" || e2.type === "HTMLClose";
      }
      const bh = new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
      function Ah(e2) {
        return e2 && bh.has(e2.type);
      }
      function vh(e2) {
        return e2.type === "NumericLiteral" || e2.type === "Literal" && typeof e2.value == "number";
      }
      function Fh(e2) {
        return e2.type === "StringLiteral" || e2.type === "Literal" && typeof e2.value == "string";
      }
      function xh(e2) {
        return e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression";
      }
      function Sh(e2) {
        return Oh(e2) && e2.callee.type === "Identifier" && (e2.callee.name === "async" || e2.callee.name === "inject" || e2.callee.name === "fakeAsync");
      }
      function wh(e2) {
        return e2.type === "JSXElement" || e2.type === "JSXFragment";
      }
      function Th(e2) {
        return e2.kind === "get" || e2.kind === "set";
      }
      function Bh(e2) {
        return Th(e2) || mh(e2, e2.value);
      }
      const Nh = new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
      const kh = new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
      const Ph = /^(?:skip|[fx]?(?:it|describe|test))$/;
      function Oh(e2) {
        return e2 && (e2.type === "CallExpression" || e2.type === "OptionalCallExpression");
      }
      function Ih(e2) {
        return e2 && (e2.type === "MemberExpression" || e2.type === "OptionalMemberExpression");
      }
      function Lh(e2) {
        return /^(?:\d+|\d+\.\d+)$/.test(e2);
      }
      function jh(e2) {
        return e2.quasis.some((e3) => e3.value.raw.includes("\n"));
      }
      function _h(e2) {
        return e2.extra ? e2.extra.raw : e2.raw;
      }
      const Mh = { "==": true, "!=": true, "===": true, "!==": true }, Rh = { "*": true, "/": true, "%": true }, $h = { ">>": true, ">>>": true, "<<": true };
      const Vh = {};
      for (const [e2, t2] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
        for (const n2 of t2)
          Vh[n2] = e2;
      function Wh(e2) {
        return Vh[e2];
      }
      const qh = new WeakMap();
      function Uh(e2) {
        if (qh.has(e2))
          return qh.get(e2);
        const t2 = [];
        return e2.this && t2.push(e2.this), Array.isArray(e2.parameters) ? t2.push(...e2.parameters) : Array.isArray(e2.params) && t2.push(...e2.params), e2.rest && t2.push(e2.rest), qh.set(e2, t2), t2;
      }
      const zh = new WeakMap();
      function Gh(e2) {
        if (zh.has(e2))
          return zh.get(e2);
        let t2 = e2.arguments;
        return e2.type === "ImportExpression" && (t2 = [e2.source], e2.attributes && t2.push(e2.attributes)), zh.set(e2, t2), t2;
      }
      function Hh(e2) {
        return e2.value.trim() === "prettier-ignore" && !e2.unignore;
      }
      function Jh(e2) {
        return e2 && (e2.prettierIgnore || Kh(e2, Xh.PrettierIgnore));
      }
      const Xh = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 }, Yh = (e2, t2) => {
        if (typeof e2 == "function" && (t2 = e2, e2 = 0), e2 || t2)
          return (n2, r2, i2) => !(e2 & Xh.Leading && !n2.leading || e2 & Xh.Trailing && !n2.trailing || e2 & Xh.Dangling && (n2.leading || n2.trailing) || e2 & Xh.Block && !Eh(n2) || e2 & Xh.Line && !Ch(n2) || e2 & Xh.First && r2 !== 0 || e2 & Xh.Last && r2 !== i2.length - 1 || e2 & Xh.PrettierIgnore && !Hh(n2) || t2 && !t2(n2));
      };
      function Kh(e2, t2, n2) {
        if (!e2 || !ph(e2.comments))
          return false;
        const r2 = Yh(t2, n2);
        return !r2 || e2.comments.some(r2);
      }
      function Qh(e2, t2, n2) {
        if (!e2 || !Array.isArray(e2.comments))
          return [];
        const r2 = Yh(t2, n2);
        return r2 ? e2.comments.filter(r2) : e2.comments;
      }
      function Zh(e2) {
        return Oh(e2) || e2.type === "NewExpression" || e2.type === "ImportExpression";
      }
      var eg = { getFunctionParameters: Uh, iterateFunctionParametersPath: function(e2, t2) {
        const n2 = e2.getValue();
        let r2 = 0;
        const i2 = (e3) => t2(e3, r2++);
        n2.this && e2.call(i2, "this"), Array.isArray(n2.parameters) ? e2.each(i2, "parameters") : Array.isArray(n2.params) && e2.each(i2, "params"), n2.rest && e2.call(i2, "rest");
      }, getCallArguments: Gh, iterateCallArgumentsPath: function(e2, t2) {
        const n2 = e2.getValue();
        n2.type === "ImportExpression" ? (e2.call((e3) => t2(e3, 0), "source"), n2.attributes && e2.call((e3) => t2(e3, 1), "attributes")) : e2.each(t2, "arguments");
      }, hasRestParameter: function(e2) {
        if (e2.rest)
          return true;
        const t2 = Uh(e2);
        return t2.length > 0 && ah(t2).type === "RestElement";
      }, getLeftSide: function(e2) {
        return e2.expressions ? e2.expressions[0] : e2.left || e2.test || e2.callee || e2.object || e2.tag || e2.argument || e2.expression;
      }, getLeftSidePathName: function(e2, t2) {
        if (t2.expressions)
          return ["expressions", 0];
        if (t2.left)
          return ["left"];
        if (t2.test)
          return ["test"];
        if (t2.object)
          return ["object"];
        if (t2.callee)
          return ["callee"];
        if (t2.tag)
          return ["tag"];
        if (t2.argument)
          return ["argument"];
        if (t2.expression)
          return ["expression"];
        throw new Error("Unexpected node has no left side.");
      }, getParentExportDeclaration: function(e2) {
        const t2 = e2.getParentNode();
        return e2.getName() === "declaration" && Ah(t2) ? t2 : null;
      }, getTypeScriptMappedTypeModifier: function(e2, t2) {
        return e2 === "+" ? "+" + t2 : e2 === "-" ? "-" + t2 : t2;
      }, hasFlowAnnotationComment: function(e2) {
        return ph(e2) && Eh(e2[0]) && Dh.test(e2[0].value);
      }, hasFlowShorthandAnnotationComment: function(e2) {
        return e2.extra && e2.extra.parenthesized && ph(e2.trailingComments) && Eh(e2.trailingComments[0]) && yh.test(e2.trailingComments[0].value);
      }, hasLeadingOwnLineComment: function(e2, t2) {
        return wh(t2) ? Jh(t2) : Kh(t2, Xh.Leading, (t3) => ch(e2, gh(t3)));
      }, hasNakedLeftSide: function(e2) {
        return e2.type === "AssignmentExpression" || e2.type === "BinaryExpression" || e2.type === "LogicalExpression" || e2.type === "NGPipeExpression" || e2.type === "ConditionalExpression" || Oh(e2) || Ih(e2) || e2.type === "SequenceExpression" || e2.type === "TaggedTemplateExpression" || e2.type === "BindExpression" || e2.type === "UpdateExpression" && !e2.prefix || e2.type === "TSAsExpression" || e2.type === "TSNonNullExpression";
      }, hasNode: function e2(t2, n2) {
        if (!t2 || typeof t2 != "object")
          return false;
        if (Array.isArray(t2))
          return t2.some((t3) => e2(t3, n2));
        const r2 = n2(t2);
        return typeof r2 == "boolean" ? r2 : Object.values(t2).some((t3) => e2(t3, n2));
      }, hasIgnoreComment: function(e2) {
        return Jh(e2.getValue());
      }, hasNodeIgnoreComment: Jh, identity: function(e2) {
        return e2;
      }, isBinaryish: function(e2) {
        return Nh.has(e2.type);
      }, isBlockComment: Eh, isCallLikeExpression: Zh, isLineComment: Ch, isPrettierIgnoreComment: Hh, isCallExpression: Oh, isMemberExpression: Ih, isExportDeclaration: Ah, isFlowAnnotationComment: function(e2, t2) {
        const n2 = hh(t2), r2 = lh(e2, gh(t2));
        return r2 !== false && e2.slice(n2, n2 + 2) === "/*" && e2.slice(r2, r2 + 2) === "*/";
      }, isFunctionCompositionArgs: function(e2) {
        if (e2.length <= 1)
          return false;
        let t2 = 0;
        for (const n2 of e2)
          if (xh(n2)) {
            if (t2 += 1, t2 > 1)
              return true;
          } else if (Oh(n2)) {
            for (const e3 of n2.arguments)
              if (xh(e3))
                return true;
          }
        return false;
      }, isFunctionNotation: Bh, isFunctionOrArrowExpression: xh, isGetterOrSetter: Th, isJestEachTemplateLiteral: function(e2, t2) {
        const n2 = /^[fx]?(?:describe|it|test)$/;
        return t2.type === "TaggedTemplateExpression" && t2.quasi === e2 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && n2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && n2.test(t2.tag.object.object.name));
      }, isJsxNode: wh, isLiteral: function(e2) {
        return e2.type === "BooleanLiteral" || e2.type === "DirectiveLiteral" || e2.type === "Literal" || e2.type === "NullLiteral" || e2.type === "NumericLiteral" || e2.type === "BigIntLiteral" || e2.type === "DecimalLiteral" || e2.type === "RegExpLiteral" || e2.type === "StringLiteral" || e2.type === "TemplateLiteral" || e2.type === "TSTypeLiteral" || e2.type === "JSXText";
      }, isLongCurriedCallExpression: function(e2) {
        const t2 = e2.getValue(), n2 = e2.getParentNode();
        return Oh(t2) && Oh(n2) && n2.callee === t2 && t2.arguments.length > n2.arguments.length && n2.arguments.length > 0;
      }, isSimpleCallArgument: function e2(t2, n2) {
        if (n2 >= 2)
          return false;
        const r2 = (t3) => e2(t3, n2 + 1), i2 = t2.type === "Literal" && "regex" in t2 && t2.regex.pattern || t2.type === "RegExpLiteral" && t2.pattern;
        return !(i2 && dh(i2) > 5) && (t2.type === "Literal" || t2.type === "BigIntLiteral" || t2.type === "DecimalLiteral" || t2.type === "BooleanLiteral" || t2.type === "NullLiteral" || t2.type === "NumericLiteral" || t2.type === "RegExpLiteral" || t2.type === "StringLiteral" || t2.type === "Identifier" || t2.type === "ThisExpression" || t2.type === "Super" || t2.type === "PrivateName" || t2.type === "PrivateIdentifier" || t2.type === "ArgumentPlaceholder" || t2.type === "Import" || (t2.type === "TemplateLiteral" ? t2.quasis.every((e3) => !e3.value.raw.includes("\n")) && t2.expressions.every(r2) : t2.type === "ObjectExpression" ? t2.properties.every((e3) => !e3.computed && (e3.shorthand || e3.value && r2(e3.value))) : t2.type === "ArrayExpression" ? t2.elements.every((e3) => e3 === null || r2(e3)) : Zh(t2) ? (t2.type === "ImportExpression" || e2(t2.callee, n2)) && Gh(t2).every(r2) : Ih(t2) ? e2(t2.object, n2) && e2(t2.property, n2) : t2.type !== "UnaryExpression" || t2.operator !== "!" && t2.operator !== "-" ? t2.type === "TSNonNullExpression" && e2(t2.expression, n2) : e2(t2.argument, n2)));
      }, isMemberish: function(e2) {
        return Ih(e2) || e2.type === "BindExpression" && Boolean(e2.object);
      }, isNumericLiteral: vh, isSignedNumericLiteral: function(e2) {
        return e2.type === "UnaryExpression" && (e2.operator === "+" || e2.operator === "-") && vh(e2.argument);
      }, isObjectProperty: function(e2) {
        return e2 && (e2.type === "ObjectProperty" || e2.type === "Property" && !e2.method && e2.kind === "init");
      }, isObjectType: function(e2) {
        return e2.type === "ObjectTypeAnnotation" || e2.type === "TSTypeLiteral" || e2.type === "TSMappedType";
      }, isObjectTypePropertyAFunction: function(e2) {
        return !(e2.type !== "ObjectTypeProperty" && e2.type !== "ObjectTypeInternalSlot" || e2.value.type !== "FunctionTypeAnnotation" || e2.static || Bh(e2));
      }, isSimpleType: function(e2) {
        return !!e2 && (!(e2.type !== "GenericTypeAnnotation" && e2.type !== "TSTypeReference" || e2.typeParameters) || !!kh.has(e2.type));
      }, isSimpleNumber: Lh, isSimpleTemplateLiteral: function(e2) {
        let t2 = "expressions";
        e2.type === "TSTemplateLiteralType" && (t2 = "types");
        const n2 = e2[t2];
        return n2.length !== 0 && n2.every((e3) => {
          if (Kh(e3))
            return false;
          if (e3.type === "Identifier" || e3.type === "ThisExpression")
            return true;
          if (Ih(e3)) {
            let t3 = e3;
            for (; Ih(t3); ) {
              if (t3.property.type !== "Identifier" && t3.property.type !== "Literal" && t3.property.type !== "StringLiteral" && t3.property.type !== "NumericLiteral")
                return false;
              if (t3 = t3.object, Kh(t3))
                return false;
            }
            return t3.type === "Identifier" || t3.type === "ThisExpression";
          }
          return false;
        });
      }, isStringLiteral: Fh, isStringPropSafeToUnquote: function(e2, t2) {
        return t2.parser !== "json" && Fh(e2.key) && _h(e2.key).slice(1, -1) === e2.key.value && (sh(e2.key.value) && !((t2.parser === "typescript" || t2.parser === "babel-ts") && e2.type === "ClassProperty") || Lh(e2.key.value) && String(Number(e2.key.value)) === e2.key.value && (t2.parser === "babel" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree"));
      }, isTemplateOnItsOwnLine: function(e2, t2) {
        return (e2.type === "TemplateLiteral" && jh(e2) || e2.type === "TaggedTemplateExpression" && jh(e2.quasi)) && !ch(t2, hh(e2), { backwards: true });
      }, isTestCall: function e2(t2, n2) {
        if (t2.type !== "CallExpression")
          return false;
        if (t2.arguments.length === 1) {
          if (Sh(t2) && n2 && e2(n2))
            return xh(t2.arguments[0]);
          if (function(e3) {
            return e3.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(e3.callee.name) && e3.arguments.length === 1;
          }(t2))
            return Sh(t2.arguments[0]);
        } else if ((t2.arguments.length === 2 || t2.arguments.length === 3) && (t2.callee.type === "Identifier" && Ph.test(t2.callee.name) || function(e3) {
          return Ih(e3.callee) && e3.callee.object.type === "Identifier" && e3.callee.property.type === "Identifier" && Ph.test(e3.callee.object.name) && (e3.callee.property.name === "only" || e3.callee.property.name === "skip");
        }(t2)) && (function(e3) {
          return e3.type === "TemplateLiteral";
        }(t2.arguments[0]) || Fh(t2.arguments[0])))
          return !(t2.arguments[2] && !vh(t2.arguments[2])) && ((t2.arguments.length === 2 ? xh(t2.arguments[1]) : function(e3) {
            return e3.type === "FunctionExpression" || e3.type === "ArrowFunctionExpression" && e3.body.type === "BlockStatement";
          }(t2.arguments[1]) && Uh(t2.arguments[1]).length <= 1) || Sh(t2.arguments[1]));
        return false;
      }, isTheOnlyJsxElementInMarkdown: function(e2, t2) {
        if (e2.parentParser !== "markdown" && e2.parentParser !== "mdx")
          return false;
        const n2 = t2.getNode();
        if (!n2.expression || !wh(n2.expression))
          return false;
        const r2 = t2.getParentNode();
        return r2.type === "Program" && r2.body.length === 1;
      }, isTSXFile: function(e2) {
        return e2.filepath && /\.tsx$/i.test(e2.filepath);
      }, isTypeAnnotationAFunction: function(e2) {
        return !(e2.type !== "TypeAnnotation" && e2.type !== "TSTypeAnnotation" || e2.typeAnnotation.type !== "FunctionTypeAnnotation" || e2.static || mh(e2, e2.typeAnnotation));
      }, isNextLineEmpty: (e2, { originalText: t2 }) => fh(t2, gh(e2)), needsHardlineAfterDanglingComment: function(e2) {
        if (!Kh(e2))
          return false;
        const t2 = ah(Qh(e2, Xh.Dangling));
        return t2 && !Eh(t2);
      }, rawText: _h, shouldPrintComma: function(e2, t2 = "es5") {
        return e2.trailingComma === "es5" && t2 === "es5" || e2.trailingComma === "all" && (t2 === "all" || t2 === "es5");
      }, isBitwiseOperator: function(e2) {
        return Boolean($h[e2]) || e2 === "|" || e2 === "^" || e2 === "&";
      }, shouldFlatten: function(e2, t2) {
        return Wh(t2) === Wh(e2) && (e2 !== "**" && ((!Mh[e2] || !Mh[t2]) && (!(t2 === "%" && Rh[e2] || e2 === "%" && Rh[t2]) && ((t2 === e2 || !Rh[t2] || !Rh[e2]) && (!$h[e2] || !$h[t2])))));
      }, startsWithNoLookaheadToken: function e2(t2, n2) {
        switch ((t2 = function(e3) {
          for (; e3.left; )
            e3 = e3.left;
          return e3;
        }(t2)).type) {
          case "FunctionExpression":
          case "ClassExpression":
          case "DoExpression":
            return n2;
          case "ObjectExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return e2(t2.object, n2);
          case "TaggedTemplateExpression":
            return t2.tag.type !== "FunctionExpression" && e2(t2.tag, n2);
          case "CallExpression":
          case "OptionalCallExpression":
            return t2.callee.type !== "FunctionExpression" && e2(t2.callee, n2);
          case "ConditionalExpression":
            return e2(t2.test, n2);
          case "UpdateExpression":
            return !t2.prefix && e2(t2.argument, n2);
          case "BindExpression":
            return t2.object && e2(t2.object, n2);
          case "SequenceExpression":
            return e2(t2.expressions[0], n2);
          case "TSAsExpression":
          case "TSNonNullExpression":
            return e2(t2.expression, n2);
          default:
            return false;
        }
      }, getPrecedence: Wh, hasComment: Kh, getComments: Qh, CommentCheckFlags: Xh };
      const { getStringWidth: tg, getIndentSize: ng } = Fi, { builders: { join: rg, hardline: ig, softline: ug, group: og, indent: sg, align: ag, lineSuffixBoundary: cg, addAlignmentToDoc: lg }, printer: { printDocToString: pg }, utils: { mapDoc: fg } } = su, { isBinaryish: dg, isJestEachTemplateLiteral: hg, isSimpleTemplateLiteral: gg, hasComment: mg, isMemberExpression: yg } = eg;
      function Dg(e2) {
        return e2.replace(/([\\`]|\${)/g, "\\$1");
      }
      var Eg = { printTemplateLiteral: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (r2.type === "TemplateLiteral" && hg(r2, e2.getParentNode())) {
          const r3 = function(e3, t3, n3) {
            const r4 = e3.getNode(), i3 = r4.quasis[0].value.raw.trim().split(/\s*\|\s*/);
            if (i3.length > 1 || i3.some((e4) => e4.length > 0)) {
              t3.__inJestEach = true;
              const u3 = e3.map(n3, "expressions");
              t3.__inJestEach = false;
              const o3 = [], s3 = u3.map((e4) => "${" + pg(e4, Object.assign(Object.assign({}, t3), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), a2 = [{ hasLineBreak: false, cells: [] }];
              for (let e4 = 1; e4 < r4.quasis.length; e4++) {
                const t4 = _n(a2), n4 = s3[e4 - 1];
                t4.cells.push(n4), n4.includes("\n") && (t4.hasLineBreak = true), r4.quasis[e4].value.raw.includes("\n") && a2.push({ hasLineBreak: false, cells: [] });
              }
              const c2 = Math.max(i3.length, ...a2.map((e4) => e4.cells.length)), l2 = Array.from({ length: c2 }).fill(0), p2 = [{ cells: i3 }, ...a2.filter((e4) => e4.cells.length > 0)];
              for (const { cells: e4 } of p2.filter((e5) => !e5.hasLineBreak))
                for (const [t4, n4] of e4.entries())
                  l2[t4] = Math.max(l2[t4], tg(n4));
              return o3.push(cg, "`", sg([ig, rg(ig, p2.map((e4) => rg(" | ", e4.cells.map((t4, n4) => e4.hasLineBreak ? t4 : t4 + " ".repeat(l2[n4] - tg(t4))))))]), ig, "`"), o3;
            }
          }(e2, n2, t2);
          if (r3)
            return r3;
        }
        let i2 = "expressions";
        r2.type === "TSTemplateLiteralType" && (i2 = "types");
        const u2 = [];
        let o2 = e2.map(t2, i2);
        const s2 = gg(r2);
        return s2 && (o2 = o2.map((e3) => pg(e3, Object.assign(Object.assign({}, n2), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), u2.push(cg, "`"), e2.each((e3) => {
          const a2 = e3.getName();
          if (u2.push(t2()), a2 < o2.length) {
            const { tabWidth: t3 } = n2, c2 = e3.getValue(), l2 = ng(c2.value.raw, t3);
            let p2 = o2[a2];
            if (!s2) {
              const e4 = r2[i2][a2];
              (mg(e4) || yg(e4) || e4.type === "ConditionalExpression" || e4.type === "SequenceExpression" || e4.type === "TSAsExpression" || dg(e4)) && (p2 = [sg([ug, p2]), ug]);
            }
            const f2 = l2 === 0 && c2.value.raw.endsWith("\n") ? ag(Number.NEGATIVE_INFINITY, p2) : lg(p2, l2, t3);
            u2.push(og(["${", f2, cg, "}"]));
          }
        }, "quasis"), u2.push("`"), u2;
      }, printTemplateExpressions: function(e2, t2) {
        return e2.map((e3) => function(e4, t3) {
          const n2 = e4.getValue();
          let r2 = t3();
          return mg(n2) && (r2 = og([sg([ug, r2]), ug])), ["${", r2, cg, "}"];
        }(e3, t2), "expressions");
      }, escapeTemplateCharacters: function(e2, t2) {
        return fg(e2, (e3) => typeof e3 == "string" ? t2 ? e3.replace(/(\\*)`/g, "$1$1\\`") : Dg(e3) : e3);
      }, uncookTemplateElementValue: Dg };
      const { builders: { indent: Cg, softline: bg, literalline: Ag, dedentToRoot: vg } } = su, { escapeTemplateCharacters: Fg } = Eg;
      var xg = function(e2, t2, n2) {
        let r2 = e2.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (e3, t3) => "\\".repeat(t3.length / 2) + "`");
        const i2 = function(e3) {
          const t3 = e3.match(/^([^\S\n]*)\S/m);
          return t3 === null ? "" : t3[1];
        }(r2), u2 = i2 !== "";
        u2 && (r2 = r2.replace(new RegExp(`^${i2}`, "gm"), ""));
        const o2 = Fg(n2(r2, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
        return ["`", u2 ? Cg([bg, o2]) : [Ag, vg(o2)], bg, "`"];
      };
      const { isNonEmptyArray: Sg } = Fi, { builders: { indent: wg, hardline: Tg, softline: Bg }, utils: { mapDoc: Ng, replaceEndOfLine: kg, cleanDoc: Pg } } = su, { printTemplateExpressions: Og } = Eg;
      var Ig = function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = r2.quasis.map((e3) => e3.value.raw);
        let u2 = 0;
        return function(e3, t3, n3) {
          if (t3.quasis.length === 1 && !t3.quasis[0].value.raw.trim())
            return "``";
          const r3 = function(e4, t4) {
            if (!Sg(t4))
              return e4;
            let n4 = 0;
            const r4 = Ng(Pg(e4), (e5) => typeof e5 == "string" && e5.includes("@prettier-placeholder") ? e5.split(/@prettier-placeholder-(\d+)-id/).map((e6, r5) => r5 % 2 == 0 ? kg(e6) : (n4++, t4[e6])) : e5);
            return t4.length === n4 ? r4 : null;
          }(e3, n3);
          if (!r3)
            throw new Error("Couldn't insert all the expressions");
          return ["`", wg([Tg, r3]), Bg, "`"];
        }(n2(i2.reduce((e3, t3, n3) => n3 === 0 ? t3 : e3 + "@prettier-placeholder-" + u2++ + "-id" + t3, ""), { parser: "scss" }, { stripTrailingHardline: true }), r2, Og(e2, t2));
      };
      const { builders: { indent: Lg, join: jg, hardline: _g } } = su, { escapeTemplateCharacters: Mg, printTemplateExpressions: Rg } = Eg;
      function $g(e2) {
        const t2 = [];
        let n2 = false;
        const r2 = e2.map((e3) => e3.trim());
        for (const [e3, i2] of r2.entries())
          i2 !== "" && (r2[e3 - 1] === "" && n2 ? t2.push([_g, i2]) : t2.push(i2), n2 = true);
        return t2.length === 0 ? null : jg(_g, t2);
      }
      var Vg = function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = r2.quasis.length;
        if (i2 === 1 && r2.quasis[0].value.raw.trim() === "")
          return "``";
        const u2 = Rg(e2, t2), o2 = [];
        for (let e3 = 0; e3 < i2; e3++) {
          const t3 = e3 === 0, s2 = e3 === i2 - 1, a2 = r2.quasis[e3].value.cooked, c2 = a2.split("\n"), l2 = c2.length, p2 = u2[e3], f2 = l2 > 2 && c2[0].trim() === "" && c2[1].trim() === "", d2 = l2 > 2 && c2[l2 - 1].trim() === "" && c2[l2 - 2].trim() === "", h2 = c2.every((e4) => /^\s*(?:#[^\n\r]*)?$/.test(e4));
          if (!s2 && /#[^\n\r]*$/.test(c2[l2 - 1]))
            return null;
          let g2 = null;
          g2 = h2 ? $g(c2) : n2(a2, { parser: "graphql" }, { stripTrailingHardline: true }), g2 ? (g2 = Mg(g2, false), !t3 && f2 && o2.push(""), o2.push(g2), !s2 && d2 && o2.push("")) : t3 || s2 || !f2 || o2.push(""), p2 && o2.push(p2);
        }
        return ["`", Lg([_g, jg(_g, o2)]), _g, "`"];
      };
      const { builders: { indent: Wg, line: qg, hardline: Ug, group: zg }, utils: { mapDoc: Gg } } = su, { printTemplateExpressions: Hg, uncookTemplateElementValue: Jg } = Eg;
      let Xg = 0;
      var Yg = function(e2, t2, n2, r2, { parser: i2 }) {
        const u2 = e2.getValue(), o2 = Xg;
        Xg = Xg + 1 >>> 0;
        const s2 = (e3) => `PRETTIER_HTML_PLACEHOLDER_${e3}_${o2}_IN_JS`, a2 = u2.quasis.map((e3, t3, n3) => t3 === n3.length - 1 ? e3.value.cooked : e3.value.cooked + s2(t3)).join(""), c2 = Hg(e2, t2);
        if (c2.length === 0 && a2.trim().length === 0)
          return "``";
        const l2 = new RegExp(s2("(\\d+)"), "g");
        let p2 = 0;
        const f2 = n2(a2, { parser: i2, __onHtmlRoot(e3) {
          p2 = e3.children.length;
        } }, { stripTrailingHardline: true }), d2 = Gg(f2, (e3) => {
          if (typeof e3 != "string")
            return e3;
          const t3 = [], n3 = e3.split(l2);
          for (let e4 = 0; e4 < n3.length; e4++) {
            let i3 = n3[e4];
            if (e4 % 2 == 0) {
              i3 && (i3 = Jg(i3), r2.__embeddedInHtml && (i3 = i3.replace(/<\/(script)\b/gi, "<\\/$1")), t3.push(i3));
              continue;
            }
            const u3 = Number(i3);
            t3.push(c2[u3]);
          }
          return t3;
        }), h2 = /^\s/.test(a2) ? " " : "", g2 = /\s$/.test(a2) ? " " : "", m2 = r2.htmlWhitespaceSensitivity === "ignore" ? Ug : h2 && g2 ? qg : null;
        return zg(m2 ? ["`", Wg([m2, zg(d2)]), m2, "`"] : ["`", h2, p2 > 1 ? Wg(zg(d2)) : zg(d2), g2, "`"]);
      };
      const { hasComment: Kg, CommentCheckFlags: Qg, isObjectProperty: Zg } = eg;
      function em(e2) {
        return function(e3) {
          const t2 = e3.getValue(), n2 = e3.getParentNode(), r2 = e3.getParentNode(1);
          return r2 && t2.quasis && n2.type === "JSXExpressionContainer" && r2.type === "JSXElement" && r2.openingElement.name.name === "style" && r2.openingElement.attributes.some((e4) => e4.name.name === "jsx") || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "Identifier" && n2.tag.name === "css" || n2 && n2.type === "TaggedTemplateExpression" && n2.tag.type === "MemberExpression" && n2.tag.object.name === "css" && (n2.tag.property.name === "global" || n2.tag.property.name === "resolve");
        }(e2) || function(e3) {
          const t2 = e3.getParentNode();
          if (!t2 || t2.type !== "TaggedTemplateExpression")
            return false;
          const n2 = t2.tag.type === "ParenthesizedExpression" ? t2.tag.expression : t2.tag;
          switch (n2.type) {
            case "MemberExpression":
              return nm(n2.object) || rm(n2);
            case "CallExpression":
              return nm(n2.callee) || n2.callee.type === "MemberExpression" && (n2.callee.object.type === "MemberExpression" && (nm(n2.callee.object.object) || rm(n2.callee.object)) || n2.callee.object.type === "CallExpression" && nm(n2.callee.object.callee));
            case "Identifier":
              return n2.name === "css";
            default:
              return false;
          }
        }(e2) || function(e3) {
          const t2 = e3.getParentNode(), n2 = e3.getParentNode(1);
          return n2 && t2.type === "JSXExpressionContainer" && n2.type === "JSXAttribute" && n2.name.type === "JSXIdentifier" && n2.name.name === "css";
        }(e2) || function(e3) {
          return e3.match((e4) => e4.type === "TemplateLiteral", (e4, t2) => e4.type === "ArrayExpression" && t2 === "elements", (e4, t2) => Zg(e4) && e4.key.type === "Identifier" && e4.key.name === "styles" && t2 === "value", ...tm);
        }(e2) ? "css" : function(e3) {
          const t2 = e3.getValue(), n2 = e3.getParentNode();
          return im(t2, "GraphQL") || n2 && (n2.type === "TaggedTemplateExpression" && (n2.tag.type === "MemberExpression" && n2.tag.object.name === "graphql" && n2.tag.property.name === "experimental" || n2.tag.type === "Identifier" && (n2.tag.name === "gql" || n2.tag.name === "graphql")) || n2.type === "CallExpression" && n2.callee.type === "Identifier" && n2.callee.name === "graphql");
        }(e2) ? "graphql" : function(e3) {
          return im(e3.getValue(), "HTML") || e3.match((e4) => e4.type === "TemplateLiteral", (e4, t2) => e4.type === "TaggedTemplateExpression" && e4.tag.type === "Identifier" && e4.tag.name === "html" && t2 === "quasi");
        }(e2) ? "html" : function(e3) {
          return e3.match((e4) => e4.type === "TemplateLiteral", (e4, t2) => Zg(e4) && e4.key.type === "Identifier" && e4.key.name === "template" && t2 === "value", ...tm);
        }(e2) ? "angular" : function(e3) {
          const t2 = e3.getValue(), n2 = e3.getParentNode();
          return n2 && n2.type === "TaggedTemplateExpression" && t2.quasis.length === 1 && n2.tag.type === "Identifier" && (n2.tag.name === "md" || n2.tag.name === "markdown");
        }(e2) ? "markdown" : void 0;
      }
      const tm = [(e2, t2) => e2.type === "ObjectExpression" && t2 === "properties", (e2, t2) => e2.type === "CallExpression" && e2.callee.type === "Identifier" && e2.callee.name === "Component" && t2 === "arguments", (e2, t2) => e2.type === "Decorator" && t2 === "expression"];
      function nm(e2) {
        return e2.type === "Identifier" && e2.name === "styled";
      }
      function rm(e2) {
        return /^[A-Z]/.test(e2.object.name) && e2.property.name === "extend";
      }
      function im(e2, t2) {
        return Kg(e2, Qg.Block | Qg.Leading, ({ value: e3 }) => e3 === ` ${t2} `);
      }
      var um = function(e2, t2, n2, r2) {
        const i2 = e2.getValue();
        if (i2.type !== "TemplateLiteral" || function({ quasis: e3 }) {
          return e3.some(({ value: { cooked: e4 } }) => e4 === null);
        }(i2))
          return;
        const u2 = em(e2);
        return u2 ? u2 === "markdown" ? xg(e2, t2, n2) : u2 === "css" ? Ig(e2, t2, n2) : u2 === "graphql" ? Vg(e2, t2, n2) : u2 === "html" || u2 === "angular" ? Yg(e2, t2, n2, r2, { parser: u2 }) : void 0 : void 0;
      };
      const { isBlockComment: om } = eg, sm = new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), am = (e2) => {
        for (const t2 of e2.quasis)
          delete t2.value;
      };
      function cm(e2, t2, n2) {
        if (e2.type === "Program" && delete t2.sourceType, e2.type !== "BigIntLiteral" && e2.type !== "BigIntLiteralTypeAnnotation" || t2.value && (t2.value = t2.value.toLowerCase()), e2.type !== "BigIntLiteral" && e2.type !== "Literal" || t2.bigint && (t2.bigint = t2.bigint.toLowerCase()), e2.type === "DecimalLiteral" && (t2.value = Number(t2.value)), e2.type === "Literal" && t2.decimal && (t2.decimal = Number(t2.decimal)), e2.type === "EmptyStatement")
          return null;
        if (e2.type === "JSXText")
          return null;
        if (e2.type === "JSXExpressionContainer" && (e2.expression.type === "Literal" || e2.expression.type === "StringLiteral") && e2.expression.value === " ")
          return null;
        if (e2.type !== "Property" && e2.type !== "ObjectProperty" && e2.type !== "MethodDefinition" && e2.type !== "ClassProperty" && e2.type !== "ClassMethod" && e2.type !== "PropertyDefinition" && e2.type !== "TSDeclareMethod" && e2.type !== "TSPropertySignature" && e2.type !== "ObjectTypeProperty" || typeof e2.key != "object" || !e2.key || e2.key.type !== "Literal" && e2.key.type !== "NumericLiteral" && e2.key.type !== "StringLiteral" && e2.key.type !== "Identifier" || delete t2.key, e2.type === "JSXElement" && e2.openingElement.name.name === "style" && e2.openingElement.attributes.some((e3) => e3.name.name === "jsx"))
          for (const { type: e3, expression: n3 } of t2.children)
            e3 === "JSXExpressionContainer" && n3.type === "TemplateLiteral" && am(n3);
        e2.type === "JSXAttribute" && e2.name.name === "css" && e2.value.type === "JSXExpressionContainer" && e2.value.expression.type === "TemplateLiteral" && am(t2.value.expression), e2.type === "JSXAttribute" && e2.value && e2.value.type === "Literal" && /["']|&quot;|&apos;/.test(e2.value.value) && (t2.value.value = t2.value.value.replace(/["']|&quot;|&apos;/g, '"'));
        const r2 = e2.expression || e2.callee;
        if (e2.type === "Decorator" && r2.type === "CallExpression" && r2.callee.name === "Component" && r2.arguments.length === 1) {
          const n3 = e2.expression.arguments[0].properties;
          for (const [e3, r3] of t2.expression.arguments[0].properties.entries())
            switch (n3[e3].key.name) {
              case "styles":
                r3.value.type === "ArrayExpression" && am(r3.value.elements[0]);
                break;
              case "template":
                r3.value.type === "TemplateLiteral" && am(r3.value);
            }
        }
        if (e2.type !== "TaggedTemplateExpression" || e2.tag.type !== "MemberExpression" && (e2.tag.type !== "Identifier" || e2.tag.name !== "gql" && e2.tag.name !== "graphql" && e2.tag.name !== "css" && e2.tag.name !== "md" && e2.tag.name !== "markdown" && e2.tag.name !== "html") && e2.tag.type !== "CallExpression" || am(t2.quasi), e2.type === "TemplateLiteral") {
          (e2.leadingComments && e2.leadingComments.some((e3) => om(e3) && ["GraphQL", "HTML"].some((t3) => e3.value === ` ${t3} `)) || n2.type === "CallExpression" && n2.callee.name === "graphql" || !e2.leadingComments) && am(t2);
        }
        return e2.type === "InterpreterDirective" && (t2.value = t2.value.trimEnd()), e2.type !== "TSIntersectionType" && e2.type !== "TSUnionType" || e2.types.length !== 1 ? void 0 : t2.types[0];
      }
      cm.ignoredProperties = sm;
      var lm = cm;
      const pm = (e2) => {
        if (typeof e2 != "string")
          throw new TypeError("Expected a string");
        const t2 = e2.match(/(?:\r?\n)/g) || [];
        if (t2.length === 0)
          return;
        const n2 = t2.filter((e3) => e3 === "\r\n").length;
        return n2 > t2.length - n2 ? "\r\n" : "\n";
      };
      var fm = pm;
      fm.graceful = (e2) => typeof e2 == "string" && pm(e2) || "\n";
      var dm = function(e2) {
        const t2 = e2.match(Am);
        return t2 ? t2[0].trimLeft() : "";
      }, hm = function(e2) {
        const t2 = e2.match(Am);
        return t2 && t2[0] ? e2.substring(t2[0].length) : e2;
      }, gm = function(e2) {
        return Bm(e2).pragmas;
      }, mm = Bm, ym = function({ comments: e2 = "", pragmas: t2 = {} }) {
        const n2 = (0, Em().default)(e2) || Dm().EOL, r2 = " *", i2 = Object.keys(t2), u2 = i2.map((e3) => Nm(e3, t2[e3])).reduce((e3, t3) => e3.concat(t3), []).map((e3) => " * " + e3 + n2).join("");
        if (!e2) {
          if (i2.length === 0)
            return "";
          if (i2.length === 1 && !Array.isArray(t2[i2[0]])) {
            const e3 = t2[i2[0]];
            return `/** ${Nm(i2[0], e3)[0]} */`;
          }
        }
        const o2 = e2.split(n2).map((e3) => ` * ${e3}`).join(n2) + n2;
        return "/**" + n2 + (e2 ? o2 : "") + (e2 && i2.length ? r2 + n2 : "") + u2 + " */";
      };
      function Dm() {
        const e2 = fs;
        return Dm = function() {
          return e2;
        }, e2;
      }
      function Em() {
        const e2 = function(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }(fm);
        return Em = function() {
          return e2;
        }, e2;
      }
      const Cm = /\*\/$/, bm = /^\/\*\*/, Am = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, vm = /(^|\s+)\/\/([^\r\n]*)/g, Fm = /^(\r?\n)+/, xm = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, Sm = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, wm = /(\r?\n|^) *\* ?/g, Tm = [];
      function Bm(e2) {
        const t2 = (0, Em().default)(e2) || Dm().EOL;
        e2 = e2.replace(bm, "").replace(Cm, "").replace(wm, "$1");
        let n2 = "";
        for (; n2 !== e2; )
          n2 = e2, e2 = e2.replace(xm, `${t2}$1 $2${t2}`);
        e2 = e2.replace(Fm, "").trimRight();
        const r2 = Object.create(null), i2 = e2.replace(Sm, "").replace(Fm, "").trimRight();
        let u2;
        for (; u2 = Sm.exec(e2); ) {
          const e3 = u2[2].replace(vm, "");
          typeof r2[u2[1]] == "string" || Array.isArray(r2[u2[1]]) ? r2[u2[1]] = Tm.concat(r2[u2[1]], e3) : r2[u2[1]] = e3;
        }
        return { comments: i2, pragmas: r2 };
      }
      function Nm(e2, t2) {
        return Tm.concat(t2).map((t3) => `@${e2} ${t3}`.trim());
      }
      var km = Object.defineProperty({ extract: dm, strip: hm, parse: gm, parseWithComments: mm, print: ym }, "__esModule", { value: true });
      const { parseWithComments: Pm, strip: Om, extract: Im, print: Lm } = km, { getShebang: jm } = Fi, { normalizeEndOfLine: _m } = xi;
      function Mm(e2) {
        const t2 = jm(e2);
        t2 && (e2 = e2.slice(t2.length + 1));
        const n2 = Im(e2), { pragmas: r2, comments: i2 } = Pm(n2);
        return { shebang: t2, text: e2, pragmas: r2, comments: i2 };
      }
      var Rm = { hasPragma: function(e2) {
        const t2 = Object.keys(Mm(e2).pragmas);
        return t2.includes("prettier") || t2.includes("format");
      }, insertPragma: function(e2) {
        const { shebang: t2, text: n2, pragmas: r2, comments: i2 } = Mm(e2), u2 = Om(n2), o2 = Lm({ pragmas: Object.assign({ format: "" }, r2), comments: i2.trimStart() });
        return (t2 ? `${t2}
` : "") + _m(o2) + (u2.startsWith("\n") ? "\n" : "\n\n") + u2;
      } };
      const { getLast: $m, hasNewline: Vm, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Wm, getNextNonSpaceNonCommentCharacter: qm, hasNewlineInRange: Um, addLeadingComment: zm, addTrailingComment: Gm, addDanglingComment: Hm, getNextNonSpaceNonCommentCharacterIndex: Jm, isNonEmptyArray: Xm } = Fi, { isBlockComment: Ym, getFunctionParameters: Km, isPrettierIgnoreComment: Qm, isJsxNode: Zm, hasFlowShorthandAnnotationComment: ey, hasFlowAnnotationComment: ty, hasIgnoreComment: ny, isCallLikeExpression: ry, getCallArguments: iy, isCallExpression: uy, isMemberExpression: oy, isObjectProperty: sy, getComments: ay, CommentCheckFlags: cy } = eg, { locStart: ly, locEnd: py } = Zc;
      function fy(e2, t2) {
        const n2 = (e2.body || e2.properties).find(({ type: e3 }) => e3 !== "EmptyStatement");
        n2 ? zm(n2, t2) : Hm(e2, t2);
      }
      function dy(e2, t2) {
        e2.type === "BlockStatement" ? fy(e2, t2) : zm(e2, t2);
      }
      function hy({ comment: e2, followingNode: t2 }) {
        return !(!t2 || !qy(e2)) && (zm(t2, e2), true);
      }
      function gy({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2 }) {
        if (!n2 || n2.type !== "IfStatement" || !r2)
          return false;
        return qm(i2, e2, py) === ")" ? (Gm(t2, e2), true) : t2 === n2.consequent && r2 === n2.alternate ? (t2.type === "BlockStatement" ? Gm(t2, e2) : Hm(n2, e2), true) : r2.type === "BlockStatement" ? (fy(r2, e2), true) : r2.type === "IfStatement" ? (dy(r2.consequent, e2), true) : n2.consequent === r2 && (zm(r2, e2), true);
      }
      function my({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2 }) {
        if (!n2 || n2.type !== "WhileStatement" || !r2)
          return false;
        return qm(i2, e2, py) === ")" ? (Gm(t2, e2), true) : r2.type === "BlockStatement" ? (fy(r2, e2), true) : n2.body === r2 && (zm(r2, e2), true);
      }
      function yy({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2 }) {
        return !(!n2 || n2.type !== "TryStatement" && n2.type !== "CatchClause" || !r2) && (n2.type === "CatchClause" && t2 ? (Gm(t2, e2), true) : r2.type === "BlockStatement" ? (fy(r2, e2), true) : r2.type === "TryStatement" ? (dy(r2.finalizer, e2), true) : r2.type === "CatchClause" && (dy(r2.body, e2), true));
      }
      function Dy({ comment: e2, enclosingNode: t2, followingNode: n2 }) {
        return !(!oy(t2) || !n2 || n2.type !== "Identifier") && (zm(t2, e2), true);
      }
      function Ey({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2 }) {
        const u2 = t2 && !Um(i2, py(t2), ly(e2));
        return !(t2 && u2 || !n2 || n2.type !== "ConditionalExpression" && n2.type !== "TSConditionalType" || !r2) && (zm(r2, e2), true);
      }
      function Cy({ comment: e2, precedingNode: t2, enclosingNode: n2 }) {
        return !(!sy(n2) || !n2.shorthand || n2.key !== t2 || n2.value.type !== "AssignmentPattern") && (Gm(n2.value.left, e2), true);
      }
      function by({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2 }) {
        if (n2 && (n2.type === "ClassDeclaration" || n2.type === "ClassExpression" || n2.type === "DeclareClass" || n2.type === "DeclareInterface" || n2.type === "InterfaceDeclaration" || n2.type === "TSInterfaceDeclaration")) {
          if (Xm(n2.decorators) && (!r2 || r2.type !== "Decorator"))
            return Gm($m(n2.decorators), e2), true;
          if (n2.body && r2 === n2.body)
            return fy(n2.body, e2), true;
          if (r2) {
            for (const i2 of ["implements", "extends", "mixins"])
              if (n2[i2] && r2 === n2[i2][0])
                return !t2 || t2 !== n2.id && t2 !== n2.typeParameters && t2 !== n2.superClass ? Hm(n2, e2, i2) : Gm(t2, e2), true;
          }
        }
        return false;
      }
      function Ay({ comment: e2, precedingNode: t2, enclosingNode: n2, text: r2 }) {
        return (n2 && t2 && (n2.type === "Property" || n2.type === "TSDeclareMethod" || n2.type === "TSAbstractMethodDefinition") && t2.type === "Identifier" && n2.key === t2 && qm(r2, t2, py) !== ":" || !(!t2 || !n2 || t2.type !== "Decorator" || n2.type !== "ClassMethod" && n2.type !== "ClassProperty" && n2.type !== "PropertyDefinition" && n2.type !== "TSAbstractClassProperty" && n2.type !== "TSAbstractMethodDefinition" && n2.type !== "TSDeclareMethod" && n2.type !== "MethodDefinition")) && (Gm(t2, e2), true);
      }
      function vy({ comment: e2, precedingNode: t2, enclosingNode: n2, text: r2 }) {
        return qm(r2, e2, py) === "(" && (!(!t2 || !n2 || n2.type !== "FunctionDeclaration" && n2.type !== "FunctionExpression" && n2.type !== "ClassMethod" && n2.type !== "MethodDefinition" && n2.type !== "ObjectMethod") && (Gm(t2, e2), true));
      }
      function Fy({ comment: e2, enclosingNode: t2, text: n2 }) {
        if (!t2 || t2.type !== "ArrowFunctionExpression")
          return false;
        const r2 = Jm(n2, e2, py);
        return r2 !== false && n2.slice(r2, r2 + 2) === "=>" && (Hm(t2, e2), true);
      }
      function xy({ comment: e2, enclosingNode: t2, text: n2 }) {
        return qm(n2, e2, py) === ")" && (t2 && (Wy(t2) && Km(t2).length === 0 || ry(t2) && iy(t2).length === 0) ? (Hm(t2, e2), true) : !(!t2 || t2.type !== "MethodDefinition" && t2.type !== "TSAbstractMethodDefinition" || Km(t2.value).length !== 0) && (Hm(t2.value, e2), true));
      }
      function Sy({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2, text: i2 }) {
        if (t2 && t2.type === "FunctionTypeParam" && n2 && n2.type === "FunctionTypeAnnotation" && r2 && r2.type !== "FunctionTypeParam")
          return Gm(t2, e2), true;
        if (t2 && (t2.type === "Identifier" || t2.type === "AssignmentPattern") && n2 && Wy(n2) && qm(i2, e2, py) === ")")
          return Gm(t2, e2), true;
        if (n2 && n2.type === "FunctionDeclaration" && r2 && r2.type === "BlockStatement") {
          const t3 = (() => {
            const e3 = Km(n2);
            if (e3.length > 0)
              return Wm(i2, py($m(e3)));
            const t4 = Wm(i2, py(n2.id));
            return t4 !== false && Wm(i2, t4 + 1);
          })();
          if (ly(e2) > t3)
            return fy(r2, e2), true;
        }
        return false;
      }
      function wy({ comment: e2, enclosingNode: t2 }) {
        return !(!t2 || t2.type !== "ImportSpecifier") && (zm(t2, e2), true);
      }
      function Ty({ comment: e2, enclosingNode: t2 }) {
        return !(!t2 || t2.type !== "LabeledStatement") && (zm(t2, e2), true);
      }
      function By({ comment: e2, enclosingNode: t2 }) {
        return !(!t2 || t2.type !== "ContinueStatement" && t2.type !== "BreakStatement" || t2.label) && (Gm(t2, e2), true);
      }
      function Ny({ comment: e2, precedingNode: t2, enclosingNode: n2 }) {
        return !!(uy(n2) && t2 && n2.callee === t2 && n2.arguments.length > 0) && (zm(n2.arguments[0], e2), true);
      }
      function ky({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2 }) {
        return !n2 || n2.type !== "UnionTypeAnnotation" && n2.type !== "TSUnionType" ? (r2 && (r2.type === "UnionTypeAnnotation" || r2.type === "TSUnionType") && Qm(e2) && (r2.types[0].prettierIgnore = true, e2.unignore = true), false) : (Qm(e2) && (r2.prettierIgnore = true, e2.unignore = true), !!t2 && (Gm(t2, e2), true));
      }
      function Py({ comment: e2, enclosingNode: t2 }) {
        return !!sy(t2) && (zm(t2, e2), true);
      }
      function Oy({ comment: e2, enclosingNode: t2, followingNode: n2, ast: r2, isLastComment: i2 }) {
        return r2 && r2.body && r2.body.length === 0 ? (i2 ? Hm(r2, e2) : zm(r2, e2), true) : t2 && t2.type === "Program" && t2.body.length === 0 && !Xm(t2.directives) ? (i2 ? Hm(t2, e2) : zm(t2, e2), true) : !(!n2 || n2.type !== "Program" || n2.body.length !== 0 || !t2 || t2.type !== "ModuleExpression") && (Hm(n2, e2), true);
      }
      function Iy({ comment: e2, enclosingNode: t2 }) {
        return !(!t2 || t2.type !== "ForInStatement" && t2.type !== "ForOfStatement") && (zm(t2, e2), true);
      }
      function Ly({ comment: e2, precedingNode: t2, enclosingNode: n2, text: r2 }) {
        return !!(t2 && t2.type === "ImportSpecifier" && n2 && n2.type === "ImportDeclaration" && Vm(r2, py(e2))) && (Gm(t2, e2), true);
      }
      function jy({ comment: e2, enclosingNode: t2 }) {
        return !(!t2 || t2.type !== "AssignmentPattern") && (zm(t2, e2), true);
      }
      function _y({ comment: e2, enclosingNode: t2 }) {
        return !(!t2 || t2.type !== "TypeAlias") && (zm(t2, e2), true);
      }
      function My({ comment: e2, enclosingNode: t2, followingNode: n2 }) {
        return !(!t2 || t2.type !== "VariableDeclarator" && t2.type !== "AssignmentExpression" || !n2 || n2.type !== "ObjectExpression" && n2.type !== "ArrayExpression" && n2.type !== "TemplateLiteral" && n2.type !== "TaggedTemplateExpression" && !Ym(e2)) && (zm(n2, e2), true);
      }
      function Ry({ comment: e2, enclosingNode: t2, followingNode: n2, text: r2 }) {
        return !(n2 || !t2 || t2.type !== "TSMethodSignature" && t2.type !== "TSDeclareFunction" && t2.type !== "TSAbstractMethodDefinition" || qm(r2, e2, py) !== ";") && (Gm(t2, e2), true);
      }
      function $y({ comment: e2, enclosingNode: t2, followingNode: n2 }) {
        if (Qm(e2) && t2 && t2.type === "TSMappedType" && n2 && n2.type === "TSTypeParameter" && n2.constraint)
          return t2.prettierIgnore = true, e2.unignore = true, true;
      }
      function Vy({ comment: e2, precedingNode: t2, enclosingNode: n2, followingNode: r2 }) {
        return !(!n2 || n2.type !== "TSMappedType") && (r2 && r2.type === "TSTypeParameter" && r2.name ? (zm(r2.name, e2), true) : !(!t2 || t2.type !== "TSTypeParameter" || !t2.constraint) && (Gm(t2.constraint, e2), true));
      }
      function Wy(e2) {
        return e2.type === "ArrowFunctionExpression" || e2.type === "FunctionExpression" || e2.type === "FunctionDeclaration" || e2.type === "ObjectMethod" || e2.type === "ClassMethod" || e2.type === "TSDeclareFunction" || e2.type === "TSCallSignatureDeclaration" || e2.type === "TSConstructSignatureDeclaration" || e2.type === "TSMethodSignature" || e2.type === "TSConstructorType" || e2.type === "TSFunctionType" || e2.type === "TSDeclareMethod";
      }
      function qy(e2) {
        return Ym(e2) && e2.value[0] === "*" && /@type\b/.test(e2.value);
      }
      var Uy = { handleOwnLineComment: function(e2) {
        return [$y, Sy, Dy, gy, my, yy, by, wy, Iy, ky, Oy, Ly, jy, Ay, Ty].some((t2) => t2(e2));
      }, handleEndOfLineComment: function(e2) {
        return [hy, Sy, Ey, wy, gy, my, yy, by, Ty, Ny, Py, Oy, _y, My].some((t2) => t2(e2));
      }, handleRemainingComment: function(e2) {
        return [$y, gy, my, Cy, xy, Ay, Oy, Fy, vy, Vy, By, Ry].some((t2) => t2(e2));
      }, isTypeCastComment: qy, getCommentChildNodes: function(e2, t2) {
        if ((t2.parser === "typescript" || t2.parser === "flow" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree") && e2.type === "MethodDefinition" && e2.value && e2.value.type === "FunctionExpression" && Km(e2.value).length === 0 && !e2.value.returnType && !Xm(e2.value.typeParameters) && e2.value.body)
          return [...e2.decorators || [], e2.key, e2.value.body];
      }, willPrintOwnComments: function(e2) {
        const t2 = e2.getValue(), n2 = e2.getParentNode();
        return (t2 && (Zm(t2) || ey(t2) || uy(n2) && ((e3) => ty(ay(e3, cy.Leading)) || ty(ay(e3, cy.Trailing)))(t2)) || n2 && (n2.type === "JSXSpreadAttribute" || n2.type === "JSXSpreadChild" || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType" || (n2.type === "ClassDeclaration" || n2.type === "ClassExpression") && n2.superClass === t2)) && (!ny(e2) || n2.type === "UnionTypeAnnotation" || n2.type === "TSUnionType");
      } };
      const { getFunctionParameters: zy, getLeftSidePathName: Gy, hasFlowShorthandAnnotationComment: Hy, hasNakedLeftSide: Jy, hasNode: Xy, isBitwiseOperator: Yy, startsWithNoLookaheadToken: Ky, shouldFlatten: Qy, getPrecedence: Zy, isCallExpression: eD, isMemberExpression: tD, isObjectProperty: nD } = eg;
      function rD(e2, t2) {
        const n2 = e2.getParentNode();
        if (!n2)
          return false;
        const r2 = e2.getName(), i2 = e2.getNode();
        if (t2.__isInHtmlInterpolation && !t2.bracketSpacing && function(e3) {
          switch (e3.type) {
            case "ObjectExpression":
              return true;
            default:
              return false;
          }
        }(i2) && iD(e2))
          return true;
        if (function(e3) {
          return e3.type === "BlockStatement" || e3.type === "BreakStatement" || e3.type === "ClassBody" || e3.type === "ClassDeclaration" || e3.type === "ClassMethod" || e3.type === "ClassProperty" || e3.type === "PropertyDefinition" || e3.type === "ClassPrivateProperty" || e3.type === "ContinueStatement" || e3.type === "DebuggerStatement" || e3.type === "DeclareClass" || e3.type === "DeclareExportAllDeclaration" || e3.type === "DeclareExportDeclaration" || e3.type === "DeclareFunction" || e3.type === "DeclareInterface" || e3.type === "DeclareModule" || e3.type === "DeclareModuleExports" || e3.type === "DeclareVariable" || e3.type === "DoWhileStatement" || e3.type === "EnumDeclaration" || e3.type === "ExportAllDeclaration" || e3.type === "ExportDefaultDeclaration" || e3.type === "ExportNamedDeclaration" || e3.type === "ExpressionStatement" || e3.type === "ForInStatement" || e3.type === "ForOfStatement" || e3.type === "ForStatement" || e3.type === "FunctionDeclaration" || e3.type === "IfStatement" || e3.type === "ImportDeclaration" || e3.type === "InterfaceDeclaration" || e3.type === "LabeledStatement" || e3.type === "MethodDefinition" || e3.type === "ReturnStatement" || e3.type === "SwitchStatement" || e3.type === "ThrowStatement" || e3.type === "TryStatement" || e3.type === "TSDeclareFunction" || e3.type === "TSEnumDeclaration" || e3.type === "TSImportEqualsDeclaration" || e3.type === "TSInterfaceDeclaration" || e3.type === "TSModuleDeclaration" || e3.type === "TSNamespaceExportDeclaration" || e3.type === "TypeAlias" || e3.type === "VariableDeclaration" || e3.type === "WhileStatement" || e3.type === "WithStatement";
        }(i2))
          return false;
        if (t2.parser !== "flow" && Hy(e2.getValue()))
          return true;
        if (i2.type === "Identifier")
          return !!(i2.extra && i2.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(i2.name)) || r2 === "left" && i2.name === "async" && n2.type === "ForOfStatement" && !n2.await;
        switch (n2.type) {
          case "ParenthesizedExpression":
            return false;
          case "ClassDeclaration":
          case "ClassExpression":
            if (r2 === "superClass" && (i2.type === "ArrowFunctionExpression" || i2.type === "AssignmentExpression" || i2.type === "AwaitExpression" || i2.type === "BinaryExpression" || i2.type === "ConditionalExpression" || i2.type === "LogicalExpression" || i2.type === "NewExpression" || i2.type === "ObjectExpression" || i2.type === "ParenthesizedExpression" || i2.type === "SequenceExpression" || i2.type === "TaggedTemplateExpression" || i2.type === "UnaryExpression" || i2.type === "UpdateExpression" || i2.type === "YieldExpression" || i2.type === "TSNonNullExpression"))
              return true;
            break;
          case "ExportDefaultDeclaration":
            return uD(e2, t2) || i2.type === "SequenceExpression";
          case "Decorator":
            if (r2 === "expression") {
              let e3 = false, t3 = false, n3 = i2;
              for (; n3; )
                switch (n3.type) {
                  case "MemberExpression":
                    t3 = true, n3 = n3.object;
                    break;
                  case "CallExpression":
                    if (t3 || e3)
                      return true;
                    e3 = true, n3 = n3.callee;
                    break;
                  case "Identifier":
                    return false;
                  default:
                    return true;
                }
              return true;
            }
            break;
          case "ExpressionStatement":
            if (Ky(i2, true))
              return true;
            break;
          case "ArrowFunctionExpression":
            if (r2 === "body" && i2.type !== "SequenceExpression" && Ky(i2, false))
              return true;
        }
        switch (i2.type) {
          case "UpdateExpression":
            if (n2.type === "UnaryExpression")
              return i2.prefix && (i2.operator === "++" && n2.operator === "+" || i2.operator === "--" && n2.operator === "-");
          case "UnaryExpression":
            switch (n2.type) {
              case "UnaryExpression":
                return i2.operator === n2.operator && (i2.operator === "+" || i2.operator === "-");
              case "BindExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r2 === "object";
              case "TaggedTemplateExpression":
                return true;
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r2 === "callee";
              case "BinaryExpression":
                return r2 === "left" && n2.operator === "**";
              case "TSNonNullExpression":
                return true;
              default:
                return false;
            }
          case "BinaryExpression":
            if (n2.type === "UpdateExpression" || n2.type === "PipelineTopicExpression" && i2.operator === "|>")
              return true;
            if (i2.operator === "in" && function(e3) {
              let t3 = 0, n3 = e3.getValue();
              for (; n3; ) {
                const r3 = e3.getParentNode(t3++);
                if (r3 && r3.type === "ForStatement" && r3.init === n3)
                  return true;
                n3 = r3;
              }
              return false;
            }(e2))
              return true;
            if (i2.operator === "|>" && i2.extra && i2.extra.parenthesized) {
              const t3 = e2.getParentNode(1);
              if (t3.type === "BinaryExpression" && t3.operator === "|>")
                return true;
            }
          case "TSTypeAssertion":
          case "TSAsExpression":
          case "LogicalExpression":
            switch (n2.type) {
              case "TSAsExpression":
                return i2.type !== "TSAsExpression";
              case "ConditionalExpression":
                return i2.type === "TSAsExpression";
              case "CallExpression":
              case "NewExpression":
              case "OptionalCallExpression":
                return r2 === "callee";
              case "ClassExpression":
              case "ClassDeclaration":
                return r2 === "superClass";
              case "TSTypeAssertion":
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "JSXSpreadAttribute":
              case "SpreadElement":
              case "SpreadProperty":
              case "BindExpression":
              case "AwaitExpression":
              case "TSNonNullExpression":
              case "UpdateExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r2 === "object";
              case "AssignmentExpression":
              case "AssignmentPattern":
                return r2 === "left" && (i2.type === "TSTypeAssertion" || i2.type === "TSAsExpression");
              case "LogicalExpression":
                if (i2.type === "LogicalExpression")
                  return n2.operator !== i2.operator;
              case "BinaryExpression": {
                const { operator: e3, type: t3 } = i2;
                if (!e3 && t3 !== "TSTypeAssertion")
                  return true;
                const u2 = Zy(e3), o2 = n2.operator, s2 = Zy(o2);
                return s2 > u2 || (r2 === "right" && s2 === u2 || (s2 === u2 && !Qy(o2, e3) || (s2 < u2 && e3 === "%" ? o2 === "+" || o2 === "-" : !!Yy(o2))));
              }
              default:
                return false;
            }
          case "SequenceExpression":
            switch (n2.type) {
              case "ReturnStatement":
              case "ForStatement":
                return false;
              case "ExpressionStatement":
                return r2 !== "expression";
              case "ArrowFunctionExpression":
                return r2 !== "body";
              default:
                return true;
            }
          case "YieldExpression":
            if (n2.type === "UnaryExpression" || n2.type === "AwaitExpression" || n2.type === "TSAsExpression" || n2.type === "TSNonNullExpression")
              return true;
            if (r2 === "expression" && i2.argument && i2.argument.type === "PipelinePrimaryTopicReference" && n2.type === "PipelineTopicExpression")
              return true;
          case "AwaitExpression":
            switch (n2.type) {
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "LogicalExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "BindExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r2 === "object";
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r2 === "callee";
              case "ConditionalExpression":
                return r2 === "test";
              case "BinaryExpression":
                return !(!i2.argument && n2.operator === "|>");
              default:
                return false;
            }
          case "TSConditionalType":
            if (r2 === "extendsType" && n2.type === "TSConditionalType")
              return true;
          case "TSFunctionType":
          case "TSConstructorType":
            if (r2 === "checkType" && n2.type === "TSConditionalType")
              return true;
          case "TSUnionType":
          case "TSIntersectionType":
            if ((n2.type === "TSUnionType" || n2.type === "TSIntersectionType") && n2.types.length > 1 && (!i2.types || i2.types.length > 1))
              return true;
          case "TSInferType":
            if (i2.type === "TSInferType" && n2.type === "TSRestType")
              return false;
          case "TSTypeOperator":
            return n2.type === "TSArrayType" || n2.type === "TSOptionalType" || n2.type === "TSRestType" || r2 === "objectType" && n2.type === "TSIndexedAccessType" || n2.type === "TSTypeOperator" || n2.type === "TSTypeAnnotation" && /^TSJSDoc/.test(e2.getParentNode(1).type);
          case "ArrayTypeAnnotation":
            return n2.type === "NullableTypeAnnotation";
          case "IntersectionTypeAnnotation":
          case "UnionTypeAnnotation":
            return n2.type === "ArrayTypeAnnotation" || n2.type === "NullableTypeAnnotation" || n2.type === "IntersectionTypeAnnotation" || n2.type === "UnionTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
          case "NullableTypeAnnotation":
            return n2.type === "ArrayTypeAnnotation" || r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
          case "FunctionTypeAnnotation": {
            const t3 = n2.type === "NullableTypeAnnotation" ? e2.getParentNode(1) : n2;
            return t3.type === "UnionTypeAnnotation" || t3.type === "IntersectionTypeAnnotation" || t3.type === "ArrayTypeAnnotation" || r2 === "objectType" && (t3.type === "IndexedAccessType" || t3.type === "OptionalIndexedAccessType") || t3.type === "NullableTypeAnnotation" || n2.type === "FunctionTypeParam" && n2.name === null && zy(i2).some((e3) => e3.typeAnnotation && e3.typeAnnotation.type === "NullableTypeAnnotation");
          }
          case "OptionalIndexedAccessType":
            return r2 === "objectType" && n2.type === "IndexedAccessType";
          case "TypeofTypeAnnotation":
            return r2 === "objectType" && (n2.type === "IndexedAccessType" || n2.type === "OptionalIndexedAccessType");
          case "StringLiteral":
          case "NumericLiteral":
          case "Literal":
            if (typeof i2.value == "string" && n2.type === "ExpressionStatement" && !n2.directive) {
              const t3 = e2.getParentNode(1);
              return t3.type === "Program" || t3.type === "BlockStatement";
            }
            return r2 === "object" && n2.type === "MemberExpression" && typeof i2.value == "number";
          case "AssignmentExpression": {
            const t3 = e2.getParentNode(1);
            return r2 === "body" && n2.type === "ArrowFunctionExpression" || (r2 !== "key" || n2.type !== "ClassProperty" && n2.type !== "PropertyDefinition" || !n2.computed) && ((r2 !== "init" && r2 !== "update" || n2.type !== "ForStatement") && (n2.type === "ExpressionStatement" ? i2.left.type === "ObjectPattern" : (r2 !== "key" || n2.type !== "TSPropertySignature") && (n2.type !== "AssignmentExpression" && ((n2.type !== "SequenceExpression" || !t3 || t3.type !== "ForStatement" || t3.init !== n2 && t3.update !== n2) && ((r2 !== "value" || n2.type !== "Property" || !t3 || t3.type !== "ObjectPattern" || !t3.properties.includes(n2)) && n2.type !== "NGChainedExpression")))));
          }
          case "ConditionalExpression":
            switch (n2.type) {
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "BinaryExpression":
              case "LogicalExpression":
              case "NGPipeExpression":
              case "ExportDefaultDeclaration":
              case "AwaitExpression":
              case "JSXSpreadAttribute":
              case "TSTypeAssertion":
              case "TypeCastExpression":
              case "TSAsExpression":
              case "TSNonNullExpression":
                return true;
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r2 === "callee";
              case "ConditionalExpression":
                return r2 === "test";
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r2 === "object";
              default:
                return false;
            }
          case "FunctionExpression":
            switch (n2.type) {
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r2 === "callee";
              case "TaggedTemplateExpression":
                return true;
              default:
                return false;
            }
          case "ArrowFunctionExpression":
            switch (n2.type) {
              case "PipelineTopicExpression":
                return Boolean(i2.extra && i2.extra.parenthesized);
              case "BinaryExpression":
                return n2.operator !== "|>" || i2.extra && i2.extra.parenthesized;
              case "NewExpression":
              case "CallExpression":
              case "OptionalCallExpression":
                return r2 === "callee";
              case "MemberExpression":
              case "OptionalMemberExpression":
                return r2 === "object";
              case "TSAsExpression":
              case "TSNonNullExpression":
              case "BindExpression":
              case "TaggedTemplateExpression":
              case "UnaryExpression":
              case "LogicalExpression":
              case "AwaitExpression":
              case "TSTypeAssertion":
                return true;
              case "ConditionalExpression":
                return r2 === "test";
              default:
                return false;
            }
          case "ClassExpression":
            switch (n2.type) {
              case "NewExpression":
                return r2 === "callee";
              default:
                return false;
            }
          case "OptionalMemberExpression":
          case "OptionalCallExpression": {
            const t3 = e2.getParentNode(1);
            if (r2 === "object" && n2.type === "MemberExpression" || r2 === "callee" && (n2.type === "CallExpression" || n2.type === "NewExpression") || n2.type === "TSNonNullExpression" && t3.type === "MemberExpression" && t3.object === n2)
              return true;
          }
          case "CallExpression":
          case "MemberExpression":
          case "TaggedTemplateExpression":
          case "TSNonNullExpression":
            if (r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression")) {
              let e3 = i2;
              for (; e3; )
                switch (e3.type) {
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                  case "BindExpression":
                    e3 = e3.object;
                    break;
                  case "TaggedTemplateExpression":
                    e3 = e3.tag;
                    break;
                  case "TSNonNullExpression":
                    e3 = e3.expression;
                    break;
                  default:
                    return false;
                }
            }
            return false;
          case "BindExpression":
            return r2 === "callee" && (n2.type === "BindExpression" || n2.type === "NewExpression") || r2 === "object" && tD(n2);
          case "NGPipeExpression":
            return !(n2.type === "NGRoot" || n2.type === "NGMicrosyntaxExpression" || n2.type === "ObjectProperty" && (!i2.extra || !i2.extra.parenthesized) || n2.type === "ArrayExpression" || eD(n2) && n2.arguments[r2] === i2 || r2 === "right" && n2.type === "NGPipeExpression" || r2 === "property" && n2.type === "MemberExpression" || n2.type === "AssignmentExpression");
          case "JSXFragment":
          case "JSXElement":
            return r2 === "callee" || r2 === "left" && n2.type === "BinaryExpression" && n2.operator === "<" || n2.type !== "ArrayExpression" && n2.type !== "ArrowFunctionExpression" && n2.type !== "AssignmentExpression" && n2.type !== "AssignmentPattern" && n2.type !== "BinaryExpression" && n2.type !== "NewExpression" && n2.type !== "ConditionalExpression" && n2.type !== "ExpressionStatement" && n2.type !== "JsExpressionRoot" && n2.type !== "JSXAttribute" && n2.type !== "JSXElement" && n2.type !== "JSXExpressionContainer" && n2.type !== "JSXFragment" && n2.type !== "LogicalExpression" && !eD(n2) && !nD(n2) && n2.type !== "ReturnStatement" && n2.type !== "ThrowStatement" && n2.type !== "TypeCastExpression" && n2.type !== "VariableDeclarator" && n2.type !== "YieldExpression";
          case "TypeAnnotation":
            return r2 === "returnType" && n2.type === "ArrowFunctionExpression" && function(e3) {
              return Xy(e3, (e4) => e4.type === "ObjectTypeAnnotation" && Xy(e4, (e5) => e5.type === "FunctionTypeAnnotation" || void 0) || void 0);
            }(i2);
        }
        return false;
      }
      function iD(e2) {
        const t2 = e2.getValue(), n2 = e2.getParentNode(), r2 = e2.getName();
        switch (n2.type) {
          case "NGPipeExpression":
            if (typeof r2 == "number" && n2.arguments[r2] === t2 && n2.arguments.length - 1 === r2)
              return e2.callParent(iD);
            break;
          case "ObjectProperty":
            if (r2 === "value") {
              const t3 = e2.getParentNode(1);
              return _n(t3.properties) === n2;
            }
            break;
          case "BinaryExpression":
          case "LogicalExpression":
            if (r2 === "right")
              return e2.callParent(iD);
            break;
          case "ConditionalExpression":
            if (r2 === "alternate")
              return e2.callParent(iD);
            break;
          case "UnaryExpression":
            if (n2.prefix)
              return e2.callParent(iD);
        }
        return false;
      }
      function uD(e2, t2) {
        const n2 = e2.getValue(), r2 = e2.getParentNode();
        return n2.type === "FunctionExpression" || n2.type === "ClassExpression" ? r2.type === "ExportDefaultDeclaration" || !rD(e2, t2) : !(!Jy(n2) || r2.type !== "ExportDefaultDeclaration" && rD(e2, t2)) && e2.call((e3) => uD(e3, t2), ...Gy(e2, n2));
      }
      var oD = rD;
      var sD = function(e2, t2) {
        switch (t2.parser) {
          case "json":
          case "json5":
          case "json-stringify":
          case "__js_expression":
          case "__vue_expression":
            return Object.assign(Object.assign({}, e2), {}, { type: t2.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: e2, comments: [], rootMarker: t2.rootMarker });
          default:
            return e2;
        }
      };
      const { builders: { join: aD, line: cD, group: lD, softline: pD, indent: fD } } = su;
      var dD = { isVueEventBindingExpression: function e2(t2) {
        switch (t2.type) {
          case "MemberExpression":
            switch (t2.property.type) {
              case "Identifier":
              case "NumericLiteral":
              case "StringLiteral":
                return e2(t2.object);
            }
            return false;
          case "Identifier":
            return true;
          default:
            return false;
        }
      }, printHtmlBinding: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (t2.__onHtmlBindingRoot && e2.getName() === null && t2.__onHtmlBindingRoot(r2, t2), r2.type === "File")
          return t2.__isVueForBindingLeft ? e2.call((e3) => {
            const t3 = aD([",", cD], e3.map(n2, "params")), { params: r3 } = e3.getValue();
            return r3.length === 1 ? t3 : ["(", fD([pD, lD(t3)]), pD, ")"];
          }, "program", "body", 0) : t2.__isVueBindings ? e2.call((e3) => aD([",", cD], e3.map(n2, "params")), "program", "body", 0) : void 0;
      } };
      const { printComments: hD } = Yf, { getLast: gD } = Fi, { builders: { join: mD, line: yD, softline: DD, group: ED, indent: CD, align: bD, ifBreak: AD, indentIfBreak: vD }, utils: { cleanDoc: FD, getDocParts: xD, isConcat: SD } } = su, { hasLeadingOwnLineComment: wD, isBinaryish: TD, isJsxNode: BD, shouldFlatten: ND, hasComment: kD, CommentCheckFlags: PD, isCallExpression: OD, isMemberExpression: ID, isObjectProperty: LD } = eg;
      let jD = 0;
      function _D(e2, t2, n2, r2, i2) {
        let u2 = [];
        const o2 = e2.getValue();
        if (TD(o2)) {
          ND(o2.operator, o2.left.operator) ? u2 = [...u2, ...e2.call((e3) => _D(e3, t2, n2, true, i2), "left")] : u2.push(ED(t2("left")));
          const s2 = MD(o2), a2 = (o2.operator === "|>" || o2.type === "NGPipeExpression" || o2.operator === "|" && n2.parser === "__vue_expression") && !wD(n2.originalText, o2.right), c2 = o2.type === "NGPipeExpression" ? "|" : o2.operator, l2 = o2.type === "NGPipeExpression" && o2.arguments.length > 0 ? ED(CD([DD, ": ", mD([DD, ":", AD(" ")], e2.map(t2, "arguments").map((e3) => bD(2, ED(e3))))])) : "", p2 = s2 ? [c2, " ", t2("right"), l2] : [a2 ? yD : "", c2, a2 ? " " : yD, t2("right"), l2], f2 = e2.getParentNode(), d2 = kD(o2.left, PD.Trailing | PD.Line), h2 = d2 || !(i2 && o2.type === "LogicalExpression") && f2.type !== o2.type && o2.left.type !== o2.type && o2.right.type !== o2.type;
          if (u2.push(a2 ? "" : " ", h2 ? ED(p2, { shouldBreak: d2 }) : p2), r2 && kD(o2)) {
            const t3 = FD(hD(e2, u2, n2));
            u2 = SD(t3) || t3.type === "fill" ? xD(t3) : [t3];
          }
        } else
          u2.push(ED(t2()));
        return u2;
      }
      function MD(e2) {
        return e2.type === "LogicalExpression" && (e2.right.type === "ObjectExpression" && e2.right.properties.length > 0 || (e2.right.type === "ArrayExpression" && e2.right.elements.length > 0 || !!BD(e2.right)));
      }
      var RD = { printBinaryishExpression: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = e2.getParentNode(), u2 = e2.getParentNode(1), o2 = r2 !== i2.body && (i2.type === "IfStatement" || i2.type === "WhileStatement" || i2.type === "SwitchStatement" || i2.type === "DoWhileStatement"), s2 = _D(e2, n2, t2, false, o2);
        if (o2)
          return s2;
        if (OD(i2) && i2.callee === r2 || i2.type === "UnaryExpression" || ID(i2) && !i2.computed)
          return ED([CD([DD, ...s2]), DD]);
        const a2 = i2.type === "ReturnStatement" || i2.type === "ThrowStatement" || i2.type === "JSXExpressionContainer" && u2.type === "JSXAttribute" || r2.operator !== "|" && i2.type === "JsExpressionRoot" || r2.type !== "NGPipeExpression" && (i2.type === "NGRoot" && t2.parser === "__ng_binding" || i2.type === "NGMicrosyntaxExpression" && u2.type === "NGMicrosyntax" && u2.body.length === 1) || r2 === i2.body && i2.type === "ArrowFunctionExpression" || r2 !== i2.body && i2.type === "ForStatement" || i2.type === "ConditionalExpression" && u2.type !== "ReturnStatement" && u2.type !== "ThrowStatement" && !OD(u2) || i2.type === "TemplateLiteral", c2 = i2.type === "AssignmentExpression" || i2.type === "VariableDeclarator" || i2.type === "ClassProperty" || i2.type === "PropertyDefinition" || i2.type === "TSAbstractClassProperty" || i2.type === "ClassPrivateProperty" || LD(i2), l2 = TD(r2.left) && ND(r2.operator, r2.left.operator);
        if (a2 || MD(r2) && !l2 || !MD(r2) && c2)
          return ED(s2);
        if (s2.length === 0)
          return "";
        const p2 = BD(r2.right), f2 = s2.findIndex((e3) => typeof e3 != "string" && !Array.isArray(e3) && e3.type === "group"), d2 = s2.slice(0, f2 === -1 ? 1 : f2 + 1), h2 = s2.slice(d2.length, p2 ? -1 : void 0), g2 = Symbol("logicalChain-" + ++jD), m2 = ED([...d2, CD(h2)], { id: g2 });
        if (!p2)
          return m2;
        const y2 = gD(s2);
        return ED([m2, vD(y2, { groupId: g2 })]);
      }, shouldInlineLogicalExpression: MD };
      const { builders: { join: $D, line: VD, group: WD } } = su, { hasNode: qD, hasComment: UD, getComments: zD } = eg, { printBinaryishExpression: GD } = RD;
      function HD(e2, t2, n2) {
        return e2.type === "NGMicrosyntaxKeyedExpression" && e2.key.name === "of" && t2 === 1 && n2.body[0].type === "NGMicrosyntaxLet" && n2.body[0].value === null;
      }
      var JD = { printAngular: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (r2.type.startsWith("NG"))
          switch (r2.type) {
            case "NGRoot":
              return [n2("node"), UD(r2.node) ? " //" + zD(r2.node)[0].value.trimEnd() : ""];
            case "NGPipeExpression":
              return GD(e2, t2, n2);
            case "NGChainedExpression":
              return WD($D([";", VD], e2.map((e3) => function(e4) {
                return qD(e4.getValue(), (e5) => {
                  switch (e5.type) {
                    case void 0:
                      return false;
                    case "CallExpression":
                    case "OptionalCallExpression":
                    case "AssignmentExpression":
                      return true;
                  }
                });
              }(e3) ? n2() : ["(", n2(), ")"], "expressions")));
            case "NGEmptyExpression":
              return "";
            case "NGQuotedExpression":
              return [r2.prefix, ": ", r2.value.trim()];
            case "NGMicrosyntax":
              return e2.map((e3, t3) => [t3 === 0 ? "" : HD(e3.getValue(), t3, r2) ? " " : [";", VD], n2()], "body");
            case "NGMicrosyntaxKey":
              return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(r2.name) ? r2.name : JSON.stringify(r2.name);
            case "NGMicrosyntaxExpression":
              return [n2("expression"), r2.alias === null ? "" : [" as ", n2("alias")]];
            case "NGMicrosyntaxKeyedExpression": {
              const t3 = e2.getName(), i2 = e2.getParentNode(), u2 = HD(r2, t3, i2) || (t3 === 1 && (r2.key.name === "then" || r2.key.name === "else") || t3 === 2 && r2.key.name === "else" && i2.body[t3 - 1].type === "NGMicrosyntaxKeyedExpression" && i2.body[t3 - 1].key.name === "then") && i2.body[0].type === "NGMicrosyntaxExpression";
              return [n2("key"), u2 ? " " : ": ", n2("expression")];
            }
            case "NGMicrosyntaxLet":
              return ["let ", n2("key"), r2.value === null ? "" : [" = ", n2("value")]];
            case "NGMicrosyntaxAs":
              return [n2("key"), " as ", n2("alias")];
            default:
              throw new Error(`Unknown Angular node type: ${JSON.stringify(r2.type)}.`);
          }
      } };
      const { printComments: XD, printDanglingComments: YD } = Yf, { builders: { line: KD, hardline: QD, softline: ZD, group: eE, indent: tE, conditionalGroup: nE, fill: rE, ifBreak: iE, lineSuffixBoundary: uE, join: oE }, utils: { willBreak: sE } } = su, { getLast: aE, getPreferredQuote: cE } = Fi, { isJsxNode: lE, rawText: pE, isLiteral: fE, isCallExpression: dE, isStringLiteral: hE, isBinaryish: gE, hasComment: mE, CommentCheckFlags: yE, hasNodeIgnoreComment: DE } = eg, { willPrintOwnComments: EE } = Uy, CE = (e2) => e2 === "" || e2 === KD || e2 === QD || e2 === ZD;
      function bE(e2, t2, n2) {
        const r2 = e2.getValue();
        if (r2.type === "JSXElement" && function(e3) {
          if (e3.children.length === 0)
            return true;
          if (e3.children.length > 1)
            return false;
          const t3 = e3.children[0];
          return fE(t3) && !BE(t3);
        }(r2))
          return [n2("openingElement"), n2("closingElement")];
        const i2 = r2.type === "JSXElement" ? n2("openingElement") : n2("openingFragment"), u2 = r2.type === "JSXElement" ? n2("closingElement") : n2("closingFragment");
        if (r2.children.length === 1 && r2.children[0].type === "JSXExpressionContainer" && (r2.children[0].expression.type === "TemplateLiteral" || r2.children[0].expression.type === "TaggedTemplateExpression"))
          return [i2, ...e2.map(n2, "children"), u2];
        r2.children = r2.children.map((e3) => function(e4) {
          return e4.type === "JSXExpressionContainer" && fE(e4.expression) && e4.expression.value === " " && !mE(e4.expression);
        }(e3) ? { type: "JSXText", value: " ", raw: " " } : e3);
        const o2 = r2.children.filter(lE).length > 0, s2 = r2.children.filter((e3) => e3.type === "JSXExpressionContainer").length > 1, a2 = r2.type === "JSXElement" && r2.openingElement.attributes.length > 1;
        let c2 = sE(i2) || o2 || a2 || s2;
        const l2 = e2.getParentNode().rootMarker === "mdx", p2 = t2.singleQuote ? "{' '}" : '{" "}', f2 = l2 ? " " : iE([p2, ZD], " "), d2 = function(e3, t3, n3, r3, i3) {
          const u3 = [];
          return e3.each((e4, t4, o3) => {
            const s3 = e4.getValue();
            if (fE(s3)) {
              const e5 = pE(s3);
              if (BE(s3)) {
                const n4 = e5.split(SE);
                if (n4[0] === "") {
                  if (u3.push(""), n4.shift(), /\n/.test(n4[0])) {
                    const e6 = o3[t4 + 1];
                    u3.push(vE(i3, n4[1], s3, e6));
                  } else
                    u3.push(r3);
                  n4.shift();
                }
                let a3;
                if (aE(n4) === "" && (n4.pop(), a3 = n4.pop()), n4.length === 0)
                  return;
                for (const [e6, t5] of n4.entries())
                  e6 % 2 == 1 ? u3.push(KD) : u3.push(t5);
                if (a3 !== void 0)
                  if (/\n/.test(a3)) {
                    const e6 = o3[t4 + 1];
                    u3.push(vE(i3, aE(u3), s3, e6));
                  } else
                    u3.push(r3);
                else {
                  const e6 = o3[t4 + 1];
                  u3.push(AE(i3, aE(u3), s3, e6));
                }
              } else
                /\n/.test(e5) ? e5.match(/\n/g).length > 1 && u3.push("", QD) : u3.push("", r3);
            } else {
              const e5 = n3();
              u3.push(e5);
              const r4 = o3[t4 + 1];
              if (r4 && BE(r4)) {
                const e6 = TE(pE(r4)).split(SE)[0];
                u3.push(AE(i3, e6, s3, r4));
              } else
                u3.push(QD);
            }
          }, "children"), u3;
        }(e2, 0, n2, f2, r2.openingElement && r2.openingElement.name && r2.openingElement.name.name === "fbt"), h2 = r2.children.some((e3) => BE(e3));
        for (let e3 = d2.length - 2; e3 >= 0; e3--) {
          const t3 = d2[e3] === "" && d2[e3 + 1] === "", n3 = d2[e3] === QD && d2[e3 + 1] === "" && d2[e3 + 2] === QD, r3 = (d2[e3] === ZD || d2[e3] === QD) && d2[e3 + 1] === "" && d2[e3 + 2] === f2, i3 = d2[e3] === f2 && d2[e3 + 1] === "" && (d2[e3 + 2] === ZD || d2[e3 + 2] === QD), u3 = d2[e3] === f2 && d2[e3 + 1] === "" && d2[e3 + 2] === f2, o3 = d2[e3] === ZD && d2[e3 + 1] === "" && d2[e3 + 2] === QD || d2[e3] === QD && d2[e3 + 1] === "" && d2[e3 + 2] === ZD;
          n3 && h2 || t3 || r3 || u3 || o3 ? d2.splice(e3, 2) : i3 && d2.splice(e3 + 1, 2);
        }
        for (; d2.length > 0 && CE(aE(d2)); )
          d2.pop();
        for (; d2.length > 1 && CE(d2[0]) && CE(d2[1]); )
          d2.shift(), d2.shift();
        const g2 = [];
        for (const [e3, t3] of d2.entries()) {
          if (t3 === f2) {
            if (e3 === 1 && d2[e3 - 1] === "") {
              if (d2.length === 2) {
                g2.push(p2);
                continue;
              }
              g2.push([p2, QD]);
              continue;
            }
            if (e3 === d2.length - 1) {
              g2.push(p2);
              continue;
            }
            if (d2[e3 - 1] === "" && d2[e3 - 2] === QD) {
              g2.push(p2);
              continue;
            }
          }
          g2.push(t3), sE(t3) && (c2 = true);
        }
        const m2 = h2 ? rE(g2) : eE(g2, { shouldBreak: true });
        if (l2)
          return m2;
        const y2 = eE([i2, tE([QD, m2]), QD, u2]);
        return c2 ? y2 : nE([eE([i2, ...d2, u2]), y2]);
      }
      function AE(e2, t2, n2, r2) {
        return e2 ? "" : n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? t2.length === 1 ? ZD : QD : ZD;
      }
      function vE(e2, t2, n2, r2) {
        return e2 ? QD : t2.length === 1 ? n2.type === "JSXElement" && !n2.closingElement || r2 && r2.type === "JSXElement" && !r2.closingElement ? QD : ZD : QD;
      }
      function FE(e2, t2, n2) {
        return function(e3, t3, n3) {
          const r2 = e3.getParentNode();
          if (!r2)
            return t3;
          if ({ ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[r2.type])
            return t3;
          const i2 = e3.match(void 0, (e4) => e4.type === "ArrowFunctionExpression", dE, (e4) => e4.type === "JSXExpressionContainer"), u2 = oD(e3, n3);
          return eE([u2 ? "" : iE("("), tE([ZD, t3]), ZD, u2 ? "" : iE(")")], { shouldBreak: i2 });
        }(e2, XD(e2, bE(e2, t2, n2), t2), t2);
      }
      function xE(e2, t2, n2) {
        const r2 = e2.getValue();
        return ["{", e2.call((e3) => {
          const r3 = ["...", n2()], i2 = e3.getValue();
          return mE(i2) && EE(e3) ? [tE([ZD, XD(e3, r3, t2)]), ZD] : r3;
        }, r2.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
      }
      const SE = new RegExp("([ \n\r	]+)"), wE = new RegExp("[^ \n\r	]"), TE = (e2) => e2.replace(new RegExp("(?:^" + SE.source + "|" + SE.source + "$)"), "");
      function BE(e2) {
        return fE(e2) && (wE.test(pE(e2)) || !/\n/.test(pE(e2)));
      }
      var NE = { hasJsxIgnoreComment: function(e2) {
        const t2 = e2.getValue(), n2 = e2.getParentNode();
        if (!(n2 && t2 && lE(t2) && lE(n2)))
          return false;
        let r2 = null;
        for (let e3 = n2.children.indexOf(t2); e3 > 0; e3--) {
          const t3 = n2.children[e3 - 1];
          if (t3.type !== "JSXText" || BE(t3)) {
            r2 = t3;
            break;
          }
        }
        return r2 && r2.type === "JSXExpressionContainer" && r2.expression.type === "JSXEmptyExpression" && DE(r2.expression);
      }, printJsx: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (r2.type.startsWith("JSX"))
          switch (r2.type) {
            case "JSXAttribute":
              return function(e3, t3, n3) {
                const r3 = e3.getValue(), i2 = [];
                if (i2.push(n3("name")), r3.value) {
                  let e4;
                  if (hE(r3.value)) {
                    let n4 = pE(r3.value).replace(/&apos;/g, "'").replace(/&quot;/g, '"');
                    const i3 = cE(n4, t3.jsxSingleQuote ? "'" : '"'), u2 = i3 === "'" ? "&apos;" : "&quot;";
                    n4 = n4.slice(1, -1).replace(new RegExp(i3, "g"), u2), e4 = [i3, n4, i3];
                  } else
                    e4 = n3("value");
                  i2.push("=", e4);
                }
                return i2;
              }(e2, t2, n2);
            case "JSXIdentifier":
              return String(r2.name);
            case "JSXNamespacedName":
              return oE(":", [n2("namespace"), n2("name")]);
            case "JSXMemberExpression":
              return oE(".", [n2("object"), n2("property")]);
            case "JSXSpreadAttribute":
              return xE(e2, t2, n2);
            case "JSXSpreadChild":
              return xE(e2, t2, n2);
            case "JSXExpressionContainer":
              return function(e3, t3, n3) {
                const r3 = e3.getValue(), i2 = e3.getParentNode(0), u2 = r3.expression.type === "JSXEmptyExpression" || !mE(r3.expression) && (r3.expression.type === "ArrayExpression" || r3.expression.type === "ObjectExpression" || r3.expression.type === "ArrowFunctionExpression" || dE(r3.expression) || r3.expression.type === "FunctionExpression" || r3.expression.type === "TemplateLiteral" || r3.expression.type === "TaggedTemplateExpression" || r3.expression.type === "DoExpression" || lE(i2) && (r3.expression.type === "ConditionalExpression" || gE(r3.expression)));
                return eE(u2 ? ["{", n3("expression"), uE, "}"] : ["{", tE([ZD, n3("expression")]), ZD, uE, "}"]);
              }(e2, 0, n2);
            case "JSXFragment":
            case "JSXElement":
              return FE(e2, t2, n2);
            case "JSXOpeningElement":
              return function(e3, t3, n3) {
                const r3 = e3.getValue(), i2 = r3.name && mE(r3.name) || r3.typeParameters && mE(r3.typeParameters);
                if (r3.selfClosing && r3.attributes.length === 0 && !i2)
                  return ["<", n3("name"), n3("typeParameters"), " />"];
                if (r3.attributes && r3.attributes.length === 1 && r3.attributes[0].value && hE(r3.attributes[0].value) && !r3.attributes[0].value.value.includes("\n") && !i2 && !mE(r3.attributes[0]))
                  return eE(["<", n3("name"), n3("typeParameters"), " ", ...e3.map(n3, "attributes"), r3.selfClosing ? " />" : ">"]);
                const u2 = r3.attributes.length > 0 && mE(aE(r3.attributes), yE.Trailing), o2 = r3.attributes.length === 0 && !i2 || (t3.bracketSameLine || t3.jsxBracketSameLine) && (!i2 || r3.attributes.length > 0) && !u2, s2 = r3.attributes && r3.attributes.some((e4) => e4.value && hE(e4.value) && e4.value.value.includes("\n"));
                return eE(["<", n3("name"), n3("typeParameters"), tE(e3.map(() => [KD, n3()], "attributes")), r3.selfClosing ? KD : o2 ? ">" : ZD, r3.selfClosing ? "/>" : o2 ? "" : ">"], { shouldBreak: s2 });
              }(e2, t2, n2);
            case "JSXClosingElement":
              return function(e3, t3, n3) {
                const r3 = e3.getValue(), i2 = [];
                i2.push("</");
                const u2 = n3("name");
                return mE(r3.name, yE.Leading | yE.Line) ? i2.push(tE([QD, u2]), QD) : mE(r3.name, yE.Leading | yE.Block) ? i2.push(" ", u2) : i2.push(u2), i2.push(">"), i2;
              }(e2, 0, n2);
            case "JSXOpeningFragment":
            case "JSXClosingFragment":
              return function(e3, t3) {
                const n3 = e3.getValue(), r3 = mE(n3), i2 = mE(n3, yE.Line), u2 = n3.type === "JSXOpeningFragment";
                return [u2 ? "<" : "</", tE([i2 ? QD : r3 && !u2 ? " " : "", YD(e3, t3, true)]), i2 ? QD : "", ">"];
              }(e2, t2);
            case "JSXEmptyExpression":
              return function(e3, t3) {
                const n3 = e3.getValue(), r3 = mE(n3, yE.Line);
                return [YD(e3, t3, !r3), r3 ? QD : ""];
              }(e2, t2);
            case "JSXText":
              throw new Error("JSXTest should be handled by JSXElement");
            default:
              throw new Error(`Unknown JSX node type: ${JSON.stringify(r2.type)}.`);
          }
      } };
      tt({ target: "Array", proto: true }, { flat: function() {
        var e2 = arguments.length ? arguments[0] : void 0, t2 = U(this), n2 = _e(t2.length), r2 = Un(t2, 0);
        return r2.length = Wn(r2, t2, t2, n2, 0, e2 === void 0 ? 1 : Le(e2)), r2;
      } });
      const { isNonEmptyArray: kE } = Fi, { builders: { indent: PE, join: OE, line: IE } } = su, { isFlowAnnotationComment: LE } = eg;
      function jE(e2, t2, n2) {
        const r2 = e2.getValue();
        if (!r2.typeAnnotation)
          return "";
        const i2 = e2.getParentNode(), u2 = r2.definite || i2 && i2.type === "VariableDeclarator" && i2.definite, o2 = i2.type === "DeclareFunction" && i2.id === r2;
        return LE(t2.originalText, r2.typeAnnotation) ? [" /*: ", n2("typeAnnotation"), " */"] : [o2 ? "" : u2 ? "!: " : ": ", n2("typeAnnotation")];
      }
      var _E = { printOptionalToken: function(e2) {
        const t2 = e2.getValue();
        return !t2.optional || t2.type === "Identifier" && t2 === e2.getParentNode().key ? "" : t2.type === "OptionalCallExpression" || t2.type === "OptionalMemberExpression" && t2.computed ? "?." : "?";
      }, printFunctionTypeParameters: function(e2, t2, n2) {
        const r2 = e2.getValue();
        return r2.typeArguments ? n2("typeArguments") : r2.typeParameters ? n2("typeParameters") : "";
      }, printBindExpressionCallee: function(e2, t2, n2) {
        return ["::", n2("callee")];
      }, printTypeScriptModifiers: function(e2, t2, n2) {
        const r2 = e2.getValue();
        return kE(r2.modifiers) ? [OE(" ", e2.map(n2, "modifiers")), " "] : "";
      }, printTypeAnnotation: jE, printRestSpread: function(e2, t2, n2) {
        return ["...", n2("argument"), jE(e2, t2, n2)];
      }, adjustClause: function(e2, t2, n2) {
        return e2.type === "EmptyStatement" ? ";" : e2.type === "BlockStatement" || n2 ? [" ", t2] : PE([IE, t2]);
      } };
      const { printDanglingComments: ME } = Yf, { builders: { line: RE, softline: $E, hardline: VE, group: WE, indent: qE, ifBreak: UE, fill: zE } } = su, { getLast: GE, hasNewline: HE } = Fi, { shouldPrintComma: JE, hasComment: XE, CommentCheckFlags: YE, isNextLineEmpty: KE, isNumericLiteral: QE, isSignedNumericLiteral: ZE } = eg, { locStart: eC } = Zc, { printOptionalToken: tC, printTypeAnnotation: nC } = _E;
      function rC(e2, t2) {
        return e2.elements.length > 1 && e2.elements.every((e3) => e3 && (QE(e3) || ZE(e3) && !XE(e3.argument)) && !XE(e3, YE.Trailing | YE.Line, (e4) => !HE(t2.originalText, eC(e4), { backwards: true })));
      }
      function iC(e2, t2, n2, r2) {
        const i2 = [];
        let u2 = [];
        return e2.each((e3) => {
          i2.push(u2, WE(r2())), u2 = [",", RE], e3.getValue() && KE(e3.getValue(), t2) && u2.push($E);
        }, n2), i2;
      }
      function uC(e2, t2, n2, r2) {
        const i2 = [];
        return e2.each((e3, u2, o2) => {
          const s2 = u2 === o2.length - 1;
          i2.push([n2(), s2 ? r2 : ","]), s2 || i2.push(KE(e3.getValue(), t2) ? [VE, VE] : XE(o2[u2 + 1], YE.Leading | YE.Line) ? VE : RE);
        }, "elements"), zE(i2);
      }
      var oC = { printArray: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = [], u2 = r2.type === "TupleExpression" ? "#[" : "[";
        if (r2.elements.length === 0)
          XE(r2, YE.Dangling) ? i2.push(WE([u2, ME(e2, t2), $E, "]"])) : i2.push(u2, "]");
        else {
          const o2 = GE(r2.elements), s2 = !(o2 && o2.type === "RestElement"), a2 = o2 === null, c2 = Symbol("array"), l2 = !t2.__inJestEach && r2.elements.length > 1 && r2.elements.every((e3, t3, n3) => {
            const r3 = e3 && e3.type;
            if (r3 !== "ArrayExpression" && r3 !== "ObjectExpression")
              return false;
            const i3 = n3[t3 + 1];
            if (i3 && r3 !== i3.type)
              return false;
            const u3 = r3 === "ArrayExpression" ? "elements" : "properties";
            return e3[u3] && e3[u3].length > 1;
          }), p2 = rC(r2, t2), f2 = s2 ? a2 ? "," : JE(t2) ? p2 ? UE(",", "", { groupId: c2 }) : UE(",") : "" : "";
          i2.push(WE([u2, qE([$E, p2 ? uC(e2, t2, n2, f2) : [iC(e2, t2, "elements", n2), f2], ME(e2, t2, true)]), $E, "]"], { shouldBreak: l2, id: c2 }));
        }
        return i2.push(tC(e2), nC(e2, t2, n2)), i2;
      }, printArrayItems: iC, isConciselyPrintedArray: rC };
      const { printDanglingComments: sC } = Yf, { getLast: aC, getPenultimate: cC } = Fi, { getFunctionParameters: lC, hasComment: pC, CommentCheckFlags: fC, isFunctionCompositionArgs: dC, isJsxNode: hC, isLongCurriedCallExpression: gC, shouldPrintComma: mC, getCallArguments: yC, iterateCallArgumentsPath: DC, isNextLineEmpty: EC, isCallExpression: CC, isStringLiteral: bC, isObjectProperty: AC } = eg, { builders: { line: vC, hardline: FC, softline: xC, group: SC, indent: wC, conditionalGroup: TC, ifBreak: BC, breakParent: NC }, utils: { willBreak: kC } } = su, { ArgExpansionBailout: PC } = Bo, { isConciselyPrintedArray: OC } = oC;
      function IC(e2, t2 = false) {
        return e2.type === "ObjectExpression" && (e2.properties.length > 0 || pC(e2)) || e2.type === "ArrayExpression" && (e2.elements.length > 0 || pC(e2)) || e2.type === "TSTypeAssertion" && IC(e2.expression) || e2.type === "TSAsExpression" && IC(e2.expression) || e2.type === "FunctionExpression" || e2.type === "ArrowFunctionExpression" && (!e2.returnType || !e2.returnType.typeAnnotation || e2.returnType.typeAnnotation.type !== "TSTypeReference" || (n2 = e2.body).type === "BlockStatement" && (n2.body.some((e3) => e3.type !== "EmptyStatement") || pC(n2, fC.Dangling))) && (e2.body.type === "BlockStatement" || e2.body.type === "ArrowFunctionExpression" && IC(e2.body, true) || e2.body.type === "ObjectExpression" || e2.body.type === "ArrayExpression" || !t2 && (CC(e2.body) || e2.body.type === "ConditionalExpression") || hC(e2.body)) || e2.type === "DoExpression" || e2.type === "ModuleExpression";
        var n2;
      }
      var LC = function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = r2.type === "ImportExpression", u2 = yC(r2);
        if (u2.length === 0)
          return ["(", sC(e2, t2, true), ")"];
        if (function(e3) {
          return e3.length === 2 && e3[0].type === "ArrowFunctionExpression" && lC(e3[0]).length === 0 && e3[0].body.type === "BlockStatement" && e3[1].type === "ArrayExpression" && !e3.some((e4) => pC(e4));
        }(u2))
          return ["(", n2(["arguments", 0]), ", ", n2(["arguments", 1]), ")"];
        let o2 = false, s2 = false;
        const a2 = u2.length - 1, c2 = [];
        DC(e2, (e3, r3) => {
          const i3 = e3.getNode(), u3 = [n2()];
          r3 === a2 || (EC(i3, t2) ? (r3 === 0 && (s2 = true), o2 = true, u3.push(",", FC, FC)) : u3.push(",", vC)), c2.push(u3);
        });
        const l2 = i2 || r2.callee && r2.callee.type === "Import" || !mC(t2, "all") ? "" : ",";
        function p2() {
          return SC(["(", wC([vC, ...c2]), l2, vC, ")"], { shouldBreak: true });
        }
        if (o2 || e2.getParentNode().type !== "Decorator" && dC(u2))
          return p2();
        const f2 = function(e3) {
          if (e3.length !== 2)
            return false;
          const [t3, n3] = e3;
          if (t3.type === "ModuleExpression" && function(e4) {
            return e4.type === "ObjectExpression" && e4.properties.length === 1 && AC(e4.properties[0]) && e4.properties[0].key.type === "Identifier" && e4.properties[0].key.name === "type" && bC(e4.properties[0].value) && e4.properties[0].value.value === "module";
          }(n3))
            return true;
          return !pC(t3) && (t3.type === "FunctionExpression" || t3.type === "ArrowFunctionExpression" && t3.body.type === "BlockStatement") && n3.type !== "FunctionExpression" && n3.type !== "ArrowFunctionExpression" && n3.type !== "ConditionalExpression" && !IC(n3);
        }(u2), d2 = function(e3, t3) {
          const n3 = aC(e3), r3 = cC(e3);
          return !pC(n3, fC.Leading) && !pC(n3, fC.Trailing) && IC(n3) && (!r3 || r3.type !== n3.type) && (e3.length !== 2 || r3.type !== "ArrowFunctionExpression" || n3.type !== "ArrayExpression") && !(e3.length > 1 && n3.type === "ArrayExpression" && OC(n3, t3));
        }(u2, t2);
        if (f2 || d2) {
          if (f2 ? c2.slice(1).some(kC) : c2.slice(0, -1).some(kC))
            return p2();
          let t3 = [];
          try {
            e2.try(() => {
              DC(e2, (e3, r3) => {
                f2 && r3 === 0 && (t3 = [[n2([], { expandFirstArg: true }), c2.length > 1 ? "," : "", s2 ? FC : vC, s2 ? FC : ""], ...c2.slice(1)]), d2 && r3 === a2 && (t3 = [...c2.slice(0, -1), n2([], { expandLastArg: true })]);
              });
            });
          } catch (e3) {
            if (e3 instanceof PC)
              return p2();
            throw e3;
          }
          return [c2.some(kC) ? NC : "", TC([["(", ...t3, ")"], f2 ? ["(", SC(t3[0], { shouldBreak: true }), ...t3.slice(1), ")"] : ["(", ...c2.slice(0, -1), SC(aC(t3), { shouldBreak: true }), ")"], p2()])];
        }
        const h2 = ["(", wC([xC, ...c2]), BC(l2), xC, ")"];
        return gC(e2) ? h2 : SC(h2, { shouldBreak: c2.some(kC) || o2 });
      };
      const { builders: { softline: jC, group: _C, indent: MC, label: RC } } = su, { isNumericLiteral: $C, isMemberExpression: VC, isCallExpression: WC } = eg, { printOptionalToken: qC } = _E;
      function UC(e2, t2, n2) {
        const r2 = n2("property"), i2 = e2.getValue(), u2 = qC(e2);
        return i2.computed ? !i2.property || $C(i2.property) ? [u2, "[", r2, "]"] : _C([u2, "[", MC([jC, r2]), jC, "]"]) : [u2, ".", r2];
      }
      var zC = { printMemberExpression: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = e2.getParentNode();
        let u2, o2 = 0;
        do {
          u2 = e2.getParentNode(o2), o2++;
        } while (u2 && (VC(u2) || u2.type === "TSNonNullExpression"));
        const s2 = n2("object"), a2 = UC(e2, t2, n2), c2 = u2 && (u2.type === "NewExpression" || u2.type === "BindExpression" || u2.type === "AssignmentExpression" && u2.left.type !== "Identifier") || r2.computed || r2.object.type === "Identifier" && r2.property.type === "Identifier" && !VC(i2) || (i2.type === "AssignmentExpression" || i2.type === "VariableDeclarator") && (WC(r2.object) && r2.object.arguments.length > 0 || r2.object.type === "TSNonNullExpression" && WC(r2.object.expression) && r2.object.expression.arguments.length > 0 || s2.label === "member-chain");
        return RC(s2.label === "member-chain" ? "member-chain" : "member", [s2, c2 ? a2 : _C(MC([jC, a2]))]);
      }, printMemberLookup: UC };
      const { printComments: GC } = Yf, { getLast: HC, isNextLineEmptyAfterIndex: JC, getNextNonSpaceNonCommentCharacterIndex: XC } = Fi, { isCallExpression: YC, isMemberExpression: KC, isFunctionOrArrowExpression: QC, isLongCurriedCallExpression: ZC, isMemberish: eb, isNumericLiteral: tb, isSimpleCallArgument: nb, hasComment: rb, CommentCheckFlags: ib, isNextLineEmpty: ub } = eg, { locEnd: ob } = Zc, { builders: { join: sb, hardline: ab, group: cb, indent: lb, conditionalGroup: pb, breakParent: fb, label: db }, utils: { willBreak: hb } } = su, { printMemberLookup: gb } = zC, { printOptionalToken: mb, printFunctionTypeParameters: yb, printBindExpressionCallee: Db } = _E;
      var Eb = function(e2, t2, n2) {
        const r2 = e2.getParentNode(), i2 = !r2 || r2.type === "ExpressionStatement", u2 = [];
        function o2(e3) {
          const { originalText: n3 } = t2, r3 = XC(n3, e3, ob);
          return n3.charAt(r3) === ")" ? r3 !== false && JC(n3, r3 + 1) : ub(e3, t2);
        }
        function s2(e3) {
          const r3 = e3.getValue();
          YC(r3) && (eb(r3.callee) || YC(r3.callee)) ? (u2.unshift({ node: r3, printed: [GC(e3, [mb(e3), yb(e3, t2, n2), LC(e3, t2, n2)], t2), o2(r3) ? ab : ""] }), e3.call((e4) => s2(e4), "callee")) : eb(r3) ? (u2.unshift({ node: r3, needsParens: oD(e3, t2), printed: GC(e3, KC(r3) ? gb(e3, t2, n2) : Db(e3, t2, n2), t2) }), e3.call((e4) => s2(e4), "object")) : r3.type === "TSNonNullExpression" ? (u2.unshift({ node: r3, printed: GC(e3, "!", t2) }), e3.call((e4) => s2(e4), "expression")) : u2.unshift({ node: r3, printed: n2() });
        }
        const a2 = e2.getValue();
        u2.unshift({ node: a2, printed: [mb(e2), yb(e2, t2, n2), LC(e2, t2, n2)] }), a2.callee && e2.call((e3) => s2(e3), "callee");
        const c2 = [];
        let l2 = [u2[0]], p2 = 1;
        for (; p2 < u2.length && (u2[p2].node.type === "TSNonNullExpression" || YC(u2[p2].node) || KC(u2[p2].node) && u2[p2].node.computed && tb(u2[p2].node.property)); ++p2)
          l2.push(u2[p2]);
        if (!YC(u2[0].node))
          for (; p2 + 1 < u2.length && (eb(u2[p2].node) && eb(u2[p2 + 1].node)); ++p2)
            l2.push(u2[p2]);
        c2.push(l2), l2 = [];
        let f2 = false;
        for (; p2 < u2.length; ++p2) {
          if (f2 && eb(u2[p2].node)) {
            if (u2[p2].node.computed && tb(u2[p2].node.property)) {
              l2.push(u2[p2]);
              continue;
            }
            c2.push(l2), l2 = [], f2 = false;
          }
          (YC(u2[p2].node) || u2[p2].node.type === "ImportExpression") && (f2 = true), l2.push(u2[p2]), rb(u2[p2].node, ib.Trailing) && (c2.push(l2), l2 = [], f2 = false);
        }
        function d2(e3) {
          return /^[A-Z]|^[$_]+$/.test(e3);
        }
        l2.length > 0 && c2.push(l2);
        const h2 = c2.length >= 2 && !rb(c2[1][0].node) && function(e3) {
          const n3 = e3[1].length > 0 && e3[1][0].node.computed;
          if (e3[0].length === 1) {
            const r4 = e3[0][0].node;
            return r4.type === "ThisExpression" || r4.type === "Identifier" && (d2(r4.name) || i2 && function(e4) {
              return e4.length <= t2.tabWidth;
            }(r4.name) || n3);
          }
          const r3 = HC(e3[0]).node;
          return KC(r3) && r3.property.type === "Identifier" && (d2(r3.property.name) || n3);
        }(c2);
        function g2(e3) {
          const t3 = e3.map((e4) => e4.printed);
          return e3.length > 0 && HC(e3).needsParens ? ["(", ...t3, ")"] : t3;
        }
        const m2 = c2.map(g2), y2 = m2, D2 = h2 ? 3 : 2, E2 = c2.flat(), C2 = E2.slice(1, -1).some((e3) => rb(e3.node, ib.Leading)) || E2.slice(0, -1).some((e3) => rb(e3.node, ib.Trailing)) || c2[D2] && rb(c2[D2][0].node, ib.Leading);
        if (c2.length <= D2 && !C2)
          return ZC(e2) ? y2 : cb(y2);
        const b2 = HC(c2[h2 ? 1 : 0]).node, A2 = !YC(b2) && o2(b2), v2 = [g2(c2[0]), h2 ? c2.slice(1, 2).map(g2) : "", A2 ? ab : "", function(e3) {
          return e3.length === 0 ? "" : lb(cb([ab, sb(ab, e3.map(g2))]));
        }(c2.slice(h2 ? 2 : 1))], F2 = u2.map(({ node: e3 }) => e3).filter(YC);
        let x2;
        return x2 = C2 || F2.length > 2 && F2.some((e3) => !e3.arguments.every((e4) => nb(e4, 0))) || m2.slice(0, -1).some(hb) || function() {
          const e3 = HC(HC(c2)).node, t3 = HC(m2);
          return YC(e3) && hb(t3) && F2.slice(0, -1).some((e4) => e4.arguments.some(QC));
        }() ? cb(v2) : [hb(y2) || A2 ? fb : "", pb([y2, v2])], db("member-chain", x2);
      };
      const { builders: { join: Cb, group: bb } } = su, { getCallArguments: Ab, hasFlowAnnotationComment: vb, isCallExpression: Fb, isMemberish: xb, isStringLiteral: Sb, isTemplateOnItsOwnLine: wb, isTestCall: Tb, iterateCallArgumentsPath: Bb } = eg, { printOptionalToken: Nb, printFunctionTypeParameters: kb } = _E;
      var Pb = { printCallExpression: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = e2.getParentNode(), u2 = r2.type === "NewExpression", o2 = r2.type === "ImportExpression", s2 = Nb(e2), a2 = Ab(r2);
        if (a2.length > 0 && (!o2 && !u2 && function(e3, t3) {
          if (e3.callee.type !== "Identifier")
            return false;
          if (e3.callee.name === "require")
            return true;
          if (e3.callee.name === "define") {
            const n3 = Ab(e3);
            return t3.type === "ExpressionStatement" && (n3.length === 1 || n3.length === 2 && n3[0].type === "ArrayExpression" || n3.length === 3 && Sb(n3[0]) && n3[1].type === "ArrayExpression");
          }
          return false;
        }(r2, i2) || a2.length === 1 && wb(a2[0], t2.originalText) || !u2 && Tb(r2, i2))) {
          const r3 = [];
          return Bb(e2, () => {
            r3.push(n2());
          }), [u2 ? "new " : "", n2("callee"), s2, kb(e2, t2, n2), "(", Cb(", ", r3), ")"];
        }
        const c2 = (t2.parser === "babel" || t2.parser === "babel-flow") && r2.callee && r2.callee.type === "Identifier" && vb(r2.callee.trailingComments);
        if (c2 && (r2.callee.trailingComments[0].printed = true), !o2 && !u2 && xb(r2.callee) && !e2.call((e3) => oD(e3, t2), "callee"))
          return Eb(e2, t2, n2);
        const l2 = [u2 ? "new " : "", o2 ? "import" : n2("callee"), s2, c2 ? `/*:: ${r2.callee.trailingComments[0].value.slice(2).trim()} */` : "", kb(e2, t2, n2), LC(e2, t2, n2)];
        return o2 || Fb(r2.callee) ? bb(l2) : l2;
      } };
      const { isNonEmptyArray: Ob, getStringWidth: Ib } = Fi, { builders: { line: Lb, group: jb, indent: _b, indentIfBreak: Mb }, utils: { cleanDoc: Rb, willBreak: $b } } = su, { hasLeadingOwnLineComment: Vb, isBinaryish: Wb, isStringLiteral: qb, isLiteral: Ub, isNumericLiteral: zb, isCallExpression: Gb, isMemberExpression: Hb, getCallArguments: Jb, rawText: Xb, hasComment: Yb, isSignedNumericLiteral: Kb, isObjectProperty: Qb } = eg, { shouldInlineLogicalExpression: Zb } = RD, { printCallExpression: eA } = Pb;
      function tA(e2, t2, n2, r2, i2, u2) {
        const o2 = function(e3, t3, n3, r3, i3) {
          const u3 = e3.getValue(), o3 = u3[i3];
          if (!o3)
            return "only-left";
          const s3 = !nA(o3);
          if (e3.match(nA, rA, (e4) => !s3 || e4.type !== "ExpressionStatement" && e4.type !== "VariableDeclaration"))
            return s3 ? o3.type === "ArrowFunctionExpression" && o3.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
          if (!s3 && nA(o3.right) || Vb(t3.originalText, o3))
            return "break-after-operator";
          if (o3.type === "CallExpression" && o3.callee.name === "require" || t3.parser === "json5" || t3.parser === "json")
            return "never-break-after-operator";
          if (function(e4) {
            if (rA(e4)) {
              const t4 = e4.left || e4.id;
              return t4.type === "ObjectPattern" && t4.properties.length > 2 && t4.properties.some((e5) => Qb(e5) && (!e5.shorthand || e5.value && e5.value.type === "AssignmentPattern"));
            }
            return false;
          }(u3) || function(e4) {
            const t4 = function(e5) {
              if (function(e6) {
                return e6.type === "TSTypeAliasDeclaration" || e6.type === "TypeAlias";
              }(e5) && e5.typeParameters && e5.typeParameters.params)
                return e5.typeParameters.params;
              return null;
            }(e4);
            if (Ob(t4)) {
              const n4 = e4.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
              if (t4.length > 1 && t4.some((e5) => e5[n4] || e5.default))
                return true;
            }
            return false;
          }(u3) || function(e4) {
            if (e4.type !== "VariableDeclarator")
              return false;
            const { typeAnnotation: t4 } = e4.id;
            if (!t4 || !t4.typeAnnotation)
              return false;
            const n4 = iA(t4.typeAnnotation);
            return Ob(n4) && n4.length > 1 && n4.some((e5) => Ob(iA(e5)) || e5.type === "TSConditionalType");
          }(u3))
            return "break-lhs";
          const a2 = function(e4, t4, n4) {
            if (!Qb(e4))
              return false;
            t4 = Rb(t4);
            const r4 = 3;
            return typeof t4 == "string" && Ib(t4) < n4.tabWidth + r4;
          }(u3, r3, t3);
          if (e3.call(() => function(e4, t4, n4, r4) {
            const i4 = e4.getValue();
            if (Wb(i4) && !Zb(i4))
              return true;
            switch (i4.type) {
              case "StringLiteralTypeAnnotation":
              case "SequenceExpression":
                return true;
              case "ConditionalExpression": {
                const { test: e5 } = i4;
                return Wb(e5) && !Zb(e5);
              }
              case "ClassExpression":
                return Ob(i4.decorators);
            }
            if (r4)
              return false;
            let u4 = i4;
            const o4 = [];
            for (; ; )
              if (u4.type === "UnaryExpression")
                u4 = u4.argument, o4.push("argument");
              else {
                if (u4.type !== "TSNonNullExpression")
                  break;
                u4 = u4.expression, o4.push("expression");
              }
            if (qb(u4) || e4.call(() => uA(e4, t4, n4), ...o4))
              return true;
            return false;
          }(e3, t3, n3, a2), i3))
            return "break-after-operator";
          if (a2 || o3.type === "TemplateLiteral" || o3.type === "TaggedTemplateExpression" || o3.type === "BooleanLiteral" || zb(o3) || o3.type === "ClassExpression")
            return "never-break-after-operator";
          return "fluid";
        }(e2, t2, n2, r2, u2), s2 = n2(u2, { assignmentLayout: o2 });
        switch (o2) {
          case "break-after-operator":
            return jb([jb(r2), i2, jb(_b([Lb, s2]))]);
          case "never-break-after-operator":
            return jb([jb(r2), i2, " ", s2]);
          case "fluid": {
            const e3 = Symbol("assignment");
            return jb([jb(r2), i2, jb(_b(Lb), { id: e3 }), Mb(s2, { groupId: e3 })]);
          }
          case "break-lhs":
            return jb([r2, i2, " ", jb(s2)]);
          case "chain":
            return [jb(r2), i2, Lb, s2];
          case "chain-tail":
            return [jb(r2), i2, _b([Lb, s2])];
          case "chain-tail-arrow-chain":
            return [jb(r2), i2, s2];
          case "only-left":
            return r2;
        }
      }
      function nA(e2) {
        return e2.type === "AssignmentExpression";
      }
      function rA(e2) {
        return nA(e2) || e2.type === "VariableDeclarator";
      }
      function iA(e2) {
        return function(e3) {
          return e3.type === "TSTypeReference" || e3.type === "GenericTypeAnnotation";
        }(e2) && e2.typeParameters && e2.typeParameters.params ? e2.typeParameters.params : null;
      }
      function uA(e2, t2, n2, r2 = false) {
        const i2 = e2.getValue(), u2 = () => uA(e2, t2, n2, true);
        if (i2.type === "TSNonNullExpression")
          return e2.call(u2, "expression");
        if (Gb(i2)) {
          if (eA(e2, t2, n2).label === "member-chain")
            return false;
          const r3 = Jb(i2);
          return !!(r3.length === 0 || r3.length === 1 && function(e3, { printWidth: t3 }) {
            if (Yb(e3))
              return false;
            const n3 = 0.25 * t3;
            if (e3.type === "ThisExpression" || e3.type === "Identifier" && e3.name.length <= n3 || Kb(e3) && !Yb(e3.argument))
              return true;
            const r4 = e3.type === "Literal" && "regex" in e3 && e3.regex.pattern || e3.type === "RegExpLiteral" && e3.pattern;
            if (r4)
              return r4.length <= n3;
            if (qb(e3))
              return Xb(e3).length <= n3;
            if (e3.type === "TemplateLiteral")
              return e3.expressions.length === 0 && e3.quasis[0].value.raw.length <= n3 && !e3.quasis[0].value.raw.includes("\n");
            return Ub(e3);
          }(r3[0], t2)) && (!function(e3, t3) {
            const n3 = function(e4) {
              return e4.typeParameters && e4.typeParameters.params || e4.typeArguments && e4.typeArguments.params;
            }(e3);
            if (Ob(n3)) {
              if (n3.length > 1)
                return true;
              if (n3.length === 1) {
                const e4 = n3[0];
                if (e4.type === "TSUnionType" || e4.type === "UnionTypeAnnotation" || e4.type === "TSIntersectionType" || e4.type === "IntersectionTypeAnnotation")
                  return true;
              }
              const r4 = e3.typeParameters ? "typeParameters" : "typeArguments";
              if ($b(t3(r4)))
                return true;
            }
            return false;
          }(i2, n2) && e2.call(u2, "callee"));
        }
        return Hb(i2) ? e2.call(u2, "object") : r2 && (i2.type === "Identifier" || i2.type === "ThisExpression");
      }
      var oA = { printVariableDeclarator: function(e2, t2, n2) {
        return tA(e2, t2, n2, n2("id"), " =", "init");
      }, printAssignmentExpression: function(e2, t2, n2) {
        const r2 = e2.getValue();
        return tA(e2, t2, n2, n2("left"), [" ", r2.operator], "right");
      }, printAssignment: tA };
      const { getNextNonSpaceNonCommentCharacter: sA } = Fi, { printDanglingComments: aA } = Yf, { builders: { line: cA, hardline: lA, softline: pA, group: fA, indent: dA, ifBreak: hA }, utils: { removeLines: gA, willBreak: mA } } = su, { getFunctionParameters: yA, iterateFunctionParametersPath: DA, isSimpleType: EA, isTestCall: CA, isTypeAnnotationAFunction: bA, isObjectType: AA, isObjectTypePropertyAFunction: vA, hasRestParameter: FA, shouldPrintComma: xA, hasComment: SA, isNextLineEmpty: wA } = eg, { locEnd: TA } = Zc, { ArgExpansionBailout: BA } = Bo, { printFunctionTypeParameters: NA } = _E;
      function kA(e2) {
        if (!e2)
          return false;
        const t2 = yA(e2);
        if (t2.length !== 1)
          return false;
        const [n2] = t2;
        return !SA(n2) && (n2.type === "ObjectPattern" || n2.type === "ArrayPattern" || n2.type === "Identifier" && n2.typeAnnotation && (n2.typeAnnotation.type === "TypeAnnotation" || n2.typeAnnotation.type === "TSTypeAnnotation") && AA(n2.typeAnnotation.typeAnnotation) || n2.type === "FunctionTypeParam" && AA(n2.typeAnnotation) || n2.type === "AssignmentPattern" && (n2.left.type === "ObjectPattern" || n2.left.type === "ArrayPattern") && (n2.right.type === "Identifier" || n2.right.type === "ObjectExpression" && n2.right.properties.length === 0 || n2.right.type === "ArrayExpression" && n2.right.elements.length === 0));
      }
      var PA = { printFunctionParameters: function(e2, t2, n2, r2, i2) {
        const u2 = e2.getValue(), o2 = yA(u2), s2 = i2 ? NA(e2, n2, t2) : "";
        if (o2.length === 0)
          return [s2, "(", aA(e2, n2, true, (e3) => sA(n2.originalText, e3, TA) === ")"), ")"];
        const a2 = e2.getParentNode(), c2 = CA(a2), l2 = kA(u2), p2 = [];
        if (DA(e2, (e3, r3) => {
          const i3 = r3 === o2.length - 1;
          i3 && u2.rest && p2.push("..."), p2.push(t2()), i3 || (p2.push(","), c2 || l2 ? p2.push(" ") : wA(o2[r3], n2) ? p2.push(lA, lA) : p2.push(cA));
        }), r2) {
          if (mA(s2) || mA(p2))
            throw new BA();
          return fA([gA(s2), "(", gA(p2), ")"]);
        }
        const f2 = o2.every((e3) => !e3.decorators);
        return l2 && f2 || c2 ? [s2, "(", ...p2, ")"] : (vA(a2) || bA(a2) || a2.type === "TypeAlias" || a2.type === "UnionTypeAnnotation" || a2.type === "TSUnionType" || a2.type === "IntersectionTypeAnnotation" || a2.type === "FunctionTypeAnnotation" && a2.returnType === u2) && o2.length === 1 && o2[0].name === null && u2.this !== o2[0] && o2[0].typeAnnotation && u2.typeParameters === null && EA(o2[0].typeAnnotation) && !u2.rest ? n2.arrowParens === "always" ? ["(", ...p2, ")"] : p2 : [s2, "(", dA([pA, ...p2]), hA(!FA(u2) && xA(n2, "all") ? "," : ""), pA, ")"];
      }, shouldHugFunctionParameters: kA, shouldGroupFunctionParameters: function(e2, t2) {
        const n2 = function(e3) {
          let t3;
          return e3.returnType ? (t3 = e3.returnType, t3.typeAnnotation && (t3 = t3.typeAnnotation)) : e3.typeAnnotation && (t3 = e3.typeAnnotation), t3;
        }(e2);
        if (!n2)
          return false;
        const r2 = e2.typeParameters && e2.typeParameters.params;
        if (r2) {
          if (r2.length > 1)
            return false;
          if (r2.length === 1) {
            const e3 = r2[0];
            if (e3.constraint || e3.default)
              return false;
          }
        }
        return yA(e2).length === 1 && (AA(n2) || mA(t2));
      } };
      const { printComments: OA, printDanglingComments: IA } = Yf, { getLast: LA } = Fi, { builders: { group: jA, join: _A, line: MA, softline: RA, indent: $A, align: VA, ifBreak: WA } } = su, { locStart: qA } = Zc, { isSimpleType: UA, isObjectType: zA, hasLeadingOwnLineComment: GA, isObjectTypePropertyAFunction: HA, shouldPrintComma: JA } = eg, { printAssignment: XA } = oA, { printFunctionParameters: YA, shouldGroupFunctionParameters: KA } = PA, { printArrayItems: QA } = oC;
      function ZA(e2) {
        if (UA(e2) || zA(e2))
          return true;
        if (e2.type === "UnionTypeAnnotation" || e2.type === "TSUnionType") {
          const t2 = e2.types.filter((e3) => e3.type === "VoidTypeAnnotation" || e3.type === "TSVoidKeyword" || e3.type === "NullLiteralTypeAnnotation" || e3.type === "TSNullKeyword").length, n2 = e2.types.some((e3) => e3.type === "ObjectTypeAnnotation" || e3.type === "TSTypeLiteral" || e3.type === "GenericTypeAnnotation" || e3.type === "TSTypeReference");
          if (e2.types.length - 1 === t2 && n2)
            return true;
        }
        return false;
      }
      var ev = { printOpaqueType: function(e2, t2, n2) {
        const r2 = t2.semi ? ";" : "", i2 = e2.getValue(), u2 = [];
        return u2.push("opaque type ", n2("id"), n2("typeParameters")), i2.supertype && u2.push(": ", n2("supertype")), i2.impltype && u2.push(" = ", n2("impltype")), u2.push(r2), u2;
      }, printTypeAlias: function(e2, t2, n2) {
        const r2 = t2.semi ? ";" : "", i2 = e2.getValue(), u2 = [];
        i2.declare && u2.push("declare "), u2.push("type ", n2("id"), n2("typeParameters"));
        const o2 = i2.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
        return [XA(e2, t2, n2, u2, " =", o2), r2];
      }, printIntersectionType: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = e2.map(n2, "types"), u2 = [];
        let o2 = false;
        for (let e3 = 0; e3 < i2.length; ++e3)
          e3 === 0 ? u2.push(i2[e3]) : zA(r2.types[e3 - 1]) && zA(r2.types[e3]) ? u2.push([" & ", o2 ? $A(i2[e3]) : i2[e3]]) : zA(r2.types[e3 - 1]) || zA(r2.types[e3]) ? (e3 > 1 && (o2 = true), u2.push(" & ", e3 > 1 ? $A(i2[e3]) : i2[e3])) : u2.push($A([" &", MA, i2[e3]]));
        return jA(u2);
      }, printUnionType: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = e2.getParentNode(), u2 = !(i2.type === "TypeParameterInstantiation" || i2.type === "TSTypeParameterInstantiation" || i2.type === "GenericTypeAnnotation" || i2.type === "TSTypeReference" || i2.type === "TSTypeAssertion" || i2.type === "TupleTypeAnnotation" || i2.type === "TSTupleType" || i2.type === "FunctionTypeParam" && !i2.name && e2.getParentNode(1).this !== i2 || (i2.type === "TypeAlias" || i2.type === "VariableDeclarator" || i2.type === "TSTypeAliasDeclaration") && GA(t2.originalText, r2)), o2 = ZA(r2), s2 = e2.map((e3) => {
          let r3 = n2();
          return o2 || (r3 = VA(2, r3)), OA(e3, r3, t2);
        }, "types");
        if (o2)
          return _A(" | ", s2);
        const a2 = u2 && !GA(t2.originalText, r2), c2 = [WA([a2 ? MA : "", "| "]), _A([MA, "| "], s2)];
        return oD(e2, t2) ? jA([$A(c2), RA]) : i2.type === "TupleTypeAnnotation" && i2.types.length > 1 || i2.type === "TSTupleType" && i2.elementTypes.length > 1 ? jA([$A([WA(["(", RA]), c2]), RA, WA(")")]) : jA(u2 ? $A(c2) : c2);
      }, printFunctionType: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = [], u2 = e2.getParentNode(0), o2 = e2.getParentNode(1), s2 = e2.getParentNode(2);
        let a2 = r2.type === "TSFunctionType" || !((u2.type === "ObjectTypeProperty" || u2.type === "ObjectTypeInternalSlot") && !u2.variance && !u2.optional && qA(u2) === qA(r2) || u2.type === "ObjectTypeCallProperty" || s2 && s2.type === "DeclareFunction"), c2 = a2 && (u2.type === "TypeAnnotation" || u2.type === "TSTypeAnnotation");
        const l2 = c2 && a2 && (u2.type === "TypeAnnotation" || u2.type === "TSTypeAnnotation") && o2.type === "ArrowFunctionExpression";
        HA(u2) && (a2 = true, c2 = true), l2 && i2.push("(");
        const p2 = YA(e2, n2, t2, false, true), f2 = r2.returnType || r2.predicate || r2.typeAnnotation ? [a2 ? " => " : ": ", n2("returnType"), n2("predicate"), n2("typeAnnotation")] : "", d2 = KA(r2, f2);
        return i2.push(d2 ? jA(p2) : p2), f2 && i2.push(f2), l2 && i2.push(")"), jA(i2);
      }, printTupleType: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = r2.type === "TSTupleType" ? "elementTypes" : "types", u2 = r2[i2].length > 0 && LA(r2[i2]).type === "TSRestType";
        return jA(["[", $A([RA, QA(e2, t2, i2, n2)]), WA(JA(t2, "all") && !u2 ? "," : ""), IA(e2, t2, true), RA, "]"]);
      }, printIndexedAccessType: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = r2.type === "OptionalIndexedAccessType" && r2.optional ? "?.[" : "[";
        return [n2("objectType"), i2, n2("indexType"), "]"];
      }, shouldHugType: ZA };
      const { printDanglingComments: tv } = Yf, { builders: { join: nv, line: rv, hardline: iv, softline: uv, group: ov, indent: sv, ifBreak: av } } = su, { isTestCall: cv, hasComment: lv, CommentCheckFlags: pv, isTSXFile: fv, shouldPrintComma: dv, getFunctionParameters: hv } = eg, { createGroupIdMapper: gv } = Fi, { shouldHugType: mv } = ev, yv = gv("typeParameters");
      function Dv(e2, t2) {
        const n2 = e2.getValue();
        if (!lv(n2, pv.Dangling))
          return "";
        const r2 = !lv(n2, pv.Line), i2 = tv(e2, t2, r2);
        return r2 ? i2 : [i2, iv];
      }
      var Ev = { printTypeParameter: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = [], u2 = e2.getParentNode();
        return u2.type === "TSMappedType" ? (i2.push("[", n2("name")), r2.constraint && i2.push(" in ", n2("constraint")), u2.nameType && i2.push(" as ", e2.callParent(() => n2("nameType"))), i2.push("]"), i2) : (r2.variance && i2.push(n2("variance")), i2.push(n2("name")), r2.bound && i2.push(": ", n2("bound")), r2.constraint && i2.push(" extends ", n2("constraint")), r2.default && i2.push(" = ", n2("default")), i2);
      }, printTypeParameters: function(e2, t2, n2, r2) {
        const i2 = e2.getValue();
        if (!i2[r2])
          return "";
        if (!Array.isArray(i2[r2]))
          return n2(r2);
        const u2 = e2.getNode(2);
        if (u2 && cv(u2) || i2[r2].length === 0 || i2[r2].length === 1 && (mv(i2[r2][0]) || i2[r2][0].type === "NullableTypeAnnotation"))
          return ["<", nv(", ", e2.map(n2, r2)), Dv(e2, t2), ">"];
        const o2 = i2.type === "TSTypeParameterInstantiation" ? "" : hv(i2).length === 1 && fv(t2) && !i2[r2][0].constraint && e2.getParentNode().type === "ArrowFunctionExpression" ? "," : dv(t2, "all") ? av(",") : "";
        return ov(["<", sv([uv, nv([",", rv], e2.map(n2, r2))]), o2, uv, ">"], { id: yv(i2) });
      }, getTypeParametersGroupId: yv };
      const { printComments: Cv } = Yf, { printString: bv, printNumber: Av } = Fi, { isNumericLiteral: vv, isSimpleNumber: Fv, isStringLiteral: xv, isStringPropSafeToUnquote: Sv, rawText: wv } = eg, { printAssignment: Tv } = oA, Bv = new WeakMap();
      function Nv(e2, t2, n2) {
        const r2 = e2.getNode();
        if (r2.computed)
          return ["[", n2("key"), "]"];
        const i2 = e2.getParentNode(), { key: u2 } = r2;
        if (r2.type === "ClassPrivateProperty" && u2.type === "Identifier")
          return ["#", n2("key")];
        if (t2.quoteProps === "consistent" && !Bv.has(i2)) {
          const e3 = (i2.properties || i2.body || i2.members).some((e4) => !e4.computed && e4.key && xv(e4.key) && !Sv(e4, t2));
          Bv.set(i2, e3);
        }
        if ((u2.type === "Identifier" || vv(u2) && Fv(Av(wv(u2))) && String(u2.value) === Av(wv(u2)) && t2.parser !== "typescript" && t2.parser !== "babel-ts") && (t2.parser === "json" || t2.quoteProps === "consistent" && Bv.get(i2))) {
          const n3 = bv(JSON.stringify(u2.type === "Identifier" ? u2.name : u2.value.toString()), t2);
          return e2.call((e3) => Cv(e3, n3, t2), "key");
        }
        return Sv(r2, t2) && (t2.quoteProps === "as-needed" || t2.quoteProps === "consistent" && !Bv.get(i2)) ? e2.call((e3) => Cv(e3, /^\d/.test(u2.value) ? Av(u2.value) : u2.value, t2), "key") : n2("key");
      }
      var kv = { printProperty: function(e2, t2, n2) {
        return e2.getValue().shorthand ? n2("value") : Tv(e2, t2, n2, Nv(e2, t2, n2), ":", "value");
      }, printPropertyKey: Nv };
      const { printDanglingComments: Pv, printCommentsSeparately: Ov } = Yf, { getNextNonSpaceNonCommentCharacterIndex: Iv } = Fi, { builders: { line: Lv, softline: jv, group: _v, indent: Mv, ifBreak: Rv, hardline: $v, join: Vv, indentIfBreak: Wv }, utils: { removeLines: qv, willBreak: Uv } } = su, { ArgExpansionBailout: zv } = Bo, { getFunctionParameters: Gv, hasLeadingOwnLineComment: Hv, isFlowAnnotationComment: Jv, isJsxNode: Xv, isTemplateOnItsOwnLine: Yv, shouldPrintComma: Kv, startsWithNoLookaheadToken: Qv, isBinaryish: Zv, isLineComment: eF, hasComment: tF, getComments: nF, CommentCheckFlags: rF, isCallLikeExpression: iF, isCallExpression: uF, getCallArguments: oF, hasNakedLeftSide: sF, getLeftSide: aF } = eg, { locEnd: cF } = Zc, { printFunctionParameters: lF, shouldGroupFunctionParameters: pF } = PA, { printPropertyKey: fF } = kv, { printFunctionTypeParameters: dF } = _E;
      function hF(e2, t2, n2) {
        const r2 = e2.getNode(), i2 = lF(e2, n2, t2), u2 = mF(e2, n2, t2), o2 = pF(r2, u2), s2 = [dF(e2, t2, n2), _v([o2 ? _v(i2) : i2, u2])];
        return r2.body ? s2.push(" ", n2("body")) : s2.push(t2.semi ? ";" : ""), s2;
      }
      function gF(e2, t2) {
        if (t2.arrowParens === "always")
          return false;
        if (t2.arrowParens === "avoid") {
          return function(e3) {
            const t3 = Gv(e3);
            return !(t3.length !== 1 || e3.typeParameters || tF(e3, rF.Dangling) || t3[0].type !== "Identifier" || t3[0].typeAnnotation || tF(t3[0]) || t3[0].optional || e3.predicate || e3.returnType);
          }(e2.getValue());
        }
        return false;
      }
      function mF(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = t2("returnType");
        if (r2.returnType && Jv(n2.originalText, r2.returnType))
          return [" /*: ", i2, " */"];
        const u2 = [i2];
        return r2.returnType && r2.returnType.typeAnnotation && u2.unshift(": "), r2.predicate && u2.push(r2.returnType ? " " : ": ", t2("predicate")), u2;
      }
      function yF(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = t2.semi ? ";" : "", u2 = [];
        r2.argument && (!function(e3, t3) {
          if (Hv(e3.originalText, t3))
            return true;
          if (sF(t3)) {
            let n3, r3 = t3;
            for (; n3 = aF(r3); )
              if (r3 = n3, Hv(e3.originalText, r3))
                return true;
          }
          return false;
        }(t2, r2.argument) ? Zv(r2.argument) || r2.argument.type === "SequenceExpression" ? u2.push(_v([Rv(" (", " "), Mv([jv, n2("argument")]), jv, Rv(")")])) : u2.push(" ", n2("argument")) : u2.push([" (", Mv([$v, n2("argument")]), $v, ")"]));
        const o2 = nF(r2), s2 = _n(o2), a2 = s2 && eF(s2);
        return a2 && u2.push(i2), tF(r2, rF.Dangling) && u2.push(" ", Pv(e2, t2, true)), a2 || u2.push(i2), u2;
      }
      var DF = { printFunction: function(e2, t2, n2, r2) {
        const i2 = e2.getValue();
        let u2 = false;
        if ((i2.type === "FunctionDeclaration" || i2.type === "FunctionExpression") && r2 && r2.expandLastArg) {
          const t3 = e2.getParentNode();
          uF(t3) && oF(t3).length > 1 && (u2 = true);
        }
        const o2 = [];
        i2.type === "TSDeclareFunction" && i2.declare && o2.push("declare "), i2.async && o2.push("async "), i2.generator ? o2.push("function* ") : o2.push("function "), i2.id && o2.push(t2("id"));
        const s2 = lF(e2, t2, n2, u2), a2 = mF(e2, t2, n2), c2 = pF(i2, a2);
        return o2.push(dF(e2, n2, t2), _v([c2 ? _v(s2) : s2, a2]), i2.body ? " " : "", t2("body")), !n2.semi || !i2.declare && i2.body || o2.push(";"), o2;
      }, printArrowFunction: function(e2, t2, n2, r2) {
        let i2 = e2.getValue();
        const u2 = [], o2 = [];
        let s2 = false;
        if (function a3() {
          const c3 = function(e3, t3, n3, r3) {
            const i3 = [];
            if (e3.getValue().async && i3.push("async "), gF(e3, t3))
              i3.push(n3(["params", 0]));
            else {
              const u4 = r3 && (r3.expandLastArg || r3.expandFirstArg);
              let o3 = mF(e3, n3, t3);
              if (u4) {
                if (Uv(o3))
                  throw new zv();
                o3 = _v(qv(o3));
              }
              i3.push(_v([lF(e3, n3, t3, u4, true), o3]));
            }
            const u3 = Pv(e3, t3, true, (e4) => {
              const n4 = Iv(t3.originalText, e4, cF);
              return n4 !== false && t3.originalText.slice(n4, n4 + 2) === "=>";
            });
            return u3 && i3.push(" ", u3), i3;
          }(e2, t2, n2, r2);
          if (u2.length === 0)
            u2.push(c3);
          else {
            const { leading: n3, trailing: r3 } = Ov(e2, t2);
            u2.push([n3, c3]), o2.unshift(r3);
          }
          s2 = s2 || i2.returnType && Gv(i2).length > 0 || i2.typeParameters || Gv(i2).some((e3) => e3.type !== "Identifier"), i2.body.type !== "ArrowFunctionExpression" || r2 && r2.expandLastArg ? o2.unshift(n2("body", r2)) : (i2 = i2.body, e2.call(a3, "body"));
        }(), u2.length > 1)
          return function(e3, t3, n3, r3, i3, u3) {
            const o3 = e3.getName(), s3 = e3.getParentNode(), a3 = iF(s3) && o3 === "callee", c3 = Boolean(t3 && t3.assignmentLayout), l3 = u3.body.type !== "BlockStatement" && u3.body.type !== "ObjectExpression", p3 = a3 && l3 || t3 && t3.assignmentLayout === "chain-tail-arrow-chain", f2 = Symbol("arrow-chain");
            return _v([_v(Mv([a3 || c3 ? jv : "", _v(Vv([" =>", Lv], n3), { shouldBreak: r3 })]), { id: f2, shouldBreak: p3 }), " =>", Wv(l3 ? Mv([Lv, i3]) : [" ", i3], { groupId: f2 }), a3 ? Rv(jv, "", { groupId: f2 }) : ""]);
          }(e2, r2, u2, s2, o2, i2);
        const a2 = u2;
        if (a2.push(" =>"), !Hv(t2.originalText, i2.body) && (i2.body.type === "ArrayExpression" || i2.body.type === "ObjectExpression" || i2.body.type === "BlockStatement" || Xv(i2.body) || Yv(i2.body, t2.originalText) || i2.body.type === "ArrowFunctionExpression" || i2.body.type === "DoExpression"))
          return _v([...a2, " ", o2]);
        if (i2.body.type === "SequenceExpression")
          return _v([...a2, _v([" (", Mv([jv, o2]), jv, ")"])]);
        const c2 = (r2 && r2.expandLastArg || e2.getParentNode().type === "JSXExpressionContainer") && !tF(i2), l2 = r2 && r2.expandLastArg && Kv(t2, "all"), p2 = i2.body.type === "ConditionalExpression" && !Qv(i2.body, false);
        return _v([...a2, _v([Mv([Lv, p2 ? Rv("", "(") : "", o2, p2 ? Rv("", ")") : ""]), c2 ? [Rv(l2 ? "," : ""), jv] : ""])]);
      }, printMethod: function(e2, t2, n2) {
        const r2 = e2.getNode(), { kind: i2 } = r2, u2 = r2.value || r2, o2 = [];
        return i2 && i2 !== "init" && i2 !== "method" && i2 !== "constructor" ? (Ff.ok(i2 === "get" || i2 === "set"), o2.push(i2, " ")) : u2.async && o2.push("async "), u2.generator && o2.push("*"), o2.push(fF(e2, t2, n2), r2.optional || r2.key.optional ? "?" : ""), r2 === u2 ? o2.push(hF(e2, t2, n2)) : u2.type === "FunctionExpression" ? o2.push(e2.call((e3) => hF(e3, t2, n2), "value")) : o2.push(n2("value")), o2;
      }, printReturnStatement: function(e2, t2, n2) {
        return ["return", yF(e2, t2, n2)];
      }, printThrowStatement: function(e2, t2, n2) {
        return ["throw", yF(e2, t2, n2)];
      }, printMethodInternal: hF, shouldPrintParamsWithoutParens: gF };
      const { isNonEmptyArray: EF, hasNewline: CF } = Fi, { builders: { line: bF, hardline: AF, join: vF, breakParent: FF, group: xF } } = su, { locStart: SF, locEnd: wF } = Zc, { getParentExportDeclaration: TF } = eg;
      function BF(e2, t2) {
        return e2.decorators.some((e3) => CF(t2.originalText, wF(e3)));
      }
      function NF(e2) {
        if (e2.type !== "ExportDefaultDeclaration" && e2.type !== "ExportNamedDeclaration" && e2.type !== "DeclareExportDeclaration")
          return false;
        const t2 = e2.declaration && e2.declaration.decorators;
        return EF(t2) && SF(e2, { ignoreDecorators: true }) > SF(t2[0]);
      }
      var kF = { printDecorators: function(e2, t2, n2) {
        const r2 = e2.getValue(), { decorators: i2 } = r2;
        if (!EF(i2) || NF(e2.getParentNode()))
          return;
        const u2 = r2.type === "ClassExpression" || r2.type === "ClassDeclaration" || BF(r2, t2);
        return [TF(e2) ? AF : u2 ? FF : "", vF(bF, e2.map(n2, "decorators")), bF];
      }, printClassMemberDecorators: function(e2, t2, n2) {
        const r2 = e2.getValue();
        return xF([vF(bF, e2.map(n2, "decorators")), BF(r2, t2) ? AF : bF]);
      }, printDecoratorsBeforeExport: function(e2, t2, n2) {
        return [vF(AF, e2.map(n2, "declaration", "decorators")), AF];
      }, hasDecoratorsBeforeExport: NF };
      const { isNonEmptyArray: PF, createGroupIdMapper: OF } = Fi, { printComments: IF, printDanglingComments: LF } = Yf, { builders: { join: jF, line: _F, hardline: MF, softline: RF, group: $F, indent: VF, ifBreak: WF } } = su, { hasComment: qF, CommentCheckFlags: UF } = eg, { getTypeParametersGroupId: zF } = Ev, { printMethod: GF } = DF, { printOptionalToken: HF, printTypeAnnotation: JF } = _E, { printPropertyKey: XF } = kv, { printAssignment: YF } = oA, { printClassMemberDecorators: KF } = kF;
      const QF = OF("heritageGroup");
      function ZF(e2) {
        return e2.typeParameters && !qF(e2.typeParameters, UF.Trailing | UF.Line) && !function(e3) {
          return ["superClass", "extends", "mixins", "implements"].filter((t2) => Boolean(e3[t2])).length > 1;
        }(e2);
      }
      function ex(e2, t2, n2, r2) {
        const i2 = e2.getValue();
        if (!PF(i2[r2]))
          return "";
        const u2 = LF(e2, t2, true, ({ marker: e3 }) => e3 === r2);
        return [ZF(i2) ? WF(" ", _F, { groupId: zF(i2.typeParameters) }) : _F, u2, u2 && MF, r2, $F(VF([_F, jF([",", _F], e2.map(n2, r2))]))];
      }
      function tx(e2, t2, n2) {
        const r2 = n2("superClass");
        return e2.getParentNode().type === "AssignmentExpression" ? $F(WF(["(", VF([RF, r2]), RF, ")"], r2)) : r2;
      }
      var nx = { printClass: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = [];
        r2.declare && i2.push("declare "), r2.abstract && i2.push("abstract "), i2.push("class");
        const u2 = r2.id && qF(r2.id, UF.Trailing) || r2.superClass && qF(r2.superClass) || PF(r2.extends) || PF(r2.mixins) || PF(r2.implements), o2 = [], s2 = [];
        if (r2.id && o2.push(" ", n2("id")), o2.push(n2("typeParameters")), r2.superClass) {
          const r3 = ["extends ", tx(e2, t2, n2), n2("superTypeParameters")], i3 = e2.call((e3) => IF(e3, r3, t2), "superClass");
          u2 ? s2.push(_F, $F(i3)) : s2.push(" ", i3);
        } else
          s2.push(ex(e2, t2, n2, "extends"));
        if (s2.push(ex(e2, t2, n2, "mixins"), ex(e2, t2, n2, "implements")), u2) {
          let e3;
          e3 = ZF(r2) ? [...o2, VF(s2)] : VF([...o2, s2]), i2.push($F(e3, { id: QF(r2) }));
        } else
          i2.push(...o2, ...s2);
        return i2.push(" ", n2("body")), i2;
      }, printClassMethod: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = [];
        return PF(r2.decorators) && i2.push(KF(e2, t2, n2)), r2.accessibility && i2.push(r2.accessibility + " "), r2.readonly && i2.push("readonly "), r2.declare && i2.push("declare "), r2.static && i2.push("static "), (r2.type === "TSAbstractMethodDefinition" || r2.abstract) && i2.push("abstract "), r2.override && i2.push("override "), i2.push(GF(e2, t2, n2)), i2;
      }, printClassProperty: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = [], u2 = t2.semi ? ";" : "";
        return PF(r2.decorators) && i2.push(KF(e2, t2, n2)), r2.accessibility && i2.push(r2.accessibility + " "), r2.declare && i2.push("declare "), r2.static && i2.push("static "), (r2.type === "TSAbstractClassProperty" || r2.abstract) && i2.push("abstract "), r2.override && i2.push("override "), r2.readonly && i2.push("readonly "), r2.variance && i2.push(n2("variance")), i2.push(XF(e2, t2, n2), HF(e2), JF(e2, t2, n2)), [YF(e2, t2, n2, i2, " =", "value"), u2];
      }, printHardlineAfterHeritage: function(e2) {
        return WF(MF, "", { groupId: QF(e2) });
      } };
      const { isNonEmptyArray: rx } = Fi, { builders: { join: ix, line: ux, group: ox, indent: sx, ifBreak: ax } } = su, { hasComment: cx, identity: lx, CommentCheckFlags: px } = eg, { getTypeParametersGroupId: fx } = Ev, { printTypeScriptModifiers: dx } = _E;
      var hx = { printInterface: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = [];
        r2.declare && i2.push("declare "), r2.type === "TSInterfaceDeclaration" && i2.push(r2.abstract ? "abstract " : "", dx(e2, t2, n2)), i2.push("interface");
        const u2 = [], o2 = [];
        r2.type !== "InterfaceTypeAnnotation" && u2.push(" ", n2("id"), n2("typeParameters"));
        const s2 = r2.typeParameters && !cx(r2.typeParameters, px.Trailing | px.Line);
        return rx(r2.extends) && o2.push(s2 ? ax(" ", ux, { groupId: fx(r2.typeParameters) }) : ux, "extends ", (r2.extends.length === 1 ? lx : sx)(ix([",", ux], e2.map(n2, "extends")))), r2.id && cx(r2.id, px.Trailing) || rx(r2.extends) ? s2 ? i2.push(ox([...u2, sx(o2)])) : i2.push(ox(sx([...u2, ...o2]))) : i2.push(...u2, ...o2), i2.push(" ", n2("body")), ox(i2);
      } };
      const { isNonEmptyArray: gx } = Fi, { builders: { softline: mx, group: yx, indent: Dx, join: Ex, line: Cx, ifBreak: bx, hardline: Ax } } = su, { printDanglingComments: vx } = Yf, { hasComment: Fx, CommentCheckFlags: xx, shouldPrintComma: Sx, needsHardlineAfterDanglingComment: wx } = eg, { locStart: Tx, hasSameLoc: Bx } = Zc, { hasDecoratorsBeforeExport: Nx, printDecoratorsBeforeExport: kx } = kF;
      function Px(e2, t2, n2) {
        const r2 = e2.getValue();
        if (!r2.source)
          return "";
        const i2 = [];
        return Ix(r2, t2) || i2.push(" from"), i2.push(" ", n2("source")), i2;
      }
      function Ox(e2, t2, n2) {
        const r2 = e2.getValue();
        if (Ix(r2, t2))
          return "";
        const i2 = [" "];
        if (gx(r2.specifiers)) {
          const u2 = [], o2 = [];
          if (e2.each(() => {
            const t3 = e2.getValue().type;
            if (t3 === "ExportNamespaceSpecifier" || t3 === "ExportDefaultSpecifier" || t3 === "ImportNamespaceSpecifier" || t3 === "ImportDefaultSpecifier")
              u2.push(n2());
            else {
              if (t3 !== "ExportSpecifier" && t3 !== "ImportSpecifier")
                throw new Error(`Unknown specifier type ${JSON.stringify(t3)}`);
              o2.push(n2());
            }
          }, "specifiers"), i2.push(Ex(", ", u2)), o2.length > 0) {
            u2.length > 0 && i2.push(", ");
            o2.length > 1 || u2.length > 0 || r2.specifiers.some((e3) => Fx(e3)) ? i2.push(yx(["{", Dx([t2.bracketSpacing ? Cx : mx, Ex([",", Cx], o2)]), bx(Sx(t2) ? "," : ""), t2.bracketSpacing ? Cx : mx, "}"])) : i2.push(["{", t2.bracketSpacing ? " " : "", ...o2, t2.bracketSpacing ? " " : "", "}"]);
          }
        } else
          i2.push("{}");
        return i2;
      }
      function Ix(e2, t2) {
        const { type: n2, importKind: r2, source: i2, specifiers: u2 } = e2;
        return n2 === "ImportDeclaration" && !gx(u2) && r2 !== "type" && !/{\s*}/.test(t2.originalText.slice(Tx(e2), Tx(i2)));
      }
      function Lx(e2, t2, n2) {
        const r2 = e2.getNode();
        return gx(r2.assertions) ? [" assert {", t2.bracketSpacing ? " " : "", Ex(", ", e2.map(n2, "assertions")), t2.bracketSpacing ? " " : "", "}"] : "";
      }
      var jx = { printImportDeclaration: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = t2.semi ? ";" : "", u2 = [], { importKind: o2 } = r2;
        return u2.push("import"), o2 && o2 !== "value" && u2.push(" ", o2), u2.push(Ox(e2, t2, n2), Px(e2, t2, n2), Lx(e2, t2, n2), i2), u2;
      }, printExportDeclaration: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = [];
        Nx(r2) && i2.push(kx(e2, t2, n2));
        const { type: u2, exportKind: o2, declaration: s2 } = r2;
        return i2.push("export"), (r2.default || u2 === "ExportDefaultDeclaration") && i2.push(" default"), Fx(r2, xx.Dangling) && (i2.push(" ", vx(e2, t2, true)), wx(r2) && i2.push(Ax)), s2 ? i2.push(" ", n2("declaration")) : i2.push(o2 === "type" ? " type" : "", Ox(e2, t2, n2), Px(e2, t2, n2), Lx(e2, t2, n2)), function(e3, t3) {
          if (!t3.semi)
            return false;
          const { type: n3, declaration: r3 } = e3, i3 = e3.default || n3 === "ExportDefaultDeclaration";
          if (!r3)
            return true;
          const { type: u3 } = r3;
          if (i3 && u3 !== "ClassDeclaration" && u3 !== "FunctionDeclaration" && u3 !== "TSInterfaceDeclaration" && u3 !== "DeclareClass" && u3 !== "DeclareFunction" && u3 !== "TSDeclareFunction" && u3 !== "EnumDeclaration")
            return true;
          return false;
        }(r2, t2) && i2.push(";"), i2;
      }, printExportAllDeclaration: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = t2.semi ? ";" : "", u2 = [], { exportKind: o2, exported: s2 } = r2;
        return u2.push("export"), o2 === "type" && u2.push(" type"), u2.push(" *"), s2 && u2.push(" as ", n2("exported")), u2.push(Px(e2, t2, n2), Lx(e2, t2, n2), i2), u2;
      }, printModuleSpecifier: function(e2, t2, n2) {
        const r2 = e2.getNode(), { type: i2, importKind: u2 } = r2, o2 = [];
        i2 === "ImportSpecifier" && u2 && o2.push(u2, " ");
        const s2 = i2.startsWith("Import"), a2 = s2 ? "imported" : "local", c2 = s2 ? "local" : "exported";
        let l2 = "", p2 = "";
        return i2 === "ExportNamespaceSpecifier" || i2 === "ImportNamespaceSpecifier" ? l2 = "*" : r2[a2] && (l2 = n2(a2)), !r2[c2] || r2[a2] && Bx(r2[a2], r2[c2]) || (p2 = n2(c2)), o2.push(l2, l2 && p2 ? " as " : "", p2), o2;
      } };
      const { printDanglingComments: _x } = Yf, { builders: { line: Mx, softline: Rx, group: $x, indent: Vx, ifBreak: Wx, hardline: qx } } = su, { getLast: Ux, hasNewlineInRange: zx, hasNewline: Gx, isNonEmptyArray: Hx } = Fi, { shouldPrintComma: Jx, hasComment: Xx, getComments: Yx, CommentCheckFlags: Kx, isNextLineEmpty: Qx } = eg, { locStart: Zx, locEnd: eS } = Zc, { printOptionalToken: tS, printTypeAnnotation: nS } = _E, { shouldHugFunctionParameters: rS } = PA, { shouldHugType: iS } = ev, { printHardlineAfterHeritage: uS } = nx;
      var oS = { printObject: function(e2, t2, n2) {
        const r2 = t2.semi ? ";" : "", i2 = e2.getValue();
        let u2;
        u2 = i2.type === "TSTypeLiteral" ? "members" : i2.type === "TSInterfaceBody" ? "body" : "properties";
        const o2 = i2.type === "ObjectTypeAnnotation", s2 = [u2];
        o2 && s2.push("indexers", "callProperties", "internalSlots");
        const a2 = s2.map((e3) => i2[e3][0]).sort((e3, t3) => Zx(e3) - Zx(t3))[0], c2 = e2.getParentNode(0), l2 = o2 && c2 && (c2.type === "InterfaceDeclaration" || c2.type === "DeclareInterface" || c2.type === "DeclareClass") && e2.getName() === "body", p2 = i2.type === "TSInterfaceBody" || l2 || i2.type === "ObjectPattern" && c2.type !== "FunctionDeclaration" && c2.type !== "FunctionExpression" && c2.type !== "ArrowFunctionExpression" && c2.type !== "ObjectMethod" && c2.type !== "ClassMethod" && c2.type !== "ClassPrivateMethod" && c2.type !== "AssignmentPattern" && c2.type !== "CatchClause" && i2.properties.some((e3) => e3.value && (e3.value.type === "ObjectPattern" || e3.value.type === "ArrayPattern")) || i2.type !== "ObjectPattern" && a2 && zx(t2.originalText, Zx(i2), Zx(a2)), f2 = l2 ? ";" : i2.type === "TSInterfaceBody" || i2.type === "TSTypeLiteral" ? Wx(r2, ";") : ",", d2 = i2.type === "RecordExpression" ? "#{" : i2.exact ? "{|" : "{", h2 = i2.exact ? "|}" : "}", g2 = [];
        for (const t3 of s2)
          e2.each((e3) => {
            const t4 = e3.getValue();
            g2.push({ node: t4, printed: n2(), loc: Zx(t4) });
          }, t3);
        s2.length > 1 && g2.sort((e3, t3) => e3.loc - t3.loc);
        let m2 = [];
        const y2 = g2.map((e3) => {
          const n3 = [...m2, $x(e3.printed)];
          return m2 = [f2, Mx], e3.node.type !== "TSPropertySignature" && e3.node.type !== "TSMethodSignature" && e3.node.type !== "TSConstructSignatureDeclaration" || !Xx(e3.node, Kx.PrettierIgnore) || m2.shift(), Qx(e3.node, t2) && m2.push(qx), n3;
        });
        if (i2.inexact) {
          let n3;
          if (Xx(i2, Kx.Dangling)) {
            const r3 = Xx(i2, Kx.Line);
            n3 = [_x(e2, t2, true), r3 || Gx(t2.originalText, eS(Ux(Yx(i2)))) ? qx : Mx, "..."];
          } else
            n3 = ["..."];
          y2.push([...m2, ...n3]);
        }
        const D2 = Ux(i2[u2]), E2 = !(i2.inexact || D2 && D2.type === "RestElement" || D2 && (D2.type === "TSPropertySignature" || D2.type === "TSCallSignatureDeclaration" || D2.type === "TSMethodSignature" || D2.type === "TSConstructSignatureDeclaration") && Xx(D2, Kx.PrettierIgnore));
        let C2;
        if (y2.length === 0) {
          if (!Xx(i2, Kx.Dangling))
            return [d2, h2, nS(e2, t2, n2)];
          C2 = $x([d2, _x(e2, t2), Rx, h2, tS(e2), nS(e2, t2, n2)]);
        } else
          C2 = [l2 && Hx(i2.properties) ? uS(c2) : "", d2, Vx([t2.bracketSpacing ? Mx : Rx, ...y2]), Wx(E2 && (f2 !== "," || Jx(t2)) ? f2 : ""), t2.bracketSpacing ? Mx : Rx, h2, tS(e2), nS(e2, t2, n2)];
        return e2.match((e3) => e3.type === "ObjectPattern" && !e3.decorators, (e3, t3, n3) => rS(e3) && (t3 === "params" || t3 === "parameters" || t3 === "this" || t3 === "rest") && n3 === 0) || e2.match(iS, (e3, t3) => t3 === "typeAnnotation", (e3, t3) => t3 === "typeAnnotation", (e3, t3, n3) => rS(e3) && (t3 === "params" || t3 === "parameters" || t3 === "this" || t3 === "rest") && n3 === 0) || !p2 && e2.match((e3) => e3.type === "ObjectPattern", (e3) => e3.type === "AssignmentExpression" || e3.type === "VariableDeclarator") ? C2 : $x(C2, { shouldBreak: p2 });
      } };
      const { printDanglingComments: sS } = Yf, { printString: aS, printNumber: cS } = Fi, { builders: { hardline: lS, softline: pS, group: fS, indent: dS } } = su, { getParentExportDeclaration: hS, isFunctionNotation: gS, isGetterOrSetter: mS, rawText: yS, shouldPrintComma: DS } = eg, { locStart: ES, locEnd: CS } = Zc, { printClass: bS } = nx, { printOpaqueType: AS, printTypeAlias: vS, printIntersectionType: FS, printUnionType: xS, printFunctionType: SS, printTupleType: wS, printIndexedAccessType: TS } = ev, { printInterface: BS } = hx, { printTypeParameter: NS, printTypeParameters: kS } = Ev, { printExportDeclaration: PS, printExportAllDeclaration: OS } = jx, { printArrayItems: IS } = oC, { printObject: LS } = oS, { printPropertyKey: jS } = kv, { printOptionalToken: _S, printTypeAnnotation: MS, printRestSpread: RS } = _E;
      function $S(e2, t2) {
        const n2 = hS(e2);
        return n2 ? (Ff.strictEqual(n2.type, "DeclareExportDeclaration"), t2) : ["declare ", t2];
      }
      var VS = { printFlow: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = t2.semi ? ";" : "", u2 = [];
        switch (r2.type) {
          case "DeclareClass":
            return $S(e2, bS(e2, t2, n2));
          case "DeclareFunction":
            return $S(e2, ["function ", n2("id"), r2.predicate ? " " : "", n2("predicate"), i2]);
          case "DeclareModule":
            return $S(e2, ["module ", n2("id"), " ", n2("body")]);
          case "DeclareModuleExports":
            return $S(e2, ["module.exports", ": ", n2("typeAnnotation"), i2]);
          case "DeclareVariable":
            return $S(e2, ["var ", n2("id"), i2]);
          case "DeclareOpaqueType":
            return $S(e2, AS(e2, t2, n2));
          case "DeclareInterface":
            return $S(e2, BS(e2, t2, n2));
          case "DeclareTypeAlias":
            return $S(e2, vS(e2, t2, n2));
          case "DeclareExportDeclaration":
            return $S(e2, PS(e2, t2, n2));
          case "DeclareExportAllDeclaration":
            return $S(e2, OS(e2, t2, n2));
          case "OpaqueType":
            return AS(e2, t2, n2);
          case "TypeAlias":
            return vS(e2, t2, n2);
          case "IntersectionTypeAnnotation":
            return FS(e2, t2, n2);
          case "UnionTypeAnnotation":
            return xS(e2, t2, n2);
          case "FunctionTypeAnnotation":
            return SS(e2, t2, n2);
          case "TupleTypeAnnotation":
            return wS(e2, t2, n2);
          case "GenericTypeAnnotation":
            return [n2("id"), kS(e2, t2, n2, "typeParameters")];
          case "IndexedAccessType":
          case "OptionalIndexedAccessType":
            return TS(e2, t2, n2);
          case "TypeAnnotation":
            return n2("typeAnnotation");
          case "TypeParameter":
            return NS(e2, t2, n2);
          case "TypeofTypeAnnotation":
            return ["typeof ", n2("argument")];
          case "ExistsTypeAnnotation":
            return "*";
          case "EmptyTypeAnnotation":
            return "empty";
          case "MixedTypeAnnotation":
            return "mixed";
          case "ArrayTypeAnnotation":
            return [n2("elementType"), "[]"];
          case "BooleanLiteralTypeAnnotation":
            return String(r2.value);
          case "EnumDeclaration":
            return ["enum ", n2("id"), " ", n2("body")];
          case "EnumBooleanBody":
          case "EnumNumberBody":
          case "EnumStringBody":
          case "EnumSymbolBody":
            if (r2.type === "EnumSymbolBody" || r2.explicitType) {
              let e3 = null;
              switch (r2.type) {
                case "EnumBooleanBody":
                  e3 = "boolean";
                  break;
                case "EnumNumberBody":
                  e3 = "number";
                  break;
                case "EnumStringBody":
                  e3 = "string";
                  break;
                case "EnumSymbolBody":
                  e3 = "symbol";
              }
              u2.push("of ", e3, " ");
            }
            if (r2.members.length !== 0 || r2.hasUnknownMembers) {
              const i3 = r2.members.length > 0 ? [lS, IS(e2, t2, "members", n2), r2.hasUnknownMembers || DS(t2) ? "," : ""] : [];
              u2.push(fS(["{", dS([...i3, ...r2.hasUnknownMembers ? [lS, "..."] : []]), sS(e2, t2, true), lS, "}"]));
            } else
              u2.push(fS(["{", sS(e2, t2), pS, "}"]));
            return u2;
          case "EnumBooleanMember":
          case "EnumNumberMember":
          case "EnumStringMember":
            return [n2("id"), " = ", typeof r2.init == "object" ? n2("init") : String(r2.init)];
          case "EnumDefaultedMember":
            return n2("id");
          case "FunctionTypeParam": {
            const t3 = r2.name ? n2("name") : e2.getParentNode().this === r2 ? "this" : "";
            return [t3, _S(e2), t3 ? ": " : "", n2("typeAnnotation")];
          }
          case "InterfaceDeclaration":
          case "InterfaceTypeAnnotation":
            return BS(e2, t2, n2);
          case "ClassImplements":
          case "InterfaceExtends":
            return [n2("id"), n2("typeParameters")];
          case "NullableTypeAnnotation":
            return ["?", n2("typeAnnotation")];
          case "Variance": {
            const { kind: e3 } = r2;
            return Ff.ok(e3 === "plus" || e3 === "minus"), e3 === "plus" ? "+" : "-";
          }
          case "ObjectTypeCallProperty":
            return r2.static && u2.push("static "), u2.push(n2("value")), u2;
          case "ObjectTypeIndexer":
            return [r2.variance ? n2("variance") : "", "[", n2("id"), r2.id ? ": " : "", n2("key"), "]: ", n2("value")];
          case "ObjectTypeProperty": {
            let i3 = "";
            return r2.proto ? i3 = "proto " : r2.static && (i3 = "static "), [i3, mS(r2) ? r2.kind + " " : "", r2.variance ? n2("variance") : "", jS(e2, t2, n2), _S(e2), gS(r2) ? "" : ": ", n2("value")];
          }
          case "ObjectTypeAnnotation":
            return LS(e2, t2, n2);
          case "ObjectTypeInternalSlot":
            return [r2.static ? "static " : "", "[[", n2("id"), "]]", _S(e2), r2.method ? "" : ": ", n2("value")];
          case "ObjectTypeSpreadProperty":
            return RS(e2, t2, n2);
          case "QualifiedTypeIdentifier":
            return [n2("qualification"), ".", n2("id")];
          case "StringLiteralTypeAnnotation":
            return aS(yS(r2), t2);
          case "NumberLiteralTypeAnnotation":
            Ff.strictEqual(typeof r2.value, "number");
          case "BigIntLiteralTypeAnnotation":
            return r2.extra ? cS(r2.extra.raw) : cS(r2.raw);
          case "TypeCastExpression":
            return ["(", n2("expression"), MS(e2, t2, n2), ")"];
          case "TypeParameterDeclaration":
          case "TypeParameterInstantiation": {
            const i3 = kS(e2, t2, n2, "params");
            if (t2.parser === "flow") {
              const e3 = ES(r2), n3 = CS(r2), u3 = t2.originalText.lastIndexOf("/*", e3), o2 = t2.originalText.indexOf("*/", n3);
              if (u3 !== -1 && o2 !== -1) {
                const e4 = t2.originalText.slice(u3 + 2, o2).trim();
                if (e4.startsWith("::") && !e4.includes("/*") && !e4.includes("*/"))
                  return ["/*:: ", i3, " */"];
              }
            }
            return i3;
          }
          case "InferredPredicate":
            return "%checks";
          case "DeclaredPredicate":
            return ["%checks(", n2("value"), ")"];
          case "AnyTypeAnnotation":
            return "any";
          case "BooleanTypeAnnotation":
            return "boolean";
          case "BigIntTypeAnnotation":
            return "bigint";
          case "NullLiteralTypeAnnotation":
            return "null";
          case "NumberTypeAnnotation":
            return "number";
          case "SymbolTypeAnnotation":
            return "symbol";
          case "StringTypeAnnotation":
            return "string";
          case "VoidTypeAnnotation":
            return "void";
          case "ThisTypeAnnotation":
            return "this";
          case "Node":
          case "Printable":
          case "SourceLocation":
          case "Position":
          case "Statement":
          case "Function":
          case "Pattern":
          case "Expression":
          case "Declaration":
          case "Specifier":
          case "NamedSpecifier":
          case "Comment":
          case "MemberTypeAnnotation":
          case "Type":
            throw new Error("unprintable type: " + JSON.stringify(r2.type));
        }
      } };
      const { hasNewlineInRange: WS } = Fi, { isJsxNode: qS, isBlockComment: US, getComments: zS, isCallExpression: GS, isMemberExpression: HS } = eg, { locStart: JS, locEnd: XS } = Zc, { builders: { line: YS, softline: KS, group: QS, indent: ZS, align: ew, ifBreak: tw, dedent: nw, breakParent: rw } } = su;
      function iw(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = r2.type === "ConditionalExpression", u2 = i2 ? "alternate" : "falseType", o2 = e2.getParentNode(), s2 = i2 ? n2("test") : [n2("checkType"), " ", "extends", " ", n2("extendsType")];
        return o2.type === r2.type && o2[u2] === r2 ? ew(2, s2) : s2;
      }
      const uw = new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
      var ow = { printTernary: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = r2.type === "ConditionalExpression", u2 = i2 ? "consequent" : "trueType", o2 = i2 ? "alternate" : "falseType", s2 = i2 ? ["test"] : ["checkType", "extendsType"], a2 = r2[u2], c2 = r2[o2], l2 = [];
        let p2 = false;
        const f2 = e2.getParentNode(), d2 = f2.type === r2.type && s2.some((e3) => f2[e3] === r2);
        let h2, g2, m2 = f2.type === r2.type && !d2, y2 = 0;
        do {
          g2 = h2 || r2, h2 = e2.getParentNode(y2), y2++;
        } while (h2 && h2.type === r2.type && s2.every((e3) => h2[e3] !== g2));
        const D2 = h2 || f2, E2 = g2;
        if (i2 && (qS(r2[s2[0]]) || qS(a2) || qS(c2) || function(e3) {
          const t3 = [e3];
          for (let e4 = 0; e4 < t3.length; e4++) {
            const n3 = t3[e4];
            for (const e5 of ["test", "consequent", "alternate"]) {
              const r3 = n3[e5];
              if (qS(r3))
                return true;
              r3.type === "ConditionalExpression" && t3.push(r3);
            }
          }
          return false;
        }(E2))) {
          p2 = true, m2 = true;
          const e3 = (e4) => [tw("("), ZS([KS, e4]), KS, tw(")")], t3 = (e4) => e4.type === "NullLiteral" || e4.type === "Literal" && e4.value === null || e4.type === "Identifier" && e4.name === "undefined";
          l2.push(" ? ", t3(a2) ? n2(u2) : e3(n2(u2)), " : ", c2.type === r2.type || t3(c2) ? n2(o2) : e3(n2(o2)));
        } else {
          const e3 = [YS, "? ", a2.type === r2.type ? tw("", "(") : "", ew(2, n2(u2)), a2.type === r2.type ? tw("", ")") : "", YS, ": ", c2.type === r2.type ? n2(o2) : ew(2, n2(o2))];
          l2.push(f2.type !== r2.type || f2[o2] === r2 || d2 ? e3 : t2.useTabs ? nw(ZS(e3)) : ew(Math.max(0, t2.tabWidth - 2), e3));
        }
        const C2 = [...s2.map((e3) => zS(r2[e3])), zS(a2), zS(c2)].flat().some((e3) => US(e3) && WS(t2.originalText, JS(e3), XS(e3))), b2 = !p2 && (HS(f2) || f2.type === "NGPipeExpression" && f2.left === r2) && !f2.computed, A2 = function(e3) {
          const t3 = e3.getValue();
          if (t3.type !== "ConditionalExpression")
            return false;
          let n3, r3 = t3;
          for (let t4 = 0; !n3; t4++) {
            const i3 = e3.getParentNode(t4);
            GS(i3) && i3.callee === r3 || HS(i3) && i3.object === r3 || i3.type === "TSNonNullExpression" && i3.expression === r3 ? r3 = i3 : i3.type === "NewExpression" && i3.callee === r3 || i3.type === "TSAsExpression" && i3.expression === r3 ? (n3 = e3.getParentNode(t4 + 1), r3 = i3) : n3 = i3;
          }
          return r3 !== t3 && n3[uw.get(n3.type)] === r3;
        }(e2), v2 = (F2 = [iw(e2, 0, n2), m2 ? l2 : ZS(l2), i2 && b2 && !A2 ? KS : ""], f2 === D2 ? QS(F2, { shouldBreak: C2 }) : C2 ? [F2, rw] : F2);
        var F2;
        return d2 || A2 ? QS([ZS([KS, v2]), KS]) : v2;
      } };
      const { builders: { hardline: sw } } = su, { getLeftSidePathName: aw, hasNakedLeftSide: cw, isJsxNode: lw, isTheOnlyJsxElementInMarkdown: pw, hasComment: fw, CommentCheckFlags: dw, isNextLineEmpty: hw } = eg, { shouldPrintParamsWithoutParens: gw } = DF;
      function mw(e2, t2, n2, r2) {
        const i2 = e2.getValue(), u2 = [], o2 = i2.type === "ClassBody", s2 = function(e3) {
          for (let t3 = e3.length - 1; t3 >= 0; t3--) {
            const n3 = e3[t3];
            if (n3.type !== "EmptyStatement")
              return n3;
          }
        }(i2[r2]);
        return e2.each((e3, r3, i3) => {
          const a2 = e3.getValue();
          if (a2.type === "EmptyStatement")
            return;
          const c2 = n2();
          t2.semi || o2 || pw(t2, e3) || !function(e4, t3) {
            if (e4.getNode().type !== "ExpressionStatement")
              return false;
            return e4.call((e5) => yw(e5, t3), "expression");
          }(e3, t2) ? u2.push(c2) : fw(a2, dw.Leading) ? u2.push(n2([], { needsSemi: true })) : u2.push(";", c2), !t2.semi && o2 && Dw(a2) && function(e4, t3) {
            const n3 = e4.key && e4.key.name;
            if (!(n3 !== "static" && n3 !== "get" && n3 !== "set" || e4.value || e4.typeAnnotation))
              return true;
            if (!t3)
              return false;
            if (t3.static || t3.accessibility)
              return false;
            if (!t3.computed) {
              const e5 = t3.key && t3.key.name;
              if (e5 === "in" || e5 === "instanceof")
                return true;
            }
            if (Dw(t3) && t3.variance && !t3.static && !t3.declare)
              return true;
            switch (t3.type) {
              case "ClassProperty":
              case "PropertyDefinition":
              case "TSAbstractClassProperty":
                return t3.computed;
              case "MethodDefinition":
              case "TSAbstractMethodDefinition":
              case "ClassMethod":
              case "ClassPrivateMethod": {
                if ((t3.value ? t3.value.async : t3.async) || t3.kind === "get" || t3.kind === "set")
                  return false;
                const e5 = t3.value ? t3.value.generator : t3.generator;
                return !(!t3.computed && !e5);
              }
              case "TSIndexSignature":
                return true;
            }
            return false;
          }(a2, i3[r3 + 1]) && u2.push(";"), a2 !== s2 && (u2.push(sw), hw(a2, t2) && u2.push(sw));
        }, r2), u2;
      }
      function yw(e2, t2) {
        const n2 = e2.getValue();
        switch (n2.type) {
          case "ParenthesizedExpression":
          case "TypeCastExpression":
          case "ArrayExpression":
          case "ArrayPattern":
          case "TemplateLiteral":
          case "TemplateElement":
          case "RegExpLiteral":
            return true;
          case "ArrowFunctionExpression":
            if (!gw(e2, t2))
              return true;
            break;
          case "UnaryExpression": {
            const { prefix: e3, operator: t3 } = n2;
            if (e3 && (t3 === "+" || t3 === "-"))
              return true;
            break;
          }
          case "BindExpression":
            if (!n2.object)
              return true;
            break;
          case "Literal":
            if (n2.regex)
              return true;
            break;
          default:
            if (lw(n2))
              return true;
        }
        return !!oD(e2, t2) || !!cw(n2) && e2.call((e3) => yw(e3, t2), ...aw(e2, n2));
      }
      const Dw = ({ type: e2 }) => e2 === "ClassProperty" || e2 === "PropertyDefinition" || e2 === "ClassPrivateProperty";
      var Ew = { printBody: function(e2, t2, n2) {
        return mw(e2, t2, n2, "body");
      }, printSwitchCaseConsequent: function(e2, t2, n2) {
        return mw(e2, t2, n2, "consequent");
      } };
      const { printDanglingComments: Cw } = Yf, { isNonEmptyArray: bw } = Fi, { builders: { hardline: Aw, indent: vw } } = su, { hasComment: Fw, CommentCheckFlags: xw, isNextLineEmpty: Sw } = eg, { printHardlineAfterHeritage: ww } = nx, { printBody: Tw } = Ew;
      function Bw(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = bw(r2.directives), u2 = r2.body.some((e3) => e3.type !== "EmptyStatement"), o2 = Fw(r2, xw.Dangling);
        if (!i2 && !u2 && !o2)
          return "";
        const s2 = [];
        if (i2 && e2.each((e3, r3, i3) => {
          s2.push(n2()), (r3 < i3.length - 1 || u2 || o2) && (s2.push(Aw), Sw(e3.getValue(), t2) && s2.push(Aw));
        }, "directives"), u2 && s2.push(Tw(e2, t2, n2)), o2 && s2.push(Cw(e2, t2, true)), r2.type === "Program") {
          const t3 = e2.getParentNode();
          t3 && t3.type === "ModuleExpression" || s2.push(Aw);
        }
        return s2;
      }
      var Nw = { printBlock: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = [];
        if (r2.type === "StaticBlock" && i2.push("static "), r2.type === "ClassBody" && bw(r2.body)) {
          const t3 = e2.getParentNode();
          i2.push(ww(t3));
        }
        i2.push("{");
        const u2 = Bw(e2, t2, n2);
        if (u2)
          i2.push(vw([Aw, u2]), Aw);
        else {
          const t3 = e2.getParentNode(), n3 = e2.getParentNode(1);
          t3.type === "ArrowFunctionExpression" || t3.type === "FunctionExpression" || t3.type === "FunctionDeclaration" || t3.type === "ObjectMethod" || t3.type === "ClassMethod" || t3.type === "ClassPrivateMethod" || t3.type === "ForStatement" || t3.type === "WhileStatement" || t3.type === "DoWhileStatement" || t3.type === "DoExpression" || t3.type === "CatchClause" && !n3.finalizer || t3.type === "TSModuleDeclaration" || t3.type === "TSDeclareFunction" || r2.type === "StaticBlock" || r2.type === "ClassBody" || i2.push(Aw);
        }
        return i2.push("}"), i2;
      }, printBlockBody: Bw };
      const { printDanglingComments: kw } = Yf, { hasNewlineInRange: Pw } = Fi, { builders: { join: Ow, line: Iw, hardline: Lw, softline: jw, group: _w, indent: Mw, conditionalGroup: Rw, ifBreak: $w } } = su, { isLiteral: Vw, getTypeScriptMappedTypeModifier: Ww, shouldPrintComma: qw, isCallExpression: Uw, isMemberExpression: zw } = eg, { locStart: Gw, locEnd: Hw } = Zc, { printOptionalToken: Jw, printTypeScriptModifiers: Xw } = _E, { printTernary: Yw } = ow, { printFunctionParameters: Kw, shouldGroupFunctionParameters: Qw } = PA, { printTemplateLiteral: Zw } = Eg, { printArrayItems: eT } = oC, { printObject: tT } = oS, { printClassProperty: nT, printClassMethod: rT } = nx, { printTypeParameter: iT, printTypeParameters: uT } = Ev, { printPropertyKey: oT } = kv, { printFunction: sT, printMethodInternal: aT } = DF, { printInterface: cT } = hx, { printBlock: lT } = Nw, { printTypeAlias: pT, printIntersectionType: fT, printUnionType: dT, printFunctionType: hT, printTupleType: gT, printIndexedAccessType: mT } = ev;
      var yT = { printTypescript: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (!r2.type.startsWith("TS"))
          return;
        if (r2.type.endsWith("Keyword"))
          return r2.type.slice(2, -7).toLowerCase();
        const i2 = t2.semi ? ";" : "", u2 = [];
        switch (r2.type) {
          case "TSThisType":
            return "this";
          case "TSTypeAssertion": {
            const e3 = !(r2.expression.type === "ArrayExpression" || r2.expression.type === "ObjectExpression"), t3 = _w(["<", Mw([jw, n2("typeAnnotation")]), jw, ">"]), i3 = [$w("("), Mw([jw, n2("expression")]), jw, $w(")")];
            return e3 ? Rw([[t3, n2("expression")], [t3, _w(i3, { shouldBreak: true })], [t3, n2("expression")]]) : _w([t3, n2("expression")]);
          }
          case "TSDeclareFunction":
            return sT(e2, n2, t2);
          case "TSExportAssignment":
            return ["export = ", n2("expression"), i2];
          case "TSModuleBlock":
            return lT(e2, t2, n2);
          case "TSInterfaceBody":
          case "TSTypeLiteral":
            return tT(e2, t2, n2);
          case "TSTypeAliasDeclaration":
            return pT(e2, t2, n2);
          case "TSQualifiedName":
            return Ow(".", [n2("left"), n2("right")]);
          case "TSAbstractMethodDefinition":
          case "TSDeclareMethod":
            return rT(e2, t2, n2);
          case "TSAbstractClassProperty":
            return nT(e2, t2, n2);
          case "TSInterfaceHeritage":
          case "TSExpressionWithTypeArguments":
            return u2.push(n2("expression")), r2.typeParameters && u2.push(n2("typeParameters")), u2;
          case "TSTemplateLiteralType":
            return Zw(e2, n2, t2);
          case "TSNamedTupleMember":
            return [n2("label"), r2.optional ? "?" : "", ": ", n2("elementType")];
          case "TSRestType":
            return ["...", n2("typeAnnotation")];
          case "TSOptionalType":
            return [n2("typeAnnotation"), "?"];
          case "TSInterfaceDeclaration":
            return cT(e2, t2, n2);
          case "TSClassImplements":
            return [n2("expression"), n2("typeParameters")];
          case "TSTypeParameterDeclaration":
          case "TSTypeParameterInstantiation":
            return uT(e2, t2, n2, "params");
          case "TSTypeParameter":
            return iT(e2, t2, n2);
          case "TSAsExpression": {
            u2.push(n2("expression"), " as ", n2("typeAnnotation"));
            const t3 = e2.getParentNode();
            return Uw(t3) && t3.callee === r2 || zw(t3) && t3.object === r2 ? _w([Mw([jw, ...u2]), jw]) : u2;
          }
          case "TSArrayType":
            return [n2("elementType"), "[]"];
          case "TSPropertySignature":
            return r2.readonly && u2.push("readonly "), u2.push(oT(e2, t2, n2), Jw(e2)), r2.typeAnnotation && u2.push(": ", n2("typeAnnotation")), r2.initializer && u2.push(" = ", n2("initializer")), u2;
          case "TSParameterProperty":
            return r2.accessibility && u2.push(r2.accessibility + " "), r2.export && u2.push("export "), r2.static && u2.push("static "), r2.override && u2.push("override "), r2.readonly && u2.push("readonly "), u2.push(n2("parameter")), u2;
          case "TSTypeQuery":
            return ["typeof ", n2("exprName")];
          case "TSIndexSignature": {
            const u3 = e2.getParentNode(), o2 = r2.parameters.length > 1 ? $w(qw(t2) ? "," : "") : "", s2 = _w([Mw([jw, Ow([", ", jw], e2.map(n2, "parameters"))]), o2, jw]);
            return [r2.export ? "export " : "", r2.accessibility ? [r2.accessibility, " "] : "", r2.static ? "static " : "", r2.readonly ? "readonly " : "", r2.declare ? "declare " : "", "[", r2.parameters ? s2 : "", r2.typeAnnotation ? "]: " : "]", r2.typeAnnotation ? n2("typeAnnotation") : "", u3.type === "ClassBody" ? i2 : ""];
          }
          case "TSTypePredicate":
            return [r2.asserts ? "asserts " : "", n2("parameterName"), r2.typeAnnotation ? [" is ", n2("typeAnnotation")] : ""];
          case "TSNonNullExpression":
            return [n2("expression"), "!"];
          case "TSImportType":
            return [r2.isTypeOf ? "typeof " : "", "import(", n2(r2.parameter ? "parameter" : "argument"), ")", r2.qualifier ? [".", n2("qualifier")] : "", uT(e2, t2, n2, "typeParameters")];
          case "TSLiteralType":
            return n2("literal");
          case "TSIndexedAccessType":
            return mT(e2, t2, n2);
          case "TSConstructSignatureDeclaration":
          case "TSCallSignatureDeclaration":
          case "TSConstructorType":
            if (r2.type === "TSConstructorType" && r2.abstract && u2.push("abstract "), r2.type !== "TSCallSignatureDeclaration" && u2.push("new "), u2.push(_w(Kw(e2, n2, t2, false, true))), r2.returnType || r2.typeAnnotation) {
              const e3 = r2.type === "TSConstructorType";
              u2.push(e3 ? " => " : ": ", n2("returnType"), n2("typeAnnotation"));
            }
            return u2;
          case "TSTypeOperator":
            return [r2.operator, " ", n2("typeAnnotation")];
          case "TSMappedType": {
            const u3 = Pw(t2.originalText, Gw(r2), Hw(r2));
            return _w(["{", Mw([t2.bracketSpacing ? Iw : jw, r2.readonly ? [Ww(r2.readonly, "readonly"), " "] : "", Xw(e2, t2, n2), n2("typeParameter"), r2.optional ? Ww(r2.optional, "?") : "", r2.typeAnnotation ? ": " : "", n2("typeAnnotation"), $w(i2)]), kw(e2, t2, true), t2.bracketSpacing ? Iw : jw, "}"], { shouldBreak: u3 });
          }
          case "TSMethodSignature": {
            const i3 = r2.kind && r2.kind !== "method" ? `${r2.kind} ` : "";
            u2.push(r2.accessibility ? [r2.accessibility, " "] : "", i3, r2.export ? "export " : "", r2.static ? "static " : "", r2.readonly ? "readonly " : "", r2.abstract ? "abstract " : "", r2.declare ? "declare " : "", r2.computed ? "[" : "", n2("key"), r2.computed ? "]" : "", Jw(e2));
            const o2 = Kw(e2, n2, t2, false, true), s2 = r2.returnType ? "returnType" : "typeAnnotation", a2 = r2[s2], c2 = a2 ? n2(s2) : "", l2 = Qw(r2, c2);
            return u2.push(l2 ? _w(o2) : o2), a2 && u2.push(": ", _w(c2)), _w(u2);
          }
          case "TSNamespaceExportDeclaration":
            return u2.push("export as namespace ", n2("id")), t2.semi && u2.push(";"), _w(u2);
          case "TSEnumDeclaration":
            return r2.declare && u2.push("declare "), r2.modifiers && u2.push(Xw(e2, t2, n2)), r2.const && u2.push("const "), u2.push("enum ", n2("id"), " "), r2.members.length === 0 ? u2.push(_w(["{", kw(e2, t2), jw, "}"])) : u2.push(_w(["{", Mw([Lw, eT(e2, t2, "members", n2), qw(t2, "es5") ? "," : ""]), kw(e2, t2, true), Lw, "}"])), u2;
          case "TSEnumMember":
            return u2.push(n2("id")), r2.initializer && u2.push(" = ", n2("initializer")), u2;
          case "TSImportEqualsDeclaration":
            return r2.isExport && u2.push("export "), u2.push("import "), r2.importKind && r2.importKind !== "value" && u2.push(r2.importKind, " "), u2.push(n2("id"), " = ", n2("moduleReference")), t2.semi && u2.push(";"), _w(u2);
          case "TSExternalModuleReference":
            return ["require(", n2("expression"), ")"];
          case "TSModuleDeclaration": {
            const o2 = e2.getParentNode(), s2 = Vw(r2.id), a2 = o2.type === "TSModuleDeclaration", c2 = r2.body && r2.body.type === "TSModuleDeclaration";
            if (a2)
              u2.push(".");
            else {
              r2.declare && u2.push("declare "), u2.push(Xw(e2, t2, n2));
              const i3 = t2.originalText.slice(Gw(r2), Gw(r2.id));
              r2.id.type === "Identifier" && r2.id.name === "global" && !/namespace|module/.test(i3) || u2.push(s2 || /(?:^|\s)module(?:\s|$)/.test(i3) ? "module " : "namespace ");
            }
            return u2.push(n2("id")), c2 ? u2.push(n2("body")) : r2.body ? u2.push(" ", _w(n2("body"))) : u2.push(i2), u2;
          }
          case "TSPrivateIdentifier":
            return r2.escapedText;
          case "TSConditionalType":
            return Yw(e2, t2, n2);
          case "TSInferType":
            return ["infer", " ", n2("typeParameter")];
          case "TSIntersectionType":
            return fT(e2, t2, n2);
          case "TSUnionType":
            return dT(e2, t2, n2);
          case "TSFunctionType":
            return hT(e2, t2, n2);
          case "TSTupleType":
            return gT(e2, t2, n2);
          case "TSTypeReference":
            return [n2("typeName"), uT(e2, t2, n2, "typeParameters")];
          case "TSTypeAnnotation":
            return n2("typeAnnotation");
          case "TSEmptyBodyFunctionExpression":
            return aT(e2, t2, n2);
          case "TSJSDocAllType":
            return "*";
          case "TSJSDocUnknownType":
            return "?";
          case "TSJSDocNullableType":
            return ["?", n2("typeAnnotation")];
          case "TSJSDocNonNullableType":
            return ["!", n2("typeAnnotation")];
          default:
            throw new Error(`Unknown TypeScript node type: ${JSON.stringify(r2.type)}.`);
        }
      } };
      const { hasNewline: DT } = Fi, { builders: { join: ET, hardline: CT }, utils: { replaceTextEndOfLine: bT } } = su, { isLineComment: AT, isBlockComment: vT } = eg, { locStart: FT, locEnd: xT } = Zc;
      var ST = { printComment: function(e2, t2) {
        const n2 = e2.getValue();
        if (AT(n2))
          return t2.originalText.slice(FT(n2), xT(n2)).trimEnd();
        if (vT(n2)) {
          if (function(e4) {
            const t3 = `*${e4.value}*`.split("\n");
            return t3.length > 1 && t3.every((e5) => e5.trim()[0] === "*");
          }(n2)) {
            const e4 = function(e5) {
              const t3 = e5.value.split("\n");
              return ["/*", ET(CT, t3.map((e6, n3) => n3 === 0 ? e6.trimEnd() : " " + (n3 < t3.length - 1 ? e6.trim() : e6.trimStart()))), "*/"];
            }(n2);
            return n2.trailing && !DT(t2.originalText, FT(n2), { backwards: true }) ? [CT, e4] : e4;
          }
          const e3 = xT(n2), r2 = t2.originalText.slice(e3 - 3, e3) === "*-/";
          return ["/*", bT(n2.value), r2 ? "*-/" : "*/"];
        }
        throw new Error("Not a comment: " + JSON.stringify(n2));
      } };
      const { printString: wT, printNumber: TT } = Fi;
      function BT(e2) {
        return e2.toLowerCase();
      }
      function NT({ pattern: e2, flags: t2 }) {
        return `/${e2}/${t2 = [...t2].sort().join("")}`;
      }
      var kT = { printLiteral: function(e2, t2) {
        const n2 = e2.getNode();
        switch (n2.type) {
          case "RegExpLiteral":
            return NT(n2);
          case "BigIntLiteral":
            return BT(n2.bigint || n2.extra.raw);
          case "NumericLiteral":
            return TT(n2.extra.raw);
          case "StringLiteral":
            return wT(n2.extra.raw, t2);
          case "NullLiteral":
            return "null";
          case "BooleanLiteral":
            return String(n2.value);
          case "DecimalLiteral":
            return TT(n2.value) + "m";
          case "Literal": {
            if (n2.regex)
              return NT(n2.regex);
            if (n2.bigint)
              return BT(n2.raw);
            if (n2.decimal)
              return TT(n2.decimal) + "m";
            const { value: e3 } = n2;
            return typeof e3 == "number" ? TT(n2.raw) : typeof e3 == "string" ? wT(n2.raw, t2) : String(e3);
          }
        }
      } };
      const { printDanglingComments: PT } = Yf, { hasNewline: OT } = Fi, { builders: { join: IT, line: LT, hardline: jT, softline: _T, group: MT, indent: RT }, utils: { replaceTextEndOfLine: $T } } = su, { insertPragma: VT } = Rm, { hasFlowShorthandAnnotationComment: WT, hasComment: qT, CommentCheckFlags: UT, isTheOnlyJsxElementInMarkdown: zT, isBlockComment: GT, isLineComment: HT, isNextLineEmpty: JT, needsHardlineAfterDanglingComment: XT, rawText: YT, hasIgnoreComment: KT, isCallExpression: QT, isMemberExpression: ZT } = eg, { locStart: eB, locEnd: tB } = Zc, { printHtmlBinding: nB, isVueEventBindingExpression: rB } = dD, { printAngular: iB } = JD, { printJsx: uB, hasJsxIgnoreComment: oB } = NE, { printFlow: sB } = VS, { printTypescript: aB } = yT, { printOptionalToken: cB, printBindExpressionCallee: lB, printTypeAnnotation: pB, adjustClause: fB, printRestSpread: dB } = _E, { printImportDeclaration: hB, printExportDeclaration: gB, printExportAllDeclaration: mB, printModuleSpecifier: yB } = jx, { printTernary: DB } = ow, { printTemplateLiteral: EB } = Eg, { printArray: CB } = oC, { printObject: bB } = oS, { printClass: AB, printClassMethod: vB, printClassProperty: FB } = nx, { printProperty: xB } = kv, { printFunction: SB, printArrowFunction: wB, printMethod: TB, printReturnStatement: BB, printThrowStatement: NB } = DF, { printCallExpression: kB } = Pb, { printVariableDeclarator: PB, printAssignmentExpression: OB } = oA, { printBinaryishExpression: IB } = RD, { printSwitchCaseConsequent: LB } = Ew, { printMemberExpression: jB } = zC, { printBlock: _B, printBlockBody: MB } = Nw, { printComment: RB } = ST, { printLiteral: $B } = kT, { printDecorators: VB } = kF;
      function WB(e2, t2) {
        const n2 = YT(e2), r2 = n2.slice(1, -1);
        if (r2.includes('"') || r2.includes("'"))
          return n2;
        const i2 = t2.singleQuote ? "'" : '"';
        return i2 + r2 + i2;
      }
      var qB = { preprocess: sD, print: function(e2, t2, n2, r2) {
        const i2 = function(e3, t3, n3, r3) {
          const i3 = e3.getValue(), u3 = t3.semi ? ";" : "";
          if (!i3)
            return "";
          if (typeof i3 == "string")
            return i3;
          for (const r4 of [$B, nB, iB, uB, sB, aB]) {
            const i4 = r4(e3, t3, n3);
            if (i4 !== void 0)
              return i4;
          }
          let o3 = [];
          switch (i3.type) {
            case "JsExpressionRoot":
              return n3("node");
            case "JsonRoot":
              return [n3("node"), jT];
            case "File":
              return i3.program && i3.program.interpreter && o3.push(n3(["program", "interpreter"])), o3.push(n3("program")), o3;
            case "Program":
              return MB(e3, t3, n3);
            case "EmptyStatement":
              return "";
            case "ExpressionStatement":
              if (i3.directive)
                return [WB(i3.expression, t3), u3];
              if (t3.parser === "__vue_event_binding") {
                const t4 = e3.getParentNode();
                if (t4.type === "Program" && t4.body.length === 1 && t4.body[0] === i3)
                  return [n3("expression"), rB(i3.expression) ? ";" : ""];
              }
              return [n3("expression"), zT(t3, e3) ? "" : u3];
            case "ParenthesizedExpression":
              return !qT(i3.expression) && (i3.expression.type === "ObjectExpression" || i3.expression.type === "ArrayExpression") ? ["(", n3("expression"), ")"] : MT(["(", RT([_T, n3("expression")]), _T, ")"]);
            case "AssignmentExpression":
              return OB(e3, t3, n3);
            case "VariableDeclarator":
              return PB(e3, t3, n3);
            case "BinaryExpression":
            case "LogicalExpression":
              return IB(e3, t3, n3);
            case "AssignmentPattern":
              return [n3("left"), " = ", n3("right")];
            case "OptionalMemberExpression":
            case "MemberExpression":
              return jB(e3, t3, n3);
            case "MetaProperty":
              return [n3("meta"), ".", n3("property")];
            case "BindExpression":
              return i3.object && o3.push(n3("object")), o3.push(MT(RT([_T, lB(e3, t3, n3)]))), o3;
            case "Identifier":
              return [i3.name, cB(e3), pB(e3, t3, n3)];
            case "V8IntrinsicIdentifier":
              return ["%", i3.name];
            case "SpreadElement":
            case "SpreadElementPattern":
            case "SpreadProperty":
            case "SpreadPropertyPattern":
            case "RestElement":
              return dB(e3, t3, n3);
            case "FunctionDeclaration":
            case "FunctionExpression":
              return SB(e3, n3, t3, r3);
            case "ArrowFunctionExpression":
              return wB(e3, t3, n3, r3);
            case "YieldExpression":
              return o3.push("yield"), i3.delegate && o3.push("*"), i3.argument && o3.push(" ", n3("argument")), o3;
            case "AwaitExpression":
              if (o3.push("await"), i3.argument) {
                o3.push(" ", n3("argument"));
                const t4 = e3.getParentNode();
                if (QT(t4) && t4.callee === i3 || ZT(t4) && t4.object === i3) {
                  o3 = [RT([_T, ...o3]), _T];
                  const t5 = e3.findAncestor((e4) => e4.type === "AwaitExpression" || e4.type === "BlockStatement");
                  if (!t5 || t5.type !== "AwaitExpression")
                    return MT(o3);
                }
              }
              return o3;
            case "ExportDefaultDeclaration":
            case "ExportNamedDeclaration":
              return gB(e3, t3, n3);
            case "ExportAllDeclaration":
              return mB(e3, t3, n3);
            case "ImportDeclaration":
              return hB(e3, t3, n3);
            case "ImportSpecifier":
            case "ExportSpecifier":
            case "ImportNamespaceSpecifier":
            case "ExportNamespaceSpecifier":
            case "ImportDefaultSpecifier":
            case "ExportDefaultSpecifier":
              return yB(e3, t3, n3);
            case "ImportAttribute":
              return [n3("key"), ": ", n3("value")];
            case "Import":
              return "import";
            case "BlockStatement":
            case "StaticBlock":
            case "ClassBody":
              return _B(e3, t3, n3);
            case "ThrowStatement":
              return NB(e3, t3, n3);
            case "ReturnStatement":
              return BB(e3, t3, n3);
            case "NewExpression":
            case "ImportExpression":
            case "OptionalCallExpression":
            case "CallExpression":
              return kB(e3, t3, n3);
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              return bB(e3, t3, n3);
            case "ObjectProperty":
            case "Property":
              return i3.method || i3.kind === "get" || i3.kind === "set" ? TB(e3, t3, n3) : xB(e3, t3, n3);
            case "ObjectMethod":
              return TB(e3, t3, n3);
            case "Decorator":
              return ["@", n3("expression")];
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              return CB(e3, t3, n3);
            case "SequenceExpression": {
              const t4 = e3.getParentNode(0);
              if (t4.type === "ExpressionStatement" || t4.type === "ForStatement") {
                const t5 = [];
                return e3.each((e4, r4) => {
                  r4 === 0 ? t5.push(n3()) : t5.push(",", RT([LT, n3()]));
                }, "expressions"), MT(t5);
              }
              return MT(IT([",", LT], e3.map(n3, "expressions")));
            }
            case "ThisExpression":
              return "this";
            case "Super":
              return "super";
            case "Directive":
              return [n3("value"), u3];
            case "DirectiveLiteral":
              return WB(i3, t3);
            case "UnaryExpression":
              return o3.push(i3.operator), /[a-z]$/.test(i3.operator) && o3.push(" "), qT(i3.argument) ? o3.push(MT(["(", RT([_T, n3("argument")]), _T, ")"])) : o3.push(n3("argument")), o3;
            case "UpdateExpression":
              return o3.push(n3("argument"), i3.operator), i3.prefix && o3.reverse(), o3;
            case "ConditionalExpression":
              return DB(e3, t3, n3);
            case "VariableDeclaration": {
              const t4 = e3.map(n3, "declarations"), r4 = e3.getParentNode(), s3 = r4.type === "ForStatement" || r4.type === "ForInStatement" || r4.type === "ForOfStatement", a3 = i3.declarations.some((e4) => e4.init);
              let c2;
              return t4.length !== 1 || qT(i3.declarations[0]) ? t4.length > 0 && (c2 = RT(t4[0])) : c2 = t4[0], o3 = [i3.declare ? "declare " : "", i3.kind, c2 ? [" ", c2] : "", RT(t4.slice(1).map((e4) => [",", a3 && !s3 ? jT : LT, e4]))], s3 && r4.body !== i3 || o3.push(u3), MT(o3);
            }
            case "WithStatement":
              return MT(["with (", n3("object"), ")", fB(i3.body, n3("body"))]);
            case "IfStatement": {
              const r4 = fB(i3.consequent, n3("consequent")), u4 = MT(["if (", MT([RT([_T, n3("test")]), _T]), ")", r4]);
              if (o3.push(u4), i3.alternate) {
                const r5 = qT(i3.consequent, UT.Trailing | UT.Line) || XT(i3), u5 = i3.consequent.type === "BlockStatement" && !r5;
                o3.push(u5 ? " " : jT), qT(i3, UT.Dangling) && o3.push(PT(e3, t3, true), r5 ? jT : " "), o3.push("else", MT(fB(i3.alternate, n3("alternate"), i3.alternate.type === "IfStatement")));
              }
              return o3;
            }
            case "ForStatement": {
              const r4 = fB(i3.body, n3("body")), u4 = PT(e3, t3, true), o4 = u4 ? [u4, _T] : "";
              return i3.init || i3.test || i3.update ? [o4, MT(["for (", MT([RT([_T, n3("init"), ";", LT, n3("test"), ";", LT, n3("update")]), _T]), ")", r4])] : [o4, MT(["for (;;)", r4])];
            }
            case "WhileStatement":
              return MT(["while (", MT([RT([_T, n3("test")]), _T]), ")", fB(i3.body, n3("body"))]);
            case "ForInStatement":
              return MT(["for (", n3("left"), " in ", n3("right"), ")", fB(i3.body, n3("body"))]);
            case "ForOfStatement":
              return MT(["for", i3.await ? " await" : "", " (", n3("left"), " of ", n3("right"), ")", fB(i3.body, n3("body"))]);
            case "DoWhileStatement": {
              const e4 = fB(i3.body, n3("body"));
              return o3 = [MT(["do", e4])], i3.body.type === "BlockStatement" ? o3.push(" ") : o3.push(jT), o3.push("while (", MT([RT([_T, n3("test")]), _T]), ")", u3), o3;
            }
            case "DoExpression":
              return [i3.async ? "async " : "", "do ", n3("body")];
            case "BreakStatement":
              return o3.push("break"), i3.label && o3.push(" ", n3("label")), o3.push(u3), o3;
            case "ContinueStatement":
              return o3.push("continue"), i3.label && o3.push(" ", n3("label")), o3.push(u3), o3;
            case "LabeledStatement":
              return i3.body.type === "EmptyStatement" ? [n3("label"), ":;"] : [n3("label"), ": ", n3("body")];
            case "TryStatement":
              return ["try ", n3("block"), i3.handler ? [" ", n3("handler")] : "", i3.finalizer ? [" finally ", n3("finalizer")] : ""];
            case "CatchClause":
              if (i3.param) {
                const e4 = qT(i3.param, (e5) => !GT(e5) || e5.leading && OT(t3.originalText, tB(e5)) || e5.trailing && OT(t3.originalText, eB(e5), { backwards: true })), r4 = n3("param");
                return ["catch ", e4 ? ["(", RT([_T, r4]), _T, ") "] : ["(", r4, ") "], n3("body")];
              }
              return ["catch ", n3("body")];
            case "SwitchStatement":
              return [MT(["switch (", RT([_T, n3("discriminant")]), _T, ")"]), " {", i3.cases.length > 0 ? RT([jT, IT(jT, e3.map((e4, r4, i4) => {
                const u4 = e4.getValue();
                return [n3(), r4 !== i4.length - 1 && JT(u4, t3) ? jT : ""];
              }, "cases"))]) : "", jT, "}"];
            case "SwitchCase": {
              i3.test ? o3.push("case ", n3("test"), ":") : o3.push("default:");
              const r4 = i3.consequent.filter((e4) => e4.type !== "EmptyStatement");
              if (r4.length > 0) {
                const i4 = LB(e3, t3, n3);
                o3.push(r4.length === 1 && r4[0].type === "BlockStatement" ? [" ", i4] : RT([jT, i4]));
              }
              return o3;
            }
            case "DebuggerStatement":
              return ["debugger", u3];
            case "ClassDeclaration":
            case "ClassExpression":
              return AB(e3, t3, n3);
            case "ClassMethod":
            case "ClassPrivateMethod":
            case "MethodDefinition":
              return vB(e3, t3, n3);
            case "ClassProperty":
            case "PropertyDefinition":
            case "ClassPrivateProperty":
              return FB(e3, t3, n3);
            case "TemplateElement":
              return $T(i3.value.raw);
            case "TemplateLiteral":
              return EB(e3, n3, t3);
            case "TaggedTemplateExpression":
              return [n3("tag"), n3("typeParameters"), n3("quasi")];
            case "PrivateIdentifier":
              return ["#", n3("name")];
            case "PrivateName":
              return ["#", n3("id")];
            case "InterpreterDirective":
              return o3.push("#!", i3.value, jT), JT(i3, t3) && o3.push(jT), o3;
            case "TopicReference":
              return "%";
            case "ArgumentPlaceholder":
              return "?";
            case "ModuleExpression": {
              o3.push("module {");
              const e4 = n3("body");
              return e4 && o3.push(RT([jT, e4]), jT), o3.push("}"), o3;
            }
            default:
              throw new Error("unknown type: " + JSON.stringify(i3.type));
          }
        }(e2, t2, n2, r2);
        if (!i2)
          return "";
        const u2 = e2.getValue(), { type: o2 } = u2;
        if (o2 === "ClassMethod" || o2 === "ClassPrivateMethod" || o2 === "ClassProperty" || o2 === "PropertyDefinition" || o2 === "TSAbstractClassProperty" || o2 === "ClassPrivateProperty" || o2 === "MethodDefinition" || o2 === "TSAbstractMethodDefinition" || o2 === "TSDeclareMethod")
          return i2;
        const s2 = VB(e2, t2, n2);
        if (s2)
          return MT([...s2, i2]);
        if (!oD(e2, t2))
          return r2 && r2.needsSemi ? [";", i2] : i2;
        const a2 = [r2 && r2.needsSemi ? ";(" : "(", i2];
        if (WT(u2)) {
          const [e3] = u2.trailingComments;
          a2.push(" /*", e3.value.trimStart(), "*/"), e3.printed = true;
        }
        return a2.push(")"), a2;
      }, embed: um, insertPragma: VT, massageAstNode: lm, hasPrettierIgnore: (e2) => KT(e2) || oB(e2), willPrintOwnComments: Uy.willPrintOwnComments, canAttachComment: function(e2) {
        return e2.type && !GT(e2) && !HT(e2) && e2.type !== "EmptyStatement" && e2.type !== "TemplateElement" && e2.type !== "Import" && e2.type !== "TSEmptyBodyFunctionExpression";
      }, printComment: RB, isBlockComment: GT, handleComments: { avoidAstMutation: true, ownLine: Uy.handleOwnLineComment, endOfLine: Uy.handleEndOfLineComment, remaining: Uy.handleRemainingComment }, getCommentChildNodes: Uy.getCommentChildNodes };
      const { builders: { hardline: UB, indent: zB, join: GB } } = su;
      const HB = new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
      function JB(e2, t2) {
        const { type: n2 } = e2;
        if (n2 !== "ObjectProperty" || e2.key.type !== "Identifier") {
          if (n2 === "UnaryExpression" && e2.operator === "+")
            return t2.argument;
          if (n2 !== "ArrayExpression")
            return n2 === "TemplateLiteral" ? { type: "StringLiteral", value: e2.quasis[0].value.cooked } : void 0;
          for (const [n3, r2] of e2.elements.entries())
            r2 === null && t2.elements.splice(n3, 0, { type: "NullLiteral" });
        } else
          t2.key = { type: "StringLiteral", value: e2.key.name };
      }
      JB.ignoredProperties = HB;
      var XB = { preprocess: sD, print: function(e2, t2, n2) {
        const r2 = e2.getValue();
        switch (r2.type) {
          case "JsonRoot":
            return [n2("node"), UB];
          case "ArrayExpression": {
            if (r2.elements.length === 0)
              return "[]";
            const t3 = e2.map(() => e2.getValue() === null ? "null" : n2(), "elements");
            return ["[", zB([UB, GB([",", UB], t3)]), UB, "]"];
          }
          case "ObjectExpression":
            return r2.properties.length === 0 ? "{}" : ["{", zB([UB, GB([",", UB], e2.map(n2, "properties"))]), UB, "}"];
          case "ObjectProperty":
            return [n2("key"), ": ", n2("value")];
          case "UnaryExpression":
            return [r2.operator === "+" ? "" : r2.operator, n2("argument")];
          case "NullLiteral":
            return "null";
          case "BooleanLiteral":
            return r2.value ? "true" : "false";
          case "StringLiteral":
          case "NumericLiteral":
            return JSON.stringify(r2.value);
          case "Identifier": {
            const t3 = e2.getParentNode();
            return t3 && t3.type === "ObjectProperty" && t3.key === r2 ? JSON.stringify(r2.name) : r2.name;
          }
          case "TemplateLiteral":
            return n2(["quasis", 0]);
          case "TemplateElement":
            return JSON.stringify(r2.value.cooked);
          default:
            throw new Error("unknown type: " + JSON.stringify(r2.type));
        }
      }, massageAstNode: JB };
      const YB = "Common";
      var KB = { bracketSpacing: { since: "0.0.0", category: YB, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: YB, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: YB, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: YB, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." } };
      const QB = "JavaScript";
      var ZB = { arrowParens: { since: "1.9.0", category: QB, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: KB.bracketSameLine, bracketSpacing: KB.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: QB, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: QB, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: KB.singleQuote, jsxSingleQuote: { since: "1.15.0", category: QB, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: QB, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: QB, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] } }, eN = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".jsb", ".jscad", ".jsfl", ".jsm", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 }, tN = { name: "TypeScript", type: "programming", color: "#2b7489", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 }, nN = { name: "TSX", type: "programming", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 }, rN = { name: "JSON", type: "data", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", extensions: [".json", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".htmlhintrc", ".imgbotconfig", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 }, iN = { name: "JSON with Comments", type: "data", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 }, uN = { name: "JSON5", type: "data", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
      var oN = { languages: [rh(eN, (e2) => ({ since: "0.0.0", parsers: ["babel", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...e2.interpreters, "zx"], extensions: [...e2.extensions.filter((e3) => e3 !== ".jsx"), ".wxs"] })), rh(eN, () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), rh(eN, () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), rh(tN, () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), rh(nN, () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), rh(rN, () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [], filenames: ["package.json", "package-lock.json", "composer.json"] })), rh(rN, (e2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: e2.extensions.filter((e3) => e3 !== ".jsonl") })), rh(iN, (e2) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...e2.filenames, ".eslintrc"] })), rh(uN, () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], options: ZB, printers: { estree: qB, "estree-json": XB }, parsers: void 0 };
      const { isFrontMatterNode: sN } = Fi, aN = new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
      function cN(e2, t2, n2) {
        if (sN(e2) && e2.lang === "yaml" && delete t2.value, e2.type === "css-comment" && n2.type === "css-root" && n2.nodes.length > 0) {
          if ((n2.nodes[0] === e2 || sN(n2.nodes[0]) && n2.nodes[1] === e2) && (delete t2.text, /^\*\s*@(?:format|prettier)\s*$/.test(e2.text)))
            return null;
          if (n2.type === "css-root" && _n(n2.nodes) === e2)
            return null;
        }
        if (e2.type === "value-root" && delete t2.text, e2.type !== "media-query" && e2.type !== "media-query-list" && e2.type !== "media-feature-expression" || delete t2.value, e2.type === "css-rule" && delete t2.params, e2.type === "selector-combinator" && (t2.value = t2.value.replace(/\s+/g, " ")), e2.type === "media-feature" && (t2.value = t2.value.replace(/ /g, "")), (e2.type === "value-word" && (e2.isColor && e2.isHex || ["initial", "inherit", "unset", "revert"].includes(t2.value.replace().toLowerCase())) || e2.type === "media-feature" || e2.type === "selector-root-invalid" || e2.type === "selector-pseudo") && (t2.value = t2.value.toLowerCase()), e2.type === "css-decl" && (t2.prop = t2.prop.toLowerCase()), e2.type !== "css-atrule" && e2.type !== "css-import" || (t2.name = t2.name.toLowerCase()), e2.type === "value-number" && (t2.unit = t2.unit.toLowerCase()), e2.type !== "media-feature" && e2.type !== "media-keyword" && e2.type !== "media-type" && e2.type !== "media-unknown" && e2.type !== "media-url" && e2.type !== "media-value" && e2.type !== "selector-attribute" && e2.type !== "selector-string" && e2.type !== "selector-class" && e2.type !== "selector-combinator" && e2.type !== "value-string" || !t2.value || (t2.value = t2.value.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1")), e2.type === "selector-attribute" && (t2.attribute = t2.attribute.trim(), t2.namespace && typeof t2.namespace == "string" && (t2.namespace = t2.namespace.trim(), t2.namespace.length === 0 && (t2.namespace = true)), t2.value && (t2.value = t2.value.trim().replace(/^["']|["']$/g, ""), delete t2.quoted)), e2.type !== "media-value" && e2.type !== "media-type" && e2.type !== "value-number" && e2.type !== "selector-root-invalid" && e2.type !== "selector-class" && e2.type !== "selector-combinator" && e2.type !== "selector-tag" || !t2.value || (t2.value = t2.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (e3, t3, n3) => {
          const r2 = Number(t3);
          return Number.isNaN(r2) ? e3 : r2 + n3.toLowerCase();
        })), e2.type === "selector-tag") {
          const n3 = e2.value.toLowerCase();
          ["from", "to"].includes(n3) && (t2.value = n3);
        }
        e2.type === "css-atrule" && e2.name.toLowerCase() === "supports" && delete t2.value, e2.type === "selector-unknown" && delete t2.value;
      }
      cN.ignoredProperties = aN;
      var lN = cN;
      const { builders: { hardline: pN, markAsRoot: fN } } = su;
      var dN = function(e2, t2) {
        if (e2.lang === "yaml") {
          const n2 = e2.value.trim(), r2 = n2 ? t2(n2, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
          return fN([e2.startDelimiter, pN, r2, r2 ? pN : "", e2.endDelimiter]);
        }
      };
      const { builders: { hardline: hN } } = su;
      var gN = function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (r2.type === "front-matter") {
          const e3 = dN(r2, n2);
          return e3 ? [e3, hN] : "";
        }
      };
      const mN = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
      var yN = function(e2) {
        const t2 = e2.match(mN);
        if (!t2)
          return { content: e2 };
        const { startDelimiter: n2, language: r2, value: i2 = "", endDelimiter: u2 } = t2.groups;
        let o2 = r2.trim() || "yaml";
        if (n2 === "+++" && (o2 = "toml"), o2 !== "yaml" && n2 !== u2)
          return { content: e2 };
        const [s2] = t2;
        return { frontMatter: { type: "front-matter", lang: o2, value: i2, startDelimiter: n2, endDelimiter: u2, raw: s2.replace(/\n$/, "") }, content: s2.replace(/[^\n]/g, " ") + e2.slice(s2.length) };
      };
      var DN = { hasPragma: function(e2) {
        return Rm.hasPragma(yN(e2).content);
      }, insertPragma: function(e2) {
        const { frontMatter: t2, content: n2 } = yN(e2);
        return (t2 ? t2.raw + "\n\n" : "") + Rm.insertPragma(n2);
      } };
      const { isNonEmptyArray: EN } = Fi, CN = new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]), bN = new Set(["import", "use", "forward"]);
      function AN(e2, t2) {
        const n2 = Array.isArray(t2) ? t2 : [t2];
        let r2, i2 = -1;
        for (; r2 = e2.getParentNode(++i2); )
          if (n2.includes(r2.type))
            return i2;
        return -1;
      }
      function vN(e2, t2) {
        const n2 = AN(e2, t2);
        return n2 === -1 ? null : e2.getParentNode(n2);
      }
      function FN(e2) {
        return e2.type === "value-operator" && e2.value === "*";
      }
      function xN(e2) {
        return e2.type === "value-operator" && e2.value === "/";
      }
      function SN(e2) {
        return e2.type === "value-operator" && e2.value === "+";
      }
      function wN(e2) {
        return e2.type === "value-operator" && e2.value === "-";
      }
      function TN(e2) {
        return e2.type === "value-operator" && e2.value === "%";
      }
      function BN(e2) {
        return e2.type === "value-comma_group" && e2.groups && e2.groups[1] && e2.groups[1].type === "value-colon";
      }
      function NN(e2) {
        return e2.type === "value-paren_group" && e2.groups && e2.groups[0] && BN(e2.groups[0]);
      }
      function kN(e2) {
        return e2 && e2.type === "value-colon";
      }
      var PN = { getAncestorCounter: AN, getAncestorNode: vN, getPropOfDeclNode: function(e2) {
        const t2 = vN(e2, "css-decl");
        return t2 && t2.prop && t2.prop.toLowerCase();
      }, hasSCSSInterpolation: function(e2) {
        if (EN(e2)) {
          for (let t2 = e2.length - 1; t2 > 0; t2--)
            if (e2[t2].type === "word" && e2[t2].value === "{" && e2[t2 - 1].type === "word" && e2[t2 - 1].value.endsWith("#"))
              return true;
        }
        return false;
      }, hasStringOrFunction: function(e2) {
        if (EN(e2)) {
          for (let t2 = 0; t2 < e2.length; t2++)
            if (e2[t2].type === "string" || e2[t2].type === "func")
              return true;
        }
        return false;
      }, maybeToLowerCase: function(e2) {
        return e2.includes("$") || e2.includes("@") || e2.includes("#") || e2.startsWith("%") || e2.startsWith("--") || e2.startsWith(":--") || e2.includes("(") && e2.includes(")") ? e2 : e2.toLowerCase();
      }, insideValueFunctionNode: function(e2, t2) {
        const n2 = vN(e2, "value-func");
        return n2 && n2.value && n2.value.toLowerCase() === t2;
      }, insideICSSRuleNode: function(e2) {
        const t2 = vN(e2, "css-rule");
        return t2 && t2.raws && t2.raws.selector && (t2.raws.selector.startsWith(":import") || t2.raws.selector.startsWith(":export"));
      }, insideAtRuleNode: function(e2, t2) {
        const n2 = Array.isArray(t2) ? t2 : [t2], r2 = vN(e2, "css-atrule");
        return r2 && n2.includes(r2.name.toLowerCase());
      }, insideURLFunctionInImportAtRuleNode: function(e2) {
        const t2 = e2.getValue(), n2 = vN(e2, "css-atrule");
        return n2 && n2.name === "import" && t2.groups[0].value === "url" && t2.groups.length === 2;
      }, isKeyframeAtRuleKeywords: function(e2, t2) {
        const n2 = vN(e2, "css-atrule");
        return n2 && n2.name && n2.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(t2.toLowerCase());
      }, isWideKeywords: function(e2) {
        return ["initial", "inherit", "unset", "revert"].includes(e2.toLowerCase());
      }, isSCSS: function(e2, t2) {
        return e2 === "less" || e2 === "scss" ? e2 === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(t2);
      }, isSCSSVariable: function(e2) {
        return Boolean(e2 && e2.type === "word" && e2.value.startsWith("$"));
      }, isLastNode: function(e2, t2) {
        const n2 = e2.getParentNode();
        if (!n2)
          return false;
        const { nodes: r2 } = n2;
        return r2 && r2.indexOf(t2) === r2.length - 1;
      }, isLessParser: function(e2) {
        return e2.parser === "css" || e2.parser === "less";
      }, isSCSSControlDirectiveNode: function(e2) {
        return e2.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(e2.name);
      }, isDetachedRulesetDeclarationNode: function(e2) {
        return !!e2.selector && (typeof e2.selector == "string" && /^@.+:.*$/.test(e2.selector) || e2.selector.value && /^@.+:.*$/.test(e2.selector.value));
      }, isRelationalOperatorNode: function(e2) {
        return e2.type === "value-word" && ["<", ">", "<=", ">="].includes(e2.value);
      }, isEqualityOperatorNode: function(e2) {
        return e2.type === "value-word" && ["==", "!="].includes(e2.value);
      }, isMultiplicationNode: FN, isDivisionNode: xN, isAdditionNode: SN, isSubtractionNode: wN, isModuloNode: TN, isMathOperatorNode: function(e2) {
        return FN(e2) || xN(e2) || SN(e2) || wN(e2) || TN(e2);
      }, isEachKeywordNode: function(e2) {
        return e2.type === "value-word" && e2.value === "in";
      }, isForKeywordNode: function(e2) {
        return e2.type === "value-word" && ["from", "through", "end"].includes(e2.value);
      }, isURLFunctionNode: function(e2) {
        return e2.type === "value-func" && e2.value.toLowerCase() === "url";
      }, isIfElseKeywordNode: function(e2) {
        return e2.type === "value-word" && ["and", "or", "not"].includes(e2.value);
      }, hasComposesNode: function(e2) {
        return e2.value && e2.value.type === "value-root" && e2.value.group && e2.value.group.type === "value-value" && e2.prop.toLowerCase() === "composes";
      }, hasParensAroundNode: function(e2) {
        return e2.value && e2.value.group && e2.value.group.group && e2.value.group.group.type === "value-paren_group" && e2.value.group.group.open !== null && e2.value.group.group.close !== null;
      }, hasEmptyRawBefore: function(e2) {
        return e2.raws && e2.raws.before === "";
      }, isSCSSNestedPropertyNode: function(e2) {
        return !!e2.selector && e2.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
      }, isDetachedRulesetCallNode: function(e2) {
        return e2.raws && e2.raws.params && /^\(\s*\)$/.test(e2.raws.params);
      }, isTemplatePlaceholderNode: function(e2) {
        return e2.name.startsWith("prettier-placeholder");
      }, isTemplatePropNode: function(e2) {
        return e2.prop.startsWith("@prettier-placeholder");
      }, isPostcssSimpleVarNode: function(e2, t2) {
        return e2.value === "$$" && e2.type === "value-func" && t2 && t2.type === "value-word" && !t2.raws.before;
      }, isKeyValuePairNode: BN, isKeyValuePairInParenGroupNode: NN, isKeyInValuePairNode: function(e2, t2) {
        if (!BN(t2))
          return false;
        const { groups: n2 } = t2, r2 = n2.indexOf(e2);
        return r2 !== -1 && kN(n2[r2 + 1]);
      }, isSCSSMapItemNode: function(e2) {
        const t2 = e2.getValue();
        if (t2.groups.length === 0)
          return false;
        const n2 = e2.getParentNode(1);
        if (!(NN(t2) || n2 && NN(n2)))
          return false;
        const r2 = vN(e2, "css-decl");
        return !!(r2 && r2.prop && r2.prop.startsWith("$")) || (!!NN(n2) || n2.type === "value-func");
      }, isInlineValueCommentNode: function(e2) {
        return e2.type === "value-comment" && e2.inline;
      }, isHashNode: function(e2) {
        return e2.type === "value-word" && e2.value === "#";
      }, isLeftCurlyBraceNode: function(e2) {
        return e2.type === "value-word" && e2.value === "{";
      }, isRightCurlyBraceNode: function(e2) {
        return e2.type === "value-word" && e2.value === "}";
      }, isWordNode: function(e2) {
        return ["value-word", "value-atword"].includes(e2.type);
      }, isColonNode: kN, isMediaAndSupportsKeywords: function(e2) {
        return e2.value && ["not", "and", "or"].includes(e2.value.toLowerCase());
      }, isColorAdjusterFuncNode: function(e2) {
        return e2.type === "value-func" && CN.has(e2.value.toLowerCase());
      }, lastLineHasInlineComment: function(e2) {
        return /\/\//.test(e2.split(/[\n\r]/).pop());
      }, stringifyNode: function e2(t2) {
        if (t2.groups) {
          return (t2.open && t2.open.value ? t2.open.value : "") + t2.groups.reduce((n3, r3, i2) => n3 + e2(r3) + (t2.groups[0].type === "comma_group" && i2 !== t2.groups.length - 1 ? "," : ""), "") + (t2.close && t2.close.value ? t2.close.value : "");
        }
        const n2 = t2.raws && t2.raws.before ? t2.raws.before : "", r2 = t2.raws && t2.raws.quote ? t2.raws.quote : "";
        return n2 + r2 + (t2.type === "atword" ? "@" : "") + (t2.value ? t2.value : "") + r2 + (t2.unit ? t2.unit : "") + (t2.group ? e2(t2.group) : "") + (t2.raws && t2.raws.after ? t2.raws.after : "");
      }, isAtWordPlaceholderNode: function(e2) {
        return e2 && e2.type === "value-atword" && e2.value.startsWith("prettier-placeholder-");
      }, isModuleRuleName: function(e2) {
        return bN.has(e2);
      } }, ON = function(e2, t2) {
        let n2 = 0;
        for (let r2 = 0; r2 < e2.line - 1; ++r2)
          n2 = t2.indexOf("\n", n2) + 1;
        return n2 + e2.column;
      };
      const { getLast: IN, skipEverythingButNewLine: LN } = Fi;
      function jN(e2, t2) {
        return typeof e2.sourceIndex == "number" ? e2.sourceIndex : e2.source ? ON(e2.source.start, t2) - 1 : null;
      }
      function _N(e2, t2) {
        if (e2.type === "css-comment" && e2.inline)
          return LN(t2, e2.source.startOffset);
        const n2 = e2.nodes && IN(e2.nodes);
        return n2 && e2.source && !e2.source.end && (e2 = n2), e2.source && e2.source.end ? ON(e2.source.end, t2) : null;
      }
      function MN(e2, t2, n2) {
        e2.source && (e2.source.startOffset = jN(e2, n2) + t2, e2.source.endOffset = _N(e2, n2) + t2);
        for (const r2 in e2) {
          const i2 = e2[r2];
          r2 !== "source" && i2 && typeof i2 == "object" && MN(i2, t2, n2);
        }
      }
      function RN(e2) {
        let t2 = e2.source.startOffset;
        return typeof e2.prop == "string" && (t2 += e2.prop.length), e2.type === "css-atrule" && typeof e2.name == "string" && (t2 += 1 + e2.name.length + e2.raws.afterName.match(/^\s*:?\s*/)[0].length), e2.type !== "css-atrule" && e2.raws && typeof e2.raws.between == "string" && (t2 += e2.raws.between.length), t2;
      }
      var $N = { locStart: function(e2) {
        return e2.source.startOffset;
      }, locEnd: function(e2) {
        return e2.source.endOffset;
      }, calculateLoc: function e2(t2, n2) {
        t2.source && (t2.source.startOffset = jN(t2, n2), t2.source.endOffset = _N(t2, n2));
        for (const r2 in t2) {
          const i2 = t2[r2];
          r2 !== "source" && i2 && typeof i2 == "object" && (i2.type === "value-root" || i2.type === "value-unknown" ? MN(i2, RN(t2), i2.text || i2.value) : e2(i2, n2));
        }
      }, replaceQuotesInInlineComments: function(e2) {
        let t2, n2 = "initial", r2 = "initial", i2 = false;
        const u2 = [];
        for (let o2 = 0; o2 < e2.length; o2++) {
          const s2 = e2[o2];
          switch (n2) {
            case "initial":
              if (s2 === "'") {
                n2 = "single-quotes";
                continue;
              }
              if (s2 === '"') {
                n2 = "double-quotes";
                continue;
              }
              if ((s2 === "u" || s2 === "U") && e2.slice(o2, o2 + 4).toLowerCase() === "url(") {
                n2 = "url", o2 += 3;
                continue;
              }
              if (s2 === "*" && e2[o2 - 1] === "/") {
                n2 = "comment-block";
                continue;
              }
              if (s2 === "/" && e2[o2 - 1] === "/") {
                n2 = "comment-inline", t2 = o2 - 1;
                continue;
              }
              continue;
            case "single-quotes":
              if (s2 === "'" && e2[o2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
                return e2;
              continue;
            case "double-quotes":
              if (s2 === '"' && e2[o2 - 1] !== "\\" && (n2 = r2, r2 = "initial"), s2 === "\n" || s2 === "\r")
                return e2;
              continue;
            case "url":
              if (s2 === ")" && (n2 = "initial"), s2 === "\n" || s2 === "\r")
                return e2;
              if (s2 === "'") {
                n2 = "single-quotes", r2 = "url";
                continue;
              }
              if (s2 === '"') {
                n2 = "double-quotes", r2 = "url";
                continue;
              }
              continue;
            case "comment-block":
              s2 === "/" && e2[o2 - 1] === "*" && (n2 = "initial");
              continue;
            case "comment-inline":
              s2 !== '"' && s2 !== "'" && s2 !== "*" || (i2 = true), s2 !== "\n" && s2 !== "\r" || (i2 && u2.push([t2, o2]), n2 = "initial", i2 = false);
              continue;
          }
        }
        for (const [t3, n3] of u2)
          e2 = e2.slice(0, t3) + e2.slice(t3, n3).replace(/["'*]/g, " ") + e2.slice(n3);
        return e2;
      } };
      const { printNumber: VN, printString: WN, hasNewline: qN, isFrontMatterNode: UN, isNextLineEmpty: zN, isNonEmptyArray: GN } = Fi, { builders: { join: HN, line: JN, hardline: XN, softline: YN, group: KN, fill: QN, indent: ZN, dedent: ek, ifBreak: tk, breakParent: nk }, utils: { removeLines: rk, getDocParts: ik } } = su, { insertPragma: uk } = DN, { getAncestorNode: ok, getPropOfDeclNode: sk, maybeToLowerCase: ak, insideValueFunctionNode: ck, insideICSSRuleNode: lk, insideAtRuleNode: pk, insideURLFunctionInImportAtRuleNode: fk, isKeyframeAtRuleKeywords: dk, isWideKeywords: hk, isSCSS: gk, isLastNode: mk, isLessParser: yk, isSCSSControlDirectiveNode: Dk, isDetachedRulesetDeclarationNode: Ek, isRelationalOperatorNode: Ck, isEqualityOperatorNode: bk, isMultiplicationNode: Ak, isDivisionNode: vk, isAdditionNode: Fk, isSubtractionNode: xk, isMathOperatorNode: Sk, isEachKeywordNode: wk, isForKeywordNode: Tk, isURLFunctionNode: Bk, isIfElseKeywordNode: Nk, hasComposesNode: kk, hasParensAroundNode: Pk, hasEmptyRawBefore: Ok, isKeyValuePairNode: Ik, isKeyInValuePairNode: Lk, isDetachedRulesetCallNode: jk, isTemplatePlaceholderNode: _k, isTemplatePropNode: Mk, isPostcssSimpleVarNode: Rk, isSCSSMapItemNode: $k, isInlineValueCommentNode: Vk, isHashNode: Wk, isLeftCurlyBraceNode: qk, isRightCurlyBraceNode: Uk, isWordNode: zk, isColonNode: Gk, isMediaAndSupportsKeywords: Hk, isColorAdjusterFuncNode: Jk, lastLineHasInlineComment: Xk, isAtWordPlaceholderNode: Yk } = PN, { locStart: Kk, locEnd: Qk } = $N;
      function Zk(e2) {
        return e2.trailingComma === "es5" || e2.trailingComma === "all";
      }
      function eP(e2, t2, n2) {
        const r2 = [];
        return e2.each((e3, i2, u2) => {
          const o2 = u2[i2 - 1];
          if (o2 && o2.type === "css-comment" && o2.text.trim() === "prettier-ignore") {
            const n3 = e3.getValue();
            r2.push(t2.originalText.slice(Kk(n3), Qk(n3)));
          } else
            r2.push(n2());
          i2 !== u2.length - 1 && (u2[i2 + 1].type === "css-comment" && !qN(t2.originalText, Kk(u2[i2 + 1]), { backwards: true }) && !UN(u2[i2]) || u2[i2 + 1].type === "css-atrule" && u2[i2 + 1].name === "else" && u2[i2].type !== "css-comment" ? r2.push(" ") : (r2.push(t2.__isHTMLStyleAttribute ? JN : XN), zN(t2.originalText, e3.getValue(), Qk) && !UN(u2[i2]) && r2.push(XN)));
        }, "nodes"), r2;
      }
      const tP = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, nP = new RegExp(tP.source + `|(${/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g.source})?(${/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g.source})(${/[A-Za-z]+/g.source})?`, "g");
      function rP(e2, t2) {
        return e2.replace(tP, (e3) => WN(e3, t2));
      }
      function iP(e2, t2) {
        const n2 = t2.singleQuote ? "'" : '"';
        return e2.includes('"') || e2.includes("'") ? e2 : n2 + e2 + n2;
      }
      function uP(e2) {
        return e2.replace(nP, (e3, t2, n2, r2, i2) => !n2 && r2 ? oP(r2) + ak(i2 || "") : e3);
      }
      function oP(e2) {
        return VN(e2).replace(/\.0(?=$|e)/, "");
      }
      var sP = { print: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (!r2)
          return "";
        if (typeof r2 == "string")
          return r2;
        switch (r2.type) {
          case "front-matter":
            return [r2.raw, XN];
          case "css-root": {
            const i2 = eP(e2, t2, n2), u2 = r2.raws.after.trim();
            return [i2, u2 ? ` ${u2}` : "", ik(i2).length > 0 ? XN : ""];
          }
          case "css-comment": {
            const e3 = r2.inline || r2.raws.inline, n3 = t2.originalText.slice(Kk(r2), Qk(r2));
            return e3 ? n3.trimEnd() : n3;
          }
          case "css-rule":
            return [n2("selector"), r2.important ? " !important" : "", r2.nodes ? [r2.selector && r2.selector.type === "selector-unknown" && Xk(r2.selector.value) ? JN : " ", "{", r2.nodes.length > 0 ? ZN([XN, eP(e2, t2, n2)]) : "", XN, "}", Ek(r2) ? ";" : ""] : ";"];
          case "css-decl": {
            const i2 = e2.getParentNode(), { between: u2 } = r2.raws, o2 = u2.trim(), s2 = o2 === ":";
            let a2 = kk(r2) ? rk(n2("value")) : n2("value");
            return !s2 && Xk(o2) && (a2 = ZN([XN, ek(a2)])), [r2.raws.before.replace(/[\s;]/g, ""), lk(e2) ? r2.prop : ak(r2.prop), o2.startsWith("//") ? " " : "", o2, r2.extend ? "" : " ", yk(t2) && r2.extend && r2.selector ? ["extend(", n2("selector"), ")"] : "", a2, r2.raws.important ? r2.raws.important.replace(/\s*!\s*important/i, " !important") : r2.important ? " !important" : "", r2.raws.scssDefault ? r2.raws.scssDefault.replace(/\s*!default/i, " !default") : r2.scssDefault ? " !default" : "", r2.raws.scssGlobal ? r2.raws.scssGlobal.replace(/\s*!global/i, " !global") : r2.scssGlobal ? " !global" : "", r2.nodes ? [" {", ZN([YN, eP(e2, t2, n2)]), YN, "}"] : Mk(r2) && !i2.raws.semicolon && t2.originalText[Qk(r2) - 1] !== ";" ? "" : t2.__isHTMLStyleAttribute && mk(e2, r2) ? tk(";") : ";"];
          }
          case "css-atrule": {
            const i2 = e2.getParentNode(), u2 = _k(r2) && !i2.raws.semicolon && t2.originalText[Qk(r2) - 1] !== ";";
            if (yk(t2)) {
              if (r2.mixin)
                return [n2("selector"), r2.important ? " !important" : "", u2 ? "" : ";"];
              if (r2.function)
                return [r2.name, n2("params"), u2 ? "" : ";"];
              if (r2.variable)
                return ["@", r2.name, ": ", r2.value ? n2("value") : "", r2.raws.between.trim() ? r2.raws.between.trim() + " " : "", r2.nodes ? ["{", ZN([r2.nodes.length > 0 ? YN : "", eP(e2, t2, n2)]), YN, "}"] : "", u2 ? "" : ";"];
            }
            return ["@", jk(r2) || r2.name.endsWith(":") ? r2.name : ak(r2.name), r2.params ? [jk(r2) ? "" : _k(r2) ? r2.raws.afterName === "" ? "" : r2.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(r2.raws.afterName) ? [XN, XN] : /^\s*\n/.test(r2.raws.afterName) ? XN : " " : " ", n2("params")] : "", r2.selector ? ZN([" ", n2("selector")]) : "", r2.value ? KN([" ", n2("value"), Dk(r2) ? Pk(r2) ? " " : JN : ""]) : r2.name === "else" ? " " : "", r2.nodes ? [Dk(r2) ? "" : r2.selector && !r2.selector.nodes && typeof r2.selector.value == "string" && Xk(r2.selector.value) || !r2.selector && typeof r2.params == "string" && Xk(r2.params) ? JN : " ", "{", ZN([r2.nodes.length > 0 ? YN : "", eP(e2, t2, n2)]), YN, "}"] : u2 ? "" : ";"];
          }
          case "media-query-list": {
            const t3 = [];
            return e2.each((e3) => {
              const r3 = e3.getValue();
              r3.type === "media-query" && r3.value === "" || t3.push(n2());
            }, "nodes"), KN(ZN(HN(JN, t3)));
          }
          case "media-query":
            return [HN(" ", e2.map(n2, "nodes")), mk(e2, r2) ? "" : ","];
          case "media-type":
            return uP(rP(r2.value, t2));
          case "media-feature-expression":
            return r2.nodes ? ["(", ...e2.map(n2, "nodes"), ")"] : r2.value;
          case "media-feature":
            return ak(rP(r2.value.replace(/ +/g, " "), t2));
          case "media-colon":
            return [r2.value, " "];
          case "media-value":
            return uP(rP(r2.value, t2));
          case "media-keyword":
            return rP(r2.value, t2);
          case "media-url":
            return rP(r2.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), t2);
          case "media-unknown":
            return r2.value;
          case "selector-root":
            return KN([pk(e2, "custom-selector") ? [ok(e2, "css-atrule").customSelector, JN] : "", HN([",", pk(e2, ["extend", "custom-selector", "nest"]) ? JN : XN], e2.map(n2, "nodes"))]);
          case "selector-selector":
            return KN(ZN(e2.map(n2, "nodes")));
          case "selector-comment":
            return r2.value;
          case "selector-string":
            return rP(r2.value, t2);
          case "selector-tag": {
            const t3 = e2.getParentNode(), n3 = t3 && t3.nodes.indexOf(r2), i2 = n3 && t3.nodes[n3 - 1];
            return [r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", i2.type === "selector-nesting" ? r2.value : uP(dk(e2, r2.value) ? r2.value.toLowerCase() : r2.value)];
          }
          case "selector-id":
            return ["#", r2.value];
          case "selector-class":
            return [".", uP(rP(r2.value, t2))];
          case "selector-attribute":
            return ["[", r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", r2.attribute.trim(), r2.operator ? r2.operator : "", r2.value ? iP(rP(r2.value.trim(), t2), t2) : "", r2.insensitive ? " i" : "", "]"];
          case "selector-combinator":
            if (r2.value === "+" || r2.value === ">" || r2.value === "~" || r2.value === ">>>") {
              const t3 = e2.getParentNode();
              return [t3.type === "selector-selector" && t3.nodes[0] === r2 ? "" : JN, r2.value, mk(e2, r2) ? "" : " "];
            }
            return [r2.value.trim().startsWith("(") ? JN : "", uP(rP(r2.value.trim(), t2)) || JN];
          case "selector-universal":
            return [r2.namespace ? [r2.namespace === true ? "" : r2.namespace.trim(), "|"] : "", r2.value];
          case "selector-pseudo":
            return [ak(r2.value), GN(r2.nodes) ? ["(", HN(", ", e2.map(n2, "nodes")), ")"] : ""];
          case "selector-nesting":
            return r2.value;
          case "selector-unknown": {
            const n3 = ok(e2, "css-rule");
            if (n3 && n3.isSCSSNesterProperty)
              return uP(rP(ak(r2.value), t2));
            const i2 = e2.getParentNode();
            if (i2.raws && i2.raws.selector) {
              const e3 = Kk(i2), n4 = e3 + i2.raws.selector.length;
              return t2.originalText.slice(e3, n4).trim();
            }
            const u2 = e2.getParentNode(1);
            if (i2.type === "value-paren_group" && u2 && u2.type === "value-func" && u2.value === "selector") {
              const e3 = Kk(i2.open) + 1, n4 = Qk(i2.close) - 1, r3 = t2.originalText.slice(e3, n4).trim();
              return Xk(r3) ? [nk, r3] : r3;
            }
            return r2.value;
          }
          case "value-value":
          case "value-root":
            return n2("group");
          case "value-comment":
            return t2.originalText.slice(Kk(r2), Qk(r2));
          case "value-comma_group": {
            const t3 = e2.getParentNode(), i2 = e2.getParentNode(1), u2 = sk(e2), o2 = u2 && t3.type === "value-value" && (u2 === "grid" || u2.startsWith("grid-template")), s2 = ok(e2, "css-atrule"), a2 = s2 && Dk(s2), c2 = r2.groups.some((e3) => Vk(e3)), l2 = e2.map(n2, "groups"), p2 = [], f2 = ck(e2, "url");
            let d2 = false, h2 = false;
            for (let n3 = 0; n3 < r2.groups.length; ++n3) {
              p2.push(l2[n3]);
              const u3 = r2.groups[n3 - 1], c3 = r2.groups[n3], g2 = r2.groups[n3 + 1], m2 = r2.groups[n3 + 2];
              if (f2) {
                (g2 && Fk(g2) || Fk(c3)) && p2.push(" ");
                continue;
              }
              if (pk(e2, "forward") && c3.type === "value-word" && c3.value && u3.type === "value-word" && u3.value === "as" && g2.type === "value-operator" && g2.value === "*")
                continue;
              if (!g2)
                continue;
              if (c3.type === "value-word" && c3.value.endsWith("-") && Yk(g2))
                continue;
              const y2 = c3.type === "value-string" && c3.value.startsWith("#{"), D2 = d2 && g2.type === "value-string" && g2.value.endsWith("}");
              if (y2 || D2) {
                d2 = !d2;
                continue;
              }
              if (d2)
                continue;
              if (Gk(c3) || Gk(g2))
                continue;
              if (c3.type === "value-atword" && c3.value === "")
                continue;
              if (c3.value === "~")
                continue;
              if (c3.value && c3.value.includes("\\") && g2 && g2.type !== "value-comment")
                continue;
              if (u3 && u3.value && u3.value.indexOf("\\") === u3.value.length - 1 && c3.type === "value-operator" && c3.value === "/")
                continue;
              if (c3.value === "\\")
                continue;
              if (Rk(c3, g2))
                continue;
              if (Wk(c3) || qk(c3) || Uk(g2) || qk(g2) && Ok(g2) || Uk(c3) && Ok(g2))
                continue;
              if (c3.value === "--" && Wk(g2))
                continue;
              const E2 = Sk(c3), C2 = Sk(g2);
              if ((E2 && Wk(g2) || C2 && Uk(c3)) && Ok(g2))
                continue;
              if (!u3 && vk(c3))
                continue;
              if (ck(e2, "calc") && (Fk(c3) || Fk(g2) || xk(c3) || xk(g2)) && Ok(g2))
                continue;
              const b2 = (Fk(c3) || xk(c3)) && n3 === 0 && (g2.type === "value-number" || g2.isHex) && i2 && Jk(i2) && !Ok(g2), A2 = m2 && m2.type === "value-func" || m2 && zk(m2) || c3.type === "value-func" || zk(c3), v2 = g2.type === "value-func" || zk(g2) || u3 && u3.type === "value-func" || u3 && zk(u3);
              if (Ak(g2) || Ak(c3) || ck(e2, "calc") || b2 || !(vk(g2) && !A2 || vk(c3) && !v2 || Fk(g2) && !A2 || Fk(c3) && !v2 || xk(g2) || xk(c3)) || !(Ok(g2) || E2 && (!u3 || u3 && Sk(u3))))
                if (Vk(c3)) {
                  if (t3.type === "value-paren_group") {
                    p2.push(ek(XN));
                    continue;
                  }
                  p2.push(XN);
                } else
                  a2 && (bk(g2) || Ck(g2) || Nk(g2) || wk(c3) || Tk(c3)) || s2 && s2.name.toLowerCase() === "namespace" ? p2.push(" ") : o2 ? c3.source && g2.source && c3.source.start.line !== g2.source.start.line ? (p2.push(XN), h2 = true) : p2.push(" ") : C2 ? p2.push(" ") : g2 && g2.value === "..." || Yk(c3) && Yk(g2) && Qk(c3) === Kk(g2) || p2.push(JN);
            }
            return c2 && p2.push(nk), h2 && p2.unshift(XN), a2 ? KN(ZN(p2)) : fk(e2) ? KN(QN(p2)) : KN(ZN(QN(p2)));
          }
          case "value-paren_group": {
            const i2 = e2.getParentNode();
            if (i2 && Bk(i2) && (r2.groups.length === 1 || r2.groups.length > 0 && r2.groups[0].type === "value-comma_group" && r2.groups[0].groups.length > 0 && r2.groups[0].groups[0].type === "value-word" && r2.groups[0].groups[0].value.startsWith("data:")))
              return [r2.open ? n2("open") : "", HN(",", e2.map(n2, "groups")), r2.close ? n2("close") : ""];
            if (!r2.open) {
              const t3 = e2.map(n2, "groups"), r3 = [];
              for (let e3 = 0; e3 < t3.length; e3++)
                e3 !== 0 && r3.push([",", JN]), r3.push(t3[e3]);
              return KN(ZN(QN(r3)));
            }
            const u2 = $k(e2), o2 = _n(r2.groups), s2 = o2 && o2.type === "value-comment", a2 = Lk(r2, i2), c2 = KN([r2.open ? n2("open") : "", ZN([YN, HN([",", JN], e2.map((e3) => {
              const t3 = e3.getValue(), r3 = n2();
              if (Ik(t3) && t3.type === "value-comma_group" && t3.groups && t3.groups[0].type !== "value-paren_group" && t3.groups[2] && t3.groups[2].type === "value-paren_group") {
                const e4 = ik(r3.contents.contents);
                return e4[1] = KN(e4[1]), KN(ek(r3));
              }
              return r3;
            }, "groups"))]), tk(!s2 && gk(t2.parser, t2.originalText) && u2 && Zk(t2) ? "," : ""), YN, r2.close ? n2("close") : ""], { shouldBreak: u2 && !a2 });
            return a2 ? ek(c2) : c2;
          }
          case "value-func":
            return [r2.value, pk(e2, "supports") && Hk(r2) ? " " : "", n2("group")];
          case "value-paren":
            return r2.value;
          case "value-number":
            return [oP(r2.value), ak(r2.unit)];
          case "value-operator":
            return r2.value;
          case "value-word":
            return r2.isColor && r2.isHex || hk(r2.value) ? r2.value.toLowerCase() : r2.value;
          case "value-colon": {
            const t3 = e2.getParentNode(), n3 = t3 && t3.groups.indexOf(r2), i2 = n3 && t3.groups[n3 - 1];
            return [r2.value, i2 && typeof i2.value == "string" && _n(i2.value) === "\\" || ck(e2, "url") ? "" : JN];
          }
          case "value-comma":
            return [r2.value, " "];
          case "value-string":
            return WN(r2.raws.quote + r2.value + r2.raws.quote, t2);
          case "value-atword":
            return ["@", r2.value];
          case "value-unicode-range":
          case "value-unknown":
            return r2.value;
          default:
            throw new Error(`Unknown postcss type ${JSON.stringify(r2.type)}`);
        }
      }, embed: gN, insertPragma: uk, massageAstNode: lN }, aP = { singleQuote: KB.singleQuote }, cP = { name: "PostCSS", type: "markup", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 }, lP = { name: "Less", type: "markup", color: "#1d365d", extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 }, pP = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
      var fP = { languages: [rh({ name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 }, (e2) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...e2.extensions, ".wxss"] })), rh(cP, () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), rh(lP, () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), rh(pP, () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], options: aP, printers: { postcss: sP }, parsers: void 0 };
      var dP = { locStart: function(e2) {
        return e2.loc.start.offset;
      }, locEnd: function(e2) {
        return e2.loc.end.offset;
      } };
      function hP(e2, t2) {
        if (e2.type === "TextNode") {
          const n2 = e2.chars.trim();
          if (!n2)
            return null;
          t2.chars = n2.replace(/[\t\n\f\r ]+/g, " ");
        }
        e2.type === "AttrNode" && e2.name.toLowerCase() === "class" && delete t2.value;
      }
      hP.ignoredProperties = new Set(["loc", "selfClosing"]);
      var gP = hP;
      const mP = new Set(["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"]);
      function yP(e2) {
        return DP(e2, ["TextNode"]) && !/\S/.test(e2.chars);
      }
      function DP(e2, t2) {
        return e2 && t2.includes(e2.type);
      }
      function EP(e2, t2) {
        return DP(e2.getParentNode(0), t2);
      }
      function CP(e2, t2) {
        const n2 = e2.getValue(), r2 = e2.getParentNode(0) || {}, i2 = r2.children || r2.body || r2.parts || [], u2 = i2.indexOf(n2);
        return u2 !== -1 && i2[u2 + t2];
      }
      function bP(e2, t2 = 1) {
        return CP(e2, -t2);
      }
      function AP(e2) {
        return CP(e2, 1);
      }
      function vP(e2) {
        return DP(e2, ["MustacheCommentStatement"]) && typeof e2.value == "string" && e2.value.trim() === "prettier-ignore";
      }
      var FP = { getNextNode: AP, getPreviousNode: bP, hasPrettierIgnore: function(e2) {
        const t2 = e2.getValue(), n2 = bP(e2, 2);
        return vP(t2) || vP(n2);
      }, isLastNodeOfSiblings: function(e2) {
        const t2 = e2.getValue(), n2 = e2.getParentNode(0);
        return !(!EP(e2, ["ElementNode"]) || _n(n2.children) !== t2) || !(!EP(e2, ["Block"]) || _n(n2.body) !== t2);
      }, isNextNodeOfSomeType: function(e2, t2) {
        return DP(AP(e2), t2);
      }, isNodeOfSomeType: DP, isParentOfSomeType: EP, isPreviousNodeOfSomeType: function(e2, t2) {
        return DP(bP(e2), t2);
      }, isVoid: function(e2) {
        return function(e3) {
          return DP(e3, ["ElementNode"]) && typeof e3.tag == "string" && (function(e4) {
            return e4.toUpperCase() === e4;
          }(e3.tag[0]) || e3.tag.includes("."));
        }(e2) && e2.children.every((e3) => yP(e3)) || mP.has(e2.tag);
      }, isWhitespaceNode: yP };
      const { builders: { dedent: xP, fill: SP, group: wP, hardline: TP, ifBreak: BP, indent: NP, join: kP, line: PP, softline: OP }, utils: { getDocParts: IP, replaceTextEndOfLine: LP } } = su, { isNonEmptyArray: jP } = Fi, { locStart: _P, locEnd: MP } = dP, { getNextNode: RP, getPreviousNode: $P, hasPrettierIgnore: VP, isLastNodeOfSiblings: WP, isNextNodeOfSomeType: qP, isNodeOfSomeType: UP, isParentOfSomeType: zP, isPreviousNodeOfSomeType: GP, isVoid: HP, isWhitespaceNode: JP } = FP;
      function XP(e2, t2) {
        return _P(e2) - _P(t2);
      }
      function YP(e2, t2, n2) {
        const r2 = e2.getValue().children.every((e3) => JP(e3));
        return t2.htmlWhitespaceSensitivity === "ignore" && r2 ? "" : e2.map((e3, r3) => {
          const i2 = n2();
          return r3 === 0 && t2.htmlWhitespaceSensitivity === "ignore" ? [OP, i2] : i2;
        }, "children");
      }
      function KP(e2) {
        return HP(e2) ? BP([OP, "/>"], [" />", OP]) : BP([OP, ">"], ">");
      }
      function QP(e2) {
        return [e2.escaped === false ? "{{{" : "{{", e2.strip && e2.strip.open ? "~" : ""];
      }
      function ZP(e2) {
        const t2 = e2.escaped === false ? "}}}" : "}}";
        return [e2.strip && e2.strip.close ? "~" : "", t2];
      }
      function eO(e2) {
        return [QP(e2), e2.closeStrip.open ? "~" : "", "/"];
      }
      function tO(e2) {
        const t2 = ZP(e2);
        return [e2.closeStrip.close ? "~" : "", t2];
      }
      function nO(e2) {
        return [QP(e2), e2.inverseStrip.open ? "~" : ""];
      }
      function rO(e2) {
        const t2 = ZP(e2);
        return [e2.inverseStrip.close ? "~" : "", t2];
      }
      function iO(e2, t2) {
        const n2 = e2.getValue(), r2 = function(e3) {
          return [QP(e3), e3.openStrip.open ? "~" : "", "#"];
        }(n2), i2 = function(e3) {
          const t3 = ZP(e3);
          return [e3.openStrip.close ? "~" : "", t3];
        }(n2), u2 = [DO(e2, t2)], o2 = EO(e2, t2);
        if (o2 && u2.push(PP, o2), jP(n2.program.blockParams)) {
          const e3 = CO(n2.program);
          u2.push(PP, e3);
        }
        return wP([r2, NP(u2), OP, i2]);
      }
      function uO(e2, t2) {
        return [t2.htmlWhitespaceSensitivity === "ignore" ? TP : "", nO(e2), "else", rO(e2)];
      }
      function oO(e2, t2) {
        const n2 = e2.getParentNode(1);
        return [nO(n2), "else if ", EO(e2, t2), rO(n2)];
      }
      function sO(e2, t2, n2) {
        const r2 = e2.getValue();
        if (n2.htmlWhitespaceSensitivity === "ignore") {
          return [aO(r2) ? OP : TP, eO(r2), t2("path"), tO(r2)];
        }
        return [eO(r2), t2("path"), tO(r2)];
      }
      function aO(e2) {
        return UP(e2, ["BlockStatement"]) && e2.program.body.every((e3) => JP(e3));
      }
      function cO(e2) {
        return UP(e2, ["BlockStatement"]) && e2.inverse;
      }
      function lO(e2, t2, n2) {
        if (aO(e2.getValue()))
          return "";
        const r2 = t2("program");
        return n2.htmlWhitespaceSensitivity === "ignore" ? NP([TP, r2]) : NP(r2);
      }
      function pO(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = t2("inverse"), u2 = n2.htmlWhitespaceSensitivity === "ignore" ? [TP, i2] : i2;
        return function(e3) {
          return cO(e3) && e3.inverse.body.length === 1 && UP(e3.inverse.body[0], ["BlockStatement"]) && e3.inverse.body[0].path.parts[0] === "if";
        }(r2) ? u2 : cO(r2) ? [uO(r2, n2), NP(u2)] : "";
      }
      function fO(e2) {
        return IP(kP(PP, function(e3) {
          return e3.split(/[\t\n\f\r ]+/);
        }(e2)));
      }
      function dO(e2) {
        return (e2 = typeof e2 == "string" ? e2 : "").split("\n").length - 1;
      }
      function hO(e2 = 0) {
        return new Array(Math.min(e2, 2)).fill(TP);
      }
      function gO(e2, t2) {
        const n2 = { quote: '"', regex: /"/g }, r2 = { quote: "'", regex: /'/g }, i2 = e2.singleQuote ? r2 : n2, u2 = i2 === r2 ? n2 : r2;
        let o2 = false;
        if (t2.includes(i2.quote) || t2.includes(u2.quote)) {
          o2 = (t2.match(i2.regex) || []).length > (t2.match(u2.regex) || []).length;
        }
        return o2 ? u2 : i2;
      }
      function mO(e2, t2) {
        const n2 = DO(e2, t2), r2 = EO(e2, t2);
        return r2 ? NP([n2, PP, wP(r2)]) : n2;
      }
      function yO(e2, t2) {
        const n2 = DO(e2, t2), r2 = EO(e2, t2);
        return r2 ? [NP([n2, PP, r2]), OP] : n2;
      }
      function DO(e2, t2) {
        return t2("path");
      }
      function EO(e2, t2) {
        const n2 = e2.getValue(), r2 = [];
        if (n2.params.length > 0) {
          const n3 = e2.map(t2, "params");
          r2.push(...n3);
        }
        if (n2.hash && n2.hash.pairs.length > 0) {
          const e3 = t2("hash");
          r2.push(e3);
        }
        return r2.length === 0 ? "" : kP(PP, r2);
      }
      function CO(e2) {
        return ["as |", e2.blockParams.join(" "), "|"];
      }
      var bO = { print: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (!r2)
          return "";
        if (VP(e2))
          return t2.originalText.slice(_P(r2), MP(r2));
        switch (r2.type) {
          case "Block":
          case "Program":
          case "Template":
            return wP(e2.map(n2, "body"));
          case "ElementNode": {
            const i2 = wP(function(e3, t3) {
              const n3 = e3.getValue(), r3 = ["attributes", "modifiers", "comments"].filter((e4) => jP(n3[e4])), i3 = r3.flatMap((e4) => n3[e4]).sort(XP);
              for (const n4 of r3)
                e3.each((e4) => {
                  const n5 = i3.indexOf(e4.getValue());
                  i3.splice(n5, 1, [PP, t3()]);
                }, n4);
              jP(n3.blockParams) && i3.push(PP, CO(n3));
              return ["<", n3.tag, NP(i3), KP(n3)];
            }(e2, n2)), u2 = t2.htmlWhitespaceSensitivity === "ignore" && qP(e2, ["ElementNode"]) ? OP : "";
            if (HP(r2))
              return [i2, u2];
            const o2 = ["</", r2.tag, ">"];
            return r2.children.length === 0 ? [i2, NP(o2), u2] : t2.htmlWhitespaceSensitivity === "ignore" ? [i2, NP(YP(e2, t2, n2)), TP, NP(o2), u2] : [i2, NP(wP(YP(e2, t2, n2))), NP(o2), u2];
          }
          case "BlockStatement": {
            const i2 = e2.getParentNode(1);
            return i2 && i2.inverse && i2.inverse.body.length === 1 && i2.inverse.body[0] === r2 && i2.inverse.body[0].path.parts[0] === "if" ? [oO(e2, n2), lO(e2, n2, t2), pO(e2, n2, t2)] : [iO(e2, n2), wP([lO(e2, n2, t2), pO(e2, n2, t2), sO(e2, n2, t2)])];
          }
          case "ElementModifierStatement":
            return wP(["{{", yO(e2, n2), "}}"]);
          case "MustacheStatement":
            return wP([QP(r2), yO(e2, n2), ZP(r2)]);
          case "SubExpression":
            return wP(["(", mO(e2, n2), OP, ")"]);
          case "AttrNode": {
            const e3 = r2.value.type === "TextNode";
            if (e3 && r2.value.chars === "" && _P(r2.value) === MP(r2.value))
              return r2.name;
            const i2 = e3 ? gO(t2, r2.value.chars).quote : r2.value.type === "ConcatStatement" ? gO(t2, r2.value.parts.filter((e4) => e4.type === "TextNode").map((e4) => e4.chars).join("")).quote : "", u2 = n2("value");
            return [r2.name, "=", i2, r2.name === "class" && i2 ? wP(NP(u2)) : u2, i2];
          }
          case "ConcatStatement":
            return e2.map(n2, "parts");
          case "Hash":
            return kP(PP, e2.map(n2, "pairs"));
          case "HashPair":
            return [r2.key, "=", n2("value")];
          case "TextNode": {
            let n3 = r2.chars.replace(/{{/g, "\\{{");
            const i2 = function(e3) {
              for (let t3 = 0; t3 < 2; t3++) {
                const n4 = e3.getParentNode(t3);
                if (n4 && n4.type === "AttrNode")
                  return n4.name.toLowerCase();
              }
            }(e2);
            if (i2) {
              if (i2 === "class") {
                const t3 = n3.trim().split(/\s+/).join(" ");
                let r3 = false, i3 = false;
                return zP(e2, ["ConcatStatement"]) && (GP(e2, ["MustacheStatement"]) && /^\s/.test(n3) && (r3 = true), qP(e2, ["MustacheStatement"]) && /\s$/.test(n3) && t3 !== "" && (i3 = true)), [r3 ? PP : "", t3, i3 ? PP : ""];
              }
              return LP(n3);
            }
            const u2 = /^[\t\n\f\r ]*$/.test(n3), o2 = !$P(e2), s2 = !RP(e2);
            if (t2.htmlWhitespaceSensitivity !== "ignore") {
              const t3 = /^[\t\n\f\r ]*/, r3 = /[\t\n\f\r ]*$/, i3 = s2 && zP(e2, ["Template"]), a3 = o2 && zP(e2, ["Template"]);
              if (u2) {
                if (a3 || i3)
                  return "";
                let t4 = [PP];
                const r4 = dO(n3);
                return r4 && (t4 = hO(r4)), WP(e2) && (t4 = t4.map((e3) => xP(e3))), t4;
              }
              const [c3] = n3.match(t3), [l3] = n3.match(r3);
              let p3 = [];
              if (c3) {
                p3 = [PP];
                const e3 = dO(c3);
                e3 && (p3 = hO(e3)), n3 = n3.replace(t3, "");
              }
              let f3 = [];
              if (l3) {
                if (!i3) {
                  f3 = [PP];
                  const t4 = dO(l3);
                  t4 && (f3 = hO(t4)), WP(e2) && (f3 = f3.map((e3) => xP(e3)));
                }
                n3 = n3.replace(r3, "");
              }
              return [...p3, SP(fO(n3)), ...f3];
            }
            const a2 = dO(n3);
            let c2 = function(e3) {
              return dO(((e3 = typeof e3 == "string" ? e3 : "").match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "");
            }(n3), l2 = function(e3) {
              return dO(((e3 = typeof e3 == "string" ? e3 : "").match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "");
            }(n3);
            if ((o2 || s2) && u2 && zP(e2, ["Block", "ElementNode", "Template"]))
              return "";
            u2 && a2 ? (c2 = Math.min(a2, 2), l2 = 0) : (qP(e2, ["BlockStatement", "ElementNode"]) && (l2 = Math.max(l2, 1)), GP(e2, ["BlockStatement", "ElementNode"]) && (c2 = Math.max(c2, 1)));
            let p2 = "", f2 = "";
            return l2 === 0 && qP(e2, ["MustacheStatement"]) && (f2 = " "), c2 === 0 && GP(e2, ["MustacheStatement"]) && (p2 = " "), o2 && (c2 = 0, p2 = ""), s2 && (l2 = 0, f2 = ""), n3 = n3.replace(/^[\t\n\f\r ]+/g, p2).replace(/[\t\n\f\r ]+$/, f2), [...hO(c2), SP(fO(n3)), ...hO(l2)];
          }
          case "MustacheCommentStatement": {
            const e3 = _P(r2), n3 = MP(r2), i2 = t2.originalText.charAt(e3 + 2) === "~", u2 = t2.originalText.charAt(n3 - 3) === "~", o2 = r2.value.includes("}}") ? "--" : "";
            return ["{{", i2 ? "~" : "", "!", o2, r2.value, o2, u2 ? "~" : "", "}}"];
          }
          case "PathExpression":
            return r2.original;
          case "BooleanLiteral":
            return String(r2.value);
          case "CommentStatement":
            return ["<!--", r2.value, "-->"];
          case "StringLiteral":
            return function(e3, t3) {
              const { quote: n3, regex: r3 } = gO(t3, e3);
              return [n3, e3.replace(r3, `\\${n3}`), n3];
            }(r2.value, t2);
          case "NumberLiteral":
            return String(r2.value);
          case "UndefinedLiteral":
            return "undefined";
          case "NullLiteral":
            return "null";
          default:
            throw new Error("unknown glimmer type: " + JSON.stringify(r2.type));
        }
      }, massageAstNode: gP };
      var AO = { languages: [rh({ name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 }, () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], printers: { glimmer: bO }, parsers: void 0 };
      var vO = { hasPragma: function(e2) {
        return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(e2);
      }, insertPragma: function(e2) {
        return "# @format\n\n" + e2;
      } };
      var FO = { locStart: function(e2) {
        return typeof e2.start == "number" ? e2.start : e2.loc && e2.loc.start;
      }, locEnd: function(e2) {
        return typeof e2.end == "number" ? e2.end : e2.loc && e2.loc.end;
      } };
      const { builders: { join: xO, hardline: SO, line: wO, softline: TO, group: BO, indent: NO, ifBreak: kO } } = su, { isNextLineEmpty: PO, isNonEmptyArray: OO } = Fi, { insertPragma: IO } = vO, { locStart: LO, locEnd: jO } = FO;
      function _O(e2, t2, n2) {
        if (n2.directives.length === 0)
          return "";
        const r2 = xO(wO, e2.map(t2, "directives"));
        return n2.kind === "FragmentDefinition" || n2.kind === "OperationDefinition" ? BO([wO, r2]) : [" ", BO(NO([TO, r2]))];
      }
      function MO(e2, t2, n2) {
        const r2 = e2.getValue().length;
        return e2.map((e3, i2) => {
          const u2 = n2();
          return PO(t2.originalText, e3.getValue(), jO) && i2 < r2 - 1 ? [u2, SO] : u2;
        });
      }
      function RO(e2, t2, n2) {
        const r2 = e2.getNode(), i2 = [], { interfaces: u2 } = r2, o2 = e2.map((e3) => n2(e3), "interfaces");
        for (let e3 = 0; e3 < u2.length; e3++) {
          const n3 = u2[e3];
          i2.push(o2[e3]);
          const r3 = u2[e3 + 1];
          if (r3) {
            const e4 = t2.originalText.slice(n3.loc.end, r3.loc.start), u3 = e4.includes("#"), o3 = e4.replace(/#.*/g, "").trim();
            i2.push(o3 === "," ? "," : " &", u3 ? wO : " ");
          }
        }
        return i2;
      }
      function $O() {
      }
      $O.ignoredProperties = new Set(["loc", "comments"]);
      var VO = { print: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (!r2)
          return "";
        if (typeof r2 == "string")
          return r2;
        switch (r2.kind) {
          case "Document": {
            const r3 = [];
            return e2.each((e3, i2, u2) => {
              r3.push(n2()), i2 !== u2.length - 1 && (r3.push(SO), PO(t2.originalText, e3.getValue(), jO) && r3.push(SO));
            }, "definitions"), [...r3, SO];
          }
          case "OperationDefinition": {
            const i2 = t2.originalText[LO(r2)] !== "{", u2 = Boolean(r2.name);
            return [i2 ? r2.operation : "", i2 && u2 ? [" ", n2("name")] : "", i2 && !u2 && OO(r2.variableDefinitions) ? " " : "", OO(r2.variableDefinitions) ? BO(["(", NO([TO, xO([kO("", ", "), TO], e2.map(n2, "variableDefinitions"))]), TO, ")"]) : "", _O(e2, n2, r2), r2.selectionSet && (i2 || u2) ? " " : "", n2("selectionSet")];
          }
          case "FragmentDefinition":
            return ["fragment ", n2("name"), OO(r2.variableDefinitions) ? BO(["(", NO([TO, xO([kO("", ", "), TO], e2.map(n2, "variableDefinitions"))]), TO, ")"]) : "", " on ", n2("typeCondition"), _O(e2, n2, r2), " ", n2("selectionSet")];
          case "SelectionSet":
            return ["{", NO([SO, xO(SO, e2.call((e3) => MO(e3, t2, n2), "selections"))]), SO, "}"];
          case "Field":
            return BO([r2.alias ? [n2("alias"), ": "] : "", n2("name"), r2.arguments.length > 0 ? BO(["(", NO([TO, xO([kO("", ", "), TO], e2.call((e3) => MO(e3, t2, n2), "arguments"))]), TO, ")"]) : "", _O(e2, n2, r2), r2.selectionSet ? " " : "", n2("selectionSet")]);
          case "Name":
            return r2.value;
          case "StringValue":
            return r2.block ? ['"""', SO, xO(SO, r2.value.replace(/"""/g, "\\$&").split("\n")), SO, '"""'] : ['"', r2.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
          case "IntValue":
          case "FloatValue":
          case "EnumValue":
            return r2.value;
          case "BooleanValue":
            return r2.value ? "true" : "false";
          case "NullValue":
            return "null";
          case "Variable":
            return ["$", n2("name")];
          case "ListValue":
            return BO(["[", NO([TO, xO([kO("", ", "), TO], e2.map(n2, "values"))]), TO, "]"]);
          case "ObjectValue":
            return BO(["{", t2.bracketSpacing && r2.fields.length > 0 ? " " : "", NO([TO, xO([kO("", ", "), TO], e2.map(n2, "fields"))]), TO, kO("", t2.bracketSpacing && r2.fields.length > 0 ? " " : ""), "}"]);
          case "ObjectField":
          case "Argument":
            return [n2("name"), ": ", n2("value")];
          case "Directive":
            return ["@", n2("name"), r2.arguments.length > 0 ? BO(["(", NO([TO, xO([kO("", ", "), TO], e2.call((e3) => MO(e3, t2, n2), "arguments"))]), TO, ")"]) : ""];
          case "NamedType":
            return n2("name");
          case "VariableDefinition":
            return [n2("variable"), ": ", n2("type"), r2.defaultValue ? [" = ", n2("defaultValue")] : "", _O(e2, n2, r2)];
          case "ObjectTypeExtension":
          case "ObjectTypeDefinition":
            return [n2("description"), r2.description ? SO : "", r2.kind === "ObjectTypeExtension" ? "extend " : "", "type ", n2("name"), r2.interfaces.length > 0 ? [" implements ", ...RO(e2, t2, n2)] : "", _O(e2, n2, r2), r2.fields.length > 0 ? [" {", NO([SO, xO(SO, e2.call((e3) => MO(e3, t2, n2), "fields"))]), SO, "}"] : ""];
          case "FieldDefinition":
            return [n2("description"), r2.description ? SO : "", n2("name"), r2.arguments.length > 0 ? BO(["(", NO([TO, xO([kO("", ", "), TO], e2.call((e3) => MO(e3, t2, n2), "arguments"))]), TO, ")"]) : "", ": ", n2("type"), _O(e2, n2, r2)];
          case "DirectiveDefinition":
            return [n2("description"), r2.description ? SO : "", "directive ", "@", n2("name"), r2.arguments.length > 0 ? BO(["(", NO([TO, xO([kO("", ", "), TO], e2.call((e3) => MO(e3, t2, n2), "arguments"))]), TO, ")"]) : "", r2.repeatable ? " repeatable" : "", " on ", xO(" | ", e2.map(n2, "locations"))];
          case "EnumTypeExtension":
          case "EnumTypeDefinition":
            return [n2("description"), r2.description ? SO : "", r2.kind === "EnumTypeExtension" ? "extend " : "", "enum ", n2("name"), _O(e2, n2, r2), r2.values.length > 0 ? [" {", NO([SO, xO(SO, e2.call((e3) => MO(e3, t2, n2), "values"))]), SO, "}"] : ""];
          case "EnumValueDefinition":
            return [n2("description"), r2.description ? SO : "", n2("name"), _O(e2, n2, r2)];
          case "InputValueDefinition":
            return [n2("description"), r2.description ? r2.description.block ? SO : wO : "", n2("name"), ": ", n2("type"), r2.defaultValue ? [" = ", n2("defaultValue")] : "", _O(e2, n2, r2)];
          case "InputObjectTypeExtension":
          case "InputObjectTypeDefinition":
            return [n2("description"), r2.description ? SO : "", r2.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", n2("name"), _O(e2, n2, r2), r2.fields.length > 0 ? [" {", NO([SO, xO(SO, e2.call((e3) => MO(e3, t2, n2), "fields"))]), SO, "}"] : ""];
          case "SchemaDefinition":
            return ["schema", _O(e2, n2, r2), " {", r2.operationTypes.length > 0 ? NO([SO, xO(SO, e2.call((e3) => MO(e3, t2, n2), "operationTypes"))]) : "", SO, "}"];
          case "OperationTypeDefinition":
            return [n2("operation"), ": ", n2("type")];
          case "InterfaceTypeExtension":
          case "InterfaceTypeDefinition":
            return [n2("description"), r2.description ? SO : "", r2.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", n2("name"), r2.interfaces.length > 0 ? [" implements ", ...RO(e2, t2, n2)] : "", _O(e2, n2, r2), r2.fields.length > 0 ? [" {", NO([SO, xO(SO, e2.call((e3) => MO(e3, t2, n2), "fields"))]), SO, "}"] : ""];
          case "FragmentSpread":
            return ["...", n2("name"), _O(e2, n2, r2)];
          case "InlineFragment":
            return ["...", r2.typeCondition ? [" on ", n2("typeCondition")] : "", _O(e2, n2, r2), " ", n2("selectionSet")];
          case "UnionTypeExtension":
          case "UnionTypeDefinition":
            return BO([n2("description"), r2.description ? SO : "", BO([r2.kind === "UnionTypeExtension" ? "extend " : "", "union ", n2("name"), _O(e2, n2, r2), r2.types.length > 0 ? [" =", kO("", " "), NO([kO([wO, "  "]), xO([wO, "| "], e2.map(n2, "types"))])] : ""])]);
          case "ScalarTypeExtension":
          case "ScalarTypeDefinition":
            return [n2("description"), r2.description ? SO : "", r2.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", n2("name"), _O(e2, n2, r2)];
          case "NonNullType":
            return [n2("type"), "!"];
          case "ListType":
            return ["[", n2("type"), "]"];
          default:
            throw new Error("unknown graphql type: " + JSON.stringify(r2.kind));
        }
      }, massageAstNode: $O, hasPrettierIgnore: function(e2) {
        const t2 = e2.getValue();
        return t2 && Array.isArray(t2.comments) && t2.comments.some((e3) => e3.value.trim() === "prettier-ignore");
      }, insertPragma: IO, printComment: function(e2) {
        const t2 = e2.getValue();
        if (t2.kind === "Comment")
          return "#" + t2.value.trimEnd();
        throw new Error("Not a comment: " + JSON.stringify(t2));
      }, canAttachComment: function(e2) {
        return e2.kind && e2.kind !== "Comment";
      } }, WO = { bracketSpacing: KB.bracketSpacing };
      var qO = { languages: [rh({ name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 }, () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], options: WO, printers: { graphql: VO }, parsers: void 0 };
      var UO = { locStart: function(e2) {
        return e2.position.start.offset;
      }, locEnd: function(e2) {
        return e2.position.end.offset;
      } };
      const { getLast: zO } = Fi, { locStart: GO, locEnd: HO } = UO, { cjkPattern: JO, kPattern: XO, punctuationPattern: YO } = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" }, KO = ["liquidNode", "inlineCode", "emphasis", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], QO = [...KO, "tableCell", "paragraph", "heading"], ZO = new RegExp(XO), eI = new RegExp(YO);
      function tI(e2, t2) {
        const [, n2, r2, i2] = t2.slice(e2.position.start.offset, e2.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
        return { numberText: n2, marker: r2, leadingSpaces: i2 };
      }
      var nI = { mapAst: function(e2, t2) {
        return function e3(n2, r2, i2) {
          const u2 = Object.assign({}, t2(n2, r2, i2));
          return u2.children && (u2.children = u2.children.map((t3, n3) => e3(t3, n3, [u2, ...i2]))), u2;
        }(e2, null, []);
      }, splitText: function(e2, t2) {
        const n2 = "non-cjk", r2 = "cj-letter", i2 = "cjk-punctuation", u2 = [], o2 = (t2.proseWrap === "preserve" ? e2 : e2.replace(new RegExp(`(${JO})
(${JO})`, "g"), "$1$2")).split(/([\t\n ]+)/);
        for (const [e3, t3] of o2.entries()) {
          if (e3 % 2 == 1) {
            u2.push({ type: "whitespace", value: /\n/.test(t3) ? "\n" : " " });
            continue;
          }
          if ((e3 === 0 || e3 === o2.length - 1) && t3 === "")
            continue;
          const a2 = t3.split(new RegExp(`(${JO})`));
          for (const [e4, t4] of a2.entries())
            (e4 !== 0 && e4 !== a2.length - 1 || t4 !== "") && (e4 % 2 != 0 ? s2(eI.test(t4) ? { type: "word", value: t4, kind: i2, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: t4, kind: ZO.test(t4) ? "k-letter" : r2, hasLeadingPunctuation: false, hasTrailingPunctuation: false }) : t4 !== "" && s2({ type: "word", value: t4, kind: n2, hasLeadingPunctuation: eI.test(t4[0]), hasTrailingPunctuation: eI.test(zO(t4)) }));
        }
        return u2;
        function s2(e3) {
          const t3 = zO(u2);
          var o3, s3;
          t3 && t3.type === "word" && (t3.kind === n2 && e3.kind === r2 && !t3.hasTrailingPunctuation || t3.kind === r2 && e3.kind === n2 && !e3.hasLeadingPunctuation ? u2.push({ type: "whitespace", value: " " }) : (o3 = n2, s3 = i2, t3.kind === o3 && e3.kind === s3 || t3.kind === s3 && e3.kind === o3 || [t3.value, e3.value].some((e4) => /\u3000/.test(e4)) || u2.push({ type: "whitespace", value: "" }))), u2.push(e3);
        }
      }, punctuationPattern: YO, getFencedCodeBlockValue: function(e2, t2) {
        const { value: n2 } = e2;
        return e2.position.end.offset === t2.length && n2.endsWith("\n") && t2.endsWith("\n") ? n2.slice(0, -1) : n2;
      }, getOrderedListItemInfo: tI, hasGitDiffFriendlyOrderedList: function(e2, t2) {
        if (!e2.ordered)
          return false;
        if (e2.children.length < 2)
          return false;
        const n2 = Number(tI(e2.children[0], t2.originalText).numberText), r2 = Number(tI(e2.children[1], t2.originalText).numberText);
        if (n2 === 0 && e2.children.length > 2) {
          const n3 = Number(tI(e2.children[2], t2.originalText).numberText);
          return r2 === 1 && n3 === 1;
        }
        return r2 === 1;
      }, INLINE_NODE_TYPES: KO, INLINE_NODE_WRAPPER_TYPES: QO, isAutolink: function(e2) {
        if (!e2 || e2.type !== "link" || e2.children.length !== 1)
          return false;
        const t2 = e2.children[0];
        return t2 && GO(e2) === GO(t2) && HO(e2) === HO(t2);
      } };
      const { inferParserByLanguage: rI, getMaxContinuousCount: iI } = Fi, { builders: { hardline: uI, markAsRoot: oI }, utils: { replaceEndOfLine: sI } } = su, { getFencedCodeBlockValue: aI } = nI;
      var cI = function(e2, t2, n2, r2) {
        const i2 = e2.getValue();
        if (i2.type === "code" && i2.lang !== null) {
          const e3 = rI(i2.lang, r2);
          if (e3) {
            const t3 = r2.__inJsTemplate ? "~" : "`", u2 = t3.repeat(Math.max(3, iI(i2.value, t3) + 1)), o2 = n2(aI(i2, r2.originalText), { parser: e3 }, { stripTrailingHardline: true });
            return oI([u2, i2.lang, i2.meta ? " " + i2.meta : "", uI, sI(o2), uI, u2]);
          }
        }
        switch (i2.type) {
          case "front-matter":
            return dN(i2, n2);
          case "importExport":
            return [n2(i2.value, { parser: "babel" }, { stripTrailingHardline: true }), uI];
          case "jsx":
            return n2(`<$>${i2.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
        }
        return null;
      };
      const lI = ["format", "prettier"];
      function pI(e2) {
        const t2 = `@(${lI.join("|")})`, n2 = new RegExp([`<!--\\s*${t2}\\s*-->`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${t2}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), r2 = e2.match(n2);
        return r2 && r2.index === 0;
      }
      var fI = { startWithPragma: pI, hasPragma: (e2) => pI(yN(e2).content.trimStart()), insertPragma: (e2) => {
        const t2 = yN(e2), n2 = `<!-- @${lI[0]} -->`;
        return t2.frontMatter ? `${t2.frontMatter.raw}

${n2}

${t2.content}` : `${n2}

${t2.content}`;
      } };
      const { getOrderedListItemInfo: dI, mapAst: hI, splitText: gI } = nI, mI = /^.$/us;
      function yI(e2, t2, n2) {
        return hI(e2, (e3) => {
          if (!e3.children)
            return e3;
          const r2 = e3.children.reduce((e4, r3) => {
            const i2 = _n(e4);
            return i2 && t2(i2, r3) ? e4.splice(-1, 1, n2(i2, r3)) : e4.push(r3), e4;
          }, []);
          return Object.assign(Object.assign({}, e3), {}, { children: r2 });
        });
      }
      var DI = function(e2, t2) {
        return e2 = function(e3) {
          return yI(e3, (e4, t3) => e4.type === "importExport" && t3.type === "importExport", (e4, t3) => ({ type: "importExport", value: e4.value + "\n\n" + t3.value, position: { start: e4.position.start, end: t3.position.end } }));
        }(e2 = function(e3) {
          return hI(e3, (e4) => e4.type !== "import" && e4.type !== "export" ? e4 : Object.assign(Object.assign({}, e4), {}, { type: "importExport" }));
        }(e2 = function(e3, t3) {
          return hI(e3, (e4, n2, [r2]) => {
            if (e4.type !== "text")
              return e4;
            let { value: i2 } = e4;
            return r2.type === "paragraph" && (n2 === 0 && (i2 = i2.trimStart()), n2 === r2.children.length - 1 && (i2 = i2.trimEnd())), { type: "sentence", position: e4.position, children: gI(i2, t3) };
          });
        }(e2 = function(e3, t3) {
          return hI(e3, (e4, t4, n3) => {
            if (e4.type === "list" && e4.children.length > 0) {
              for (let t5 = 0; t5 < n3.length; t5++) {
                const r3 = n3[t5];
                if (r3.type === "list" && !r3.isAligned)
                  return e4.isAligned = false, e4;
              }
              e4.isAligned = r2(e4);
            }
            return e4;
          });
          function n2(e4) {
            return e4.children.length === 0 ? -1 : e4.children[0].position.start.column - 1;
          }
          function r2(e4) {
            if (!e4.ordered)
              return true;
            const [r3, i2] = e4.children;
            if (dI(r3, t3.originalText).leadingSpaces.length > 1)
              return true;
            const u2 = n2(r3);
            if (u2 === -1)
              return false;
            if (e4.children.length === 1)
              return u2 % t3.tabWidth == 0;
            if (u2 !== n2(i2))
              return false;
            if (u2 % t3.tabWidth == 0)
              return true;
            return dI(i2, t3.originalText).leadingSpaces.length > 1;
          }
        }(e2 = function(e3, t3) {
          return hI(e3, (e4, n2, r2) => {
            if (e4.type === "code") {
              const n3 = /^\n?(?: {4,}|\t)/.test(t3.originalText.slice(e4.position.start.offset, e4.position.end.offset));
              if (e4.isIndented = n3, n3)
                for (let e5 = 0; e5 < r2.length; e5++) {
                  const t4 = r2[e5];
                  if (t4.hasIndentedCodeblock)
                    break;
                  t4.type === "list" && (t4.hasIndentedCodeblock = true);
                }
            }
            return e4;
          });
        }(e2 = function(e3) {
          return hI(e3, (e4) => e4.type !== "inlineCode" ? e4 : Object.assign(Object.assign({}, e4), {}, { value: e4.value.replace(/\s+/g, " ") }));
        }(e2 = function(e3) {
          return yI(e3, (e4, t3) => e4.type === "text" && t3.type === "text", (e4, t3) => ({ type: "text", value: e4.value + t3.value, position: { start: e4.position.start, end: t3.position.end } }));
        }(e2 = function(e3, t3) {
          return hI(e3, (e4) => e4.type === "text" && e4.value !== "*" && e4.value !== "_" && mI.test(e4.value) && e4.position.end.offset - e4.position.start.offset !== e4.value.length ? Object.assign(Object.assign({}, e4), {}, { value: t3.originalText.slice(e4.position.start.offset, e4.position.end.offset) }) : e4);
        }(e2, t2))), t2), t2), t2)));
      };
      const { isFrontMatterNode: EI } = Fi, { startWithPragma: CI } = fI, bI = new Set(["position", "raw"]);
      function AI(e2, t2, n2) {
        return e2.type !== "front-matter" && e2.type !== "code" && e2.type !== "yaml" && e2.type !== "import" && e2.type !== "export" && e2.type !== "jsx" || delete t2.value, e2.type === "list" && delete t2.isAligned, e2.type !== "list" && e2.type !== "listItem" || (delete t2.spread, delete t2.loose), e2.type === "text" ? null : (e2.type === "inlineCode" && (t2.value = e2.value.replace(/[\t\n ]+/g, " ")), e2.type === "wikiLink" && (t2.value = e2.value.trim().replace(/[\t\n]+/g, " ")), e2.type !== "definition" && e2.type !== "linkReference" || (t2.label = e2.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), e2.type !== "definition" && e2.type !== "link" && e2.type !== "image" || !e2.title || (t2.title = e2.title.replace(/\\(["')])/g, "$1")), n2 && n2.type === "root" && n2.children.length > 0 && (n2.children[0] === e2 || EI(n2.children[0]) && n2.children[1] === e2) && e2.type === "html" && CI(e2.value) ? null : void 0);
      }
      AI.ignoredProperties = bI;
      var vI = AI;
      const { getLast: FI, getMinNotPresentContinuousCount: xI, getMaxContinuousCount: SI, getStringWidth: wI, isNonEmptyArray: TI } = Fi, { builders: { breakParent: BI, join: NI, line: kI, literalline: PI, markAsRoot: OI, hardline: II, softline: LI, ifBreak: jI, fill: _I, align: MI, indent: RI, group: $I, hardlineWithoutBreakParent: VI }, utils: { normalizeDoc: WI, replaceTextEndOfLine: qI }, printer: { printDocToString: UI } } = su, { insertPragma: zI } = fI, { locStart: GI, locEnd: HI } = UO, { getFencedCodeBlockValue: JI, hasGitDiffFriendlyOrderedList: XI, splitText: YI, punctuationPattern: KI, INLINE_NODE_TYPES: QI, INLINE_NODE_WRAPPER_TYPES: ZI, isAutolink: eL } = nI, tL = new Set(["importExport"]), nL = ["heading", "tableCell", "link", "wikiLink"], rL = new Set(["listItem", "definition", "footnoteDefinition"]);
      function iL(e2, t2, n2, r2) {
        const i2 = e2.getValue(), u2 = i2.checked === null ? "" : i2.checked ? "[x] " : "[ ] ";
        return [u2, lL(e2, t2, n2, { processor: (e3, i3) => {
          if (i3 === 0 && e3.getValue().type !== "list")
            return MI(" ".repeat(u2.length), n2());
          const o2 = " ".repeat(function(e4, t3, n3) {
            return e4 < t3 ? t3 : e4 > n3 ? n3 : e4;
          }(t2.tabWidth - r2.length, 0, 3));
          return [o2, MI(o2, n2())];
        } })];
      }
      function uL(e2, t2) {
        return function(e3, t3, n2) {
          let r2 = -1;
          for (const i2 of t3.children)
            if (i2.type === e3.type && n2(i2) ? r2++ : r2 = -1, i2 === e3)
              return r2;
        }(e2, t2, (t3) => t3.ordered === e2.ordered);
      }
      function oL(e2, t2) {
        const n2 = Array.isArray(t2) ? t2 : [t2];
        let r2, i2 = -1;
        for (; r2 = e2.getParentNode(++i2); )
          if (n2.includes(r2.type))
            return i2;
        return -1;
      }
      function sL(e2, t2) {
        const n2 = oL(e2, t2);
        return n2 === -1 ? null : e2.getParentNode(n2);
      }
      function aL(e2, t2, n2) {
        if (n2.proseWrap === "preserve" && t2 === "\n")
          return II;
        const r2 = n2.proseWrap === "always" && !sL(e2, nL);
        return t2 !== "" ? r2 ? kI : " " : r2 ? LI : "";
      }
      function cL(e2, t2, n2) {
        const r2 = [];
        let i2 = null;
        const { children: u2 } = e2.getValue();
        for (const [e3, t3] of u2.entries())
          switch (fL(t3)) {
            case "start":
              i2 === null && (i2 = { index: e3, offset: t3.position.end.offset });
              break;
            case "end":
              i2 !== null && (r2.push({ start: i2, end: { index: e3, offset: t3.position.start.offset } }), i2 = null);
          }
        return lL(e2, t2, n2, { processor: (e3, i3) => {
          if (r2.length > 0) {
            const e4 = r2[0];
            if (i3 === e4.start.index)
              return [u2[e4.start.index].value, t2.originalText.slice(e4.start.offset, e4.end.offset), u2[e4.end.index].value];
            if (e4.start.index < i3 && i3 < e4.end.index)
              return false;
            if (i3 === e4.end.index)
              return r2.shift(), false;
          }
          return n2();
        } });
      }
      function lL(e2, t2, n2, r2 = {}) {
        const { postprocessor: i2 } = r2, u2 = r2.processor || (() => n2()), o2 = e2.getValue(), s2 = [];
        let a2;
        return e2.each((e3, n3) => {
          const r3 = e3.getValue(), i3 = u2(e3, n3);
          if (i3 !== false) {
            const e4 = { parts: s2, prevNode: a2, parentNode: o2, options: t2 };
            (function(e5, t3) {
              const n4 = t3.parts.length === 0, r4 = QI.includes(e5.type), i4 = e5.type === "html" && ZI.includes(t3.parentNode.type);
              return !n4 && !r4 && !i4;
            })(r3, e4) && (s2.push(II), a2 && tL.has(a2.type) || (function(e5, t3) {
              const n4 = (t3.prevNode && t3.prevNode.type) === e5.type && rL.has(e5.type), r4 = t3.parentNode.type === "listItem" && !t3.parentNode.loose, i4 = t3.prevNode && t3.prevNode.type === "listItem" && t3.prevNode.loose, u3 = fL(t3.prevNode) === "next", o3 = e5.type === "html" && t3.prevNode && t3.prevNode.type === "html" && t3.prevNode.position.end.line + 1 === e5.position.start.line, s3 = e5.type === "html" && t3.parentNode.type === "listItem" && t3.prevNode && t3.prevNode.type === "paragraph" && t3.prevNode.position.end.line + 1 === e5.position.start.line;
              return i4 || !(n4 || r4 || u3 || o3 || s3);
            }(r3, e4) || dL(r3, e4)) && s2.push(II), dL(r3, e4) && s2.push(II)), s2.push(i3), a2 = r3;
          }
        }, "children"), i2 ? i2(s2) : s2;
      }
      function pL(e2) {
        let t2 = e2;
        for (; TI(t2.children); )
          t2 = FI(t2.children);
        return t2;
      }
      function fL(e2) {
        if (e2.type !== "html")
          return false;
        const t2 = e2.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
        return t2 !== null && (t2[1] ? t2[1] : "next");
      }
      function dL(e2, t2) {
        const n2 = t2.prevNode && t2.prevNode.type === "list", r2 = e2.type === "code" && e2.isIndented;
        return n2 && r2;
      }
      function hL(e2, t2 = []) {
        const n2 = [" ", ...Array.isArray(t2) ? t2 : [t2]];
        return new RegExp(n2.map((e3) => `\\${e3}`).join("|")).test(e2) ? `<${e2}>` : e2;
      }
      function gL(e2, t2, n2 = true) {
        if (!e2)
          return "";
        if (n2)
          return " " + gL(e2, t2, false);
        if ((e2 = e2.replace(/\\(["')])/g, "$1")).includes('"') && e2.includes("'") && !e2.includes(")"))
          return `(${e2})`;
        const r2 = e2.split("'").length - 1, i2 = e2.split('"').length - 1, u2 = r2 > i2 ? '"' : i2 > r2 || t2.singleQuote ? "'" : '"';
        return `${u2}${e2 = (e2 = e2.replace(/\\/, "\\\\")).replace(new RegExp(`(${u2})`, "g"), "\\$1")}${u2}`;
      }
      var mL = { preprocess: DI, print: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (function(e3) {
          const t3 = sL(e3, ["linkReference", "imageReference"]);
          return t3 && (t3.type !== "linkReference" || t3.referenceType !== "full");
        }(e2))
          return YI(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset), t2).map((n3) => n3.type === "word" ? n3.value : n3.value === "" ? "" : aL(e2, n3.value, t2));
        switch (r2.type) {
          case "front-matter":
            return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
          case "root":
            return r2.children.length === 0 ? "" : [WI(cL(e2, t2, n2)), tL.has(pL(r2).type) ? "" : II];
          case "paragraph":
            return lL(e2, t2, n2, { postprocessor: _I });
          case "sentence":
            return lL(e2, t2, n2);
          case "word": {
            let t3 = r2.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${KI})(_+)`, `(_+)(${KI}|$)`].join("|"), "g"), (e3, t4, n4, r3, i3) => (n4 ? `${t4}${n4}` : `${r3}${i3}`).replace(/_/g, "\\_"));
            const n3 = (e3, t4, n4) => e3.type === "sentence" && n4 === 0, i2 = (e3, t4, n4) => eL(e3.children[n4 - 1]);
            return t3 !== r2.value && (e2.match(void 0, n3, i2) || e2.match(void 0, n3, (e3, t4, n4) => e3.type === "emphasis" && n4 === 0, i2)) && (t3 = t3.replace(/^(\\?[*_])+/, (e3) => e3.replace(/\\/g, ""))), t3;
          }
          case "whitespace": {
            const n3 = e2.getParentNode(), i2 = n3.children.indexOf(r2), u2 = n3.children[i2 + 1], o2 = u2 && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(u2.value) ? "never" : t2.proseWrap;
            return aL(e2, r2.value, { proseWrap: o2 });
          }
          case "emphasis": {
            let i2;
            if (eL(r2.children[0]))
              i2 = t2.originalText[r2.position.start.offset];
            else {
              const t3 = e2.getParentNode(), n3 = t3.children.indexOf(r2), u2 = t3.children[n3 - 1], o2 = t3.children[n3 + 1];
              i2 = u2 && u2.type === "sentence" && u2.children.length > 0 && FI(u2.children).type === "word" && !FI(u2.children).hasTrailingPunctuation || o2 && o2.type === "sentence" && o2.children.length > 0 && o2.children[0].type === "word" && !o2.children[0].hasLeadingPunctuation || sL(e2, "emphasis") ? "*" : "_";
            }
            return [i2, lL(e2, t2, n2), i2];
          }
          case "strong":
            return ["**", lL(e2, t2, n2), "**"];
          case "delete":
            return ["~~", lL(e2, t2, n2), "~~"];
          case "inlineCode": {
            const e3 = xI(r2.value, "`"), t3 = "`".repeat(e3 || 1), n3 = e3 && !/^\s/.test(r2.value) ? " " : "";
            return [t3, n3, r2.value, n3, t3];
          }
          case "wikiLink": {
            let e3 = "";
            return e3 = t2.proseWrap === "preserve" ? r2.value : r2.value.replace(/[\t\n]+/g, " "), ["[[", e3, "]]"];
          }
          case "link":
            switch (t2.originalText[r2.position.start.offset]) {
              case "<": {
                const e3 = "mailto:";
                return ["<", r2.url.startsWith(e3) && t2.originalText.slice(r2.position.start.offset + 1, r2.position.start.offset + 1 + e3.length) !== e3 ? r2.url.slice(e3.length) : r2.url, ">"];
              }
              case "[":
                return ["[", lL(e2, t2, n2), "](", hL(r2.url, ")"), gL(r2.title, t2), ")"];
              default:
                return t2.originalText.slice(r2.position.start.offset, r2.position.end.offset);
            }
          case "image":
            return ["![", r2.alt || "", "](", hL(r2.url, ")"), gL(r2.title, t2), ")"];
          case "blockquote":
            return ["> ", MI("> ", lL(e2, t2, n2))];
          case "heading":
            return ["#".repeat(r2.depth) + " ", lL(e2, t2, n2)];
          case "code": {
            if (r2.isIndented) {
              const e4 = " ".repeat(4);
              return MI(e4, [e4, ...qI(r2.value, II)]);
            }
            const e3 = t2.__inJsTemplate ? "~" : "`", n3 = e3.repeat(Math.max(3, SI(r2.value, e3) + 1));
            return [n3, r2.lang || "", r2.meta ? " " + r2.meta : "", II, ...qI(JI(r2, t2.originalText), II), II, n3];
          }
          case "html": {
            const t3 = e2.getParentNode(), n3 = t3.type === "root" && FI(t3.children) === r2 ? r2.value.trimEnd() : r2.value, i2 = /^<!--.*-->$/s.test(n3);
            return qI(n3, i2 ? II : OI(PI));
          }
          case "list": {
            const i2 = uL(r2, e2.getParentNode()), u2 = XI(r2, t2);
            return lL(e2, t2, n2, { processor: (e3, o2) => {
              const s2 = function() {
                const e4 = r2.ordered ? (o2 === 0 ? r2.start : u2 ? 1 : r2.start + o2) + (i2 % 2 == 0 ? ". " : ") ") : i2 % 2 == 0 ? "- " : "* ";
                return r2.isAligned || r2.hasIndentedCodeblock ? function(e5, t3) {
                  const n3 = r3();
                  return e5 + " ".repeat(n3 >= 4 ? 0 : n3);
                  function r3() {
                    const n4 = e5.length % t3.tabWidth;
                    return n4 === 0 ? 0 : t3.tabWidth - n4;
                  }
                }(e4, t2) : e4;
              }(), a2 = e3.getValue();
              return a2.children.length === 2 && a2.children[1].type === "html" && a2.children[0].position.start.column !== a2.children[1].position.start.column ? [s2, iL(e3, t2, n2, s2)] : [s2, MI(" ".repeat(s2.length), iL(e3, t2, n2, s2))];
            } });
          }
          case "thematicBreak": {
            const t3 = oL(e2, "list");
            if (t3 === -1)
              return "---";
            return uL(e2.getParentNode(t3), e2.getParentNode(t3 + 1)) % 2 == 0 ? "***" : "---";
          }
          case "linkReference":
            return ["[", lL(e2, t2, n2), "]", r2.referenceType === "full" ? ["[", r2.identifier, "]"] : r2.referenceType === "collapsed" ? "[]" : ""];
          case "imageReference":
            switch (r2.referenceType) {
              case "full":
                return ["![", r2.alt || "", "][", r2.identifier, "]"];
              default:
                return ["![", r2.alt, "]", r2.referenceType === "collapsed" ? "[]" : ""];
            }
          case "definition": {
            const e3 = t2.proseWrap === "always" ? kI : " ";
            return $I(["[", r2.identifier, "]:", RI([e3, hL(r2.url), r2.title === null ? "" : [e3, gL(r2.title, t2, false)]])]);
          }
          case "footnote":
            return ["[^", lL(e2, t2, n2), "]"];
          case "footnoteReference":
            return ["[^", r2.identifier, "]"];
          case "footnoteDefinition": {
            const i2 = e2.getParentNode().children[e2.getName() + 1], u2 = r2.children.length === 1 && r2.children[0].type === "paragraph" && (t2.proseWrap === "never" || t2.proseWrap === "preserve" && r2.children[0].position.start.line === r2.children[0].position.end.line);
            return ["[^", r2.identifier, "]: ", u2 ? lL(e2, t2, n2) : $I([MI(" ".repeat(4), lL(e2, t2, n2, { processor: (e3, t3) => t3 === 0 ? $I([LI, n2()]) : n2() })), i2 && i2.type === "footnoteDefinition" ? LI : ""])];
          }
          case "table":
            return function(e3, t3, n3) {
              const r3 = e3.getValue(), i2 = [], u2 = e3.map((e4) => e4.map((e5, r4) => {
                const u3 = UI(n3(), t3).formatted, o3 = wI(u3);
                return i2[r4] = Math.max(i2[r4] || 3, o3), { text: u3, width: o3 };
              }, "children"), "children"), o2 = a2(false);
              if (t3.proseWrap !== "never")
                return [BI, o2];
              const s2 = a2(true);
              return [BI, $I(jI(s2, o2))];
              function a2(e4) {
                const t4 = [l2(u2[0], e4), c2(e4)];
                return u2.length > 1 && t4.push(NI(VI, u2.slice(1).map((t5) => l2(t5, e4)))), NI(VI, t4);
              }
              function c2(e4) {
                return `| ${i2.map((t4, n4) => {
                  const i3 = r3.align[n4], u3 = i3 === "center" || i3 === "right" ? ":" : "-";
                  return `${i3 === "center" || i3 === "left" ? ":" : "-"}${e4 ? "-" : "-".repeat(t4 - 2)}${u3}`;
                }).join(" | ")} |`;
              }
              function l2(e4, t4) {
                return `| ${e4.map(({ text: e5, width: n4 }, u3) => {
                  if (t4)
                    return e5;
                  const o3 = i2[u3] - n4, s3 = r3.align[u3];
                  let a3 = 0;
                  s3 === "right" ? a3 = o3 : s3 === "center" && (a3 = Math.floor(o3 / 2));
                  const c3 = o3 - a3;
                  return `${" ".repeat(a3)}${e5}${" ".repeat(c3)}`;
                }).join(" | ")} |`;
              }
            }(e2, t2, n2);
          case "tableCell":
            return lL(e2, t2, n2);
          case "break":
            return /\s/.test(t2.originalText[r2.position.start.offset]) ? ["  ", OI(PI)] : ["\\", II];
          case "liquidNode":
            return qI(r2.value, II);
          case "importExport":
            return [r2.value, II];
          case "jsx":
            return r2.value;
          case "math":
            return ["$$", II, r2.value ? [...qI(r2.value, II), II] : "", "$$"];
          case "inlineMath":
            return t2.originalText.slice(GI(r2), HI(r2));
          case "tableRow":
          case "listItem":
          default:
            throw new Error(`Unknown markdown type ${JSON.stringify(r2.type)}`);
        }
      }, embed: cI, massageAstNode: vI, hasPrettierIgnore: function(e2) {
        const t2 = Number(e2.getName());
        return t2 !== 0 && fL(e2.getParentNode().children[t2 - 1]) === "next";
      }, insertPragma: zI }, yL = { proseWrap: KB.proseWrap, singleQuote: KB.singleQuote }, DL = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
      var EL = { languages: [rh(DL, (e2) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...e2.filenames, "README"], extensions: e2.extensions.filter((e3) => e3 !== ".mdx") })), rh(DL, () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], options: yL, printers: { mdast: mL }, parsers: void 0 };
      const { isFrontMatterNode: CL } = Fi, bL = new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
      function AL(e2, t2) {
        return e2.type === "text" || e2.type === "comment" || CL(e2) || e2.type === "yaml" || e2.type === "toml" ? null : (e2.type === "attribute" && delete t2.value, void (e2.type === "docType" && delete t2.value));
      }
      AL.ignoredProperties = bL;
      var vL = AL, FL = { "*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["accesskey", "charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "tabindex", "target", "type"], abbr: ["title"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["accesskey", "alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "tabindex", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], bdo: ["dir"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["accesskey", "autofocus", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "tabindex", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dfn: ["title"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "accesskey", "align", "alt", "autocomplete", "autofocus", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "tabindex", "title", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["accesskey", "for", "form"], legend: ["accesskey", "align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "nonce", "referrerpolicy", "rel", "rev", "sizes", "target", "title", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "tabindex", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "nonce", "referrerpolicy", "src", "type"], select: ["autocomplete", "autofocus", "disabled", "form", "multiple", "name", "required", "size", "tabindex"], slot: ["name"], source: ["media", "sizes", "src", "srcset", "type"], style: ["media", "nonce", "title", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["accesskey", "autocomplete", "autofocus", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "tabindex", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"] };
      const { inferParserByLanguage: xL, isFrontMatterNode: SL } = Fi, { builders: { line: wL, hardline: TL, join: BL }, utils: { getDocParts: NL, replaceTextEndOfLine: kL } } = su, { CSS_DISPLAY_TAGS: PL, CSS_DISPLAY_DEFAULT: OL, CSS_WHITE_SPACE_TAGS: IL, CSS_WHITE_SPACE_DEFAULT: LL } = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" }, jL = WL(["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"]), _L = function(e2, t2) {
        const n2 = Object.create(null);
        for (const [r2, i2] of Object.entries(e2))
          n2[r2] = t2(i2, r2);
        return n2;
      }(FL, WL), ML = new Set(["	", "\n", "\f", "\r", " "]), RL = (e2) => e2.replace(/[\t\n\f\r ]+$/, ""), $L = (e2) => ((e3) => e3.replace(/^[\t\f\r ]*?\n/g, ""))(RL(e2)), VL = (e2) => e2.match(/^[\t\n\f\r ]*/)[0];
      function WL(e2) {
        const t2 = Object.create(null);
        for (const n2 of e2)
          t2[n2] = true;
        return t2;
      }
      function qL(e2) {
        return e2.type === "element" && (e2.fullName === "script" || e2.fullName === "style" || e2.fullName === "svg:style" || ej(e2) && (e2.name === "script" || e2.name === "style"));
      }
      function UL(e2) {
        return tj(e2).startsWith("pre");
      }
      function zL(e2) {
        return e2.type === "element" && e2.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(e2.name) || e2.cssDisplay.startsWith("table") && e2.cssDisplay !== "table-cell");
      }
      function GL(e2) {
        return YL(e2) || e2.type === "element" && e2.fullName === "br" || HL(e2);
      }
      function HL(e2) {
        return JL(e2) && XL(e2);
      }
      function JL(e2) {
        return e2.hasLeadingSpaces && (e2.prev ? e2.prev.sourceSpan.end.line < e2.sourceSpan.start.line : e2.parent.type === "root" || e2.parent.startSourceSpan.end.line < e2.sourceSpan.start.line);
      }
      function XL(e2) {
        return e2.hasTrailingSpaces && (e2.next ? e2.next.sourceSpan.start.line > e2.sourceSpan.end.line : e2.parent.type === "root" || e2.parent.endSourceSpan && e2.parent.endSourceSpan.start.line > e2.sourceSpan.end.line);
      }
      function YL(e2) {
        switch (e2.type) {
          case "ieConditionalComment":
          case "comment":
          case "directive":
            return true;
          case "element":
            return ["script", "select"].includes(e2.name);
        }
        return false;
      }
      function KL(e2) {
        const { type: t2, lang: n2 } = e2.attrMap;
        return t2 === "module" || t2 === "text/javascript" || t2 === "text/babel" || t2 === "application/javascript" || n2 === "jsx" ? "babel" : t2 === "application/x-typescript" || n2 === "ts" || n2 === "tsx" ? "typescript" : t2 === "text/markdown" ? "markdown" : t2 === "text/html" ? "html" : t2 && (t2.endsWith("json") || t2.endsWith("importmap")) ? "json" : t2 === "text/x-handlebars-template" ? "glimmer" : void 0;
      }
      function QL(e2) {
        return e2 === "block" || e2 === "list-item" || e2.startsWith("table");
      }
      function ZL(e2) {
        return tj(e2).startsWith("pre");
      }
      function ej(e2) {
        return e2.type === "element" && !e2.hasExplicitNamespace && !["html", "svg"].includes(e2.namespace);
      }
      function tj(e2) {
        return e2.type === "element" && (!e2.namespace || ej(e2)) && IL[e2.name] || LL;
      }
      function nj(e2, t2 = function(e3) {
        let t3 = Number.POSITIVE_INFINITY;
        for (const n2 of e3.split("\n")) {
          if (n2.length === 0)
            continue;
          if (!ML.has(n2[0]))
            return 0;
          const e4 = VL(n2).length;
          n2.length !== e4 && e4 < t3 && (t3 = e4);
        }
        return t3 === Number.POSITIVE_INFINITY ? 0 : t3;
      }(e2)) {
        return t2 === 0 ? e2 : e2.split("\n").map((e3) => e3.slice(t2)).join("\n");
      }
      const rj = new Set(["template", "style", "script"]);
      function ij(e2, t2) {
        return uj(e2, t2) && !rj.has(e2.fullName);
      }
      function uj(e2, t2) {
        return t2.parser === "vue" && e2.type === "element" && e2.parent.type === "root" && e2.fullName.toLowerCase() !== "html";
      }
      function oj(e2, t2) {
        return uj(e2, t2) && (ij(e2, t2) || e2.attrMap.lang && e2.attrMap.lang !== "html");
      }
      var sj = { HTML_ELEMENT_ATTRIBUTES: _L, HTML_TAGS: jL, htmlTrim: (e2) => ((e3) => e3.replace(/^[\t\n\f\r ]+/, ""))(RL(e2)), htmlTrimPreserveIndentation: $L, hasHtmlWhitespace: (e2) => /[\t\n\f\r ]/.test(e2), getLeadingAndTrailingHtmlWhitespace: (e2) => {
        const [, t2, n2, r2] = e2.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
        return { leadingWhitespace: t2, trailingWhitespace: r2, text: n2 };
      }, canHaveInterpolation: function(e2) {
        return e2.children && !qL(e2);
      }, countChars: function(e2, t2) {
        let n2 = 0;
        for (let r2 = 0; r2 < e2.length; r2++)
          e2[r2] === t2 && n2++;
        return n2;
      }, countParents: function(e2, t2) {
        let n2 = 0;
        for (let r2 = e2.stack.length - 1; r2 >= 0; r2--) {
          const i2 = e2.stack[r2];
          i2 && typeof i2 == "object" && !Array.isArray(i2) && t2(i2) && n2++;
        }
        return n2;
      }, dedentString: nj, forceBreakChildren: zL, forceBreakContent: function(e2) {
        return zL(e2) || e2.type === "element" && e2.children.length > 0 && (["body", "script", "style"].includes(e2.name) || e2.children.some((e3) => function(e4) {
          return e4.children && e4.children.some((e5) => e5.type !== "text");
        }(e3))) || e2.firstChild && e2.firstChild === e2.lastChild && e2.firstChild.type !== "text" && JL(e2.firstChild) && (!e2.lastChild.isTrailingSpaceSensitive || XL(e2.lastChild));
      }, forceNextEmptyLine: function(e2) {
        return SL(e2) || e2.next && e2.sourceSpan.end && e2.sourceSpan.end.line + 1 < e2.next.sourceSpan.start.line;
      }, getLastDescendant: function e2(t2) {
        return t2.lastChild ? e2(t2.lastChild) : t2;
      }, getNodeCssStyleDisplay: function(e2, t2) {
        if (e2.prev && e2.prev.type === "comment") {
          const t3 = e2.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
          if (t3)
            return t3[1];
        }
        let n2 = false;
        if (e2.type === "element" && e2.namespace === "svg") {
          if (!function(e3, t3) {
            let n3 = e3;
            for (; n3; ) {
              if (t3(n3))
                return true;
              n3 = n3.parent;
            }
            return false;
          }(e2, (e3) => e3.fullName === "svg:foreignObject"))
            return e2.name === "svg" ? "inline-block" : "block";
          n2 = true;
        }
        switch (t2.htmlWhitespaceSensitivity) {
          case "strict":
            return "inline";
          case "ignore":
            return "block";
          default:
            return t2.parser === "vue" && e2.parent && e2.parent.type === "root" ? "block" : e2.type === "element" && (!e2.namespace || n2 || ej(e2)) && PL[e2.name] || OL;
        }
      }, getNodeCssStyleWhiteSpace: tj, hasPrettierIgnore: function(e2) {
        return e2.type !== "attribute" && (!!e2.parent && (typeof e2.index == "number" && e2.index !== 0 && function(e3) {
          return e3.type === "comment" && e3.value.trim() === "prettier-ignore";
        }(e2.parent.children[e2.index - 1])));
      }, inferScriptParser: function(e2, t2) {
        return e2.name !== "script" || e2.attrMap.src ? e2.name === "style" ? function(e3) {
          const { lang: t3 } = e3.attrMap;
          return t3 && t3 !== "postcss" && t3 !== "css" ? t3 === "scss" ? "scss" : t3 === "less" ? "less" : void 0 : "css";
        }(e2) : t2 && oj(e2, t2) ? KL(e2) || !("src" in e2.attrMap) && xL(e2.attrMap.lang, t2) : void 0 : e2.attrMap.lang || e2.attrMap.type ? KL(e2) : "babel";
      }, isVueCustomBlock: ij, isVueNonHtmlBlock: oj, isVueSlotAttribute: function(e2) {
        const t2 = e2.fullName;
        return t2.charAt(0) === "#" || t2 === "slot-scope" || t2 === "v-slot" || t2.startsWith("v-slot:");
      }, isVueSfcBindingsAttribute: function(e2, t2) {
        const n2 = e2.parent;
        if (!uj(n2, t2))
          return false;
        const r2 = n2.fullName, i2 = e2.fullName;
        return r2 === "script" && i2 === "setup" || r2 === "style" && i2 === "vars";
      }, isDanglingSpaceSensitiveNode: function(e2) {
        return !(t2 = e2.cssDisplay, QL(t2) || t2 === "inline-block" || qL(e2));
        var t2;
      }, isIndentationSensitiveNode: UL, isLeadingSpaceSensitiveNode: function(e2, t2) {
        const n2 = function() {
          if (SL(e2))
            return false;
          if ((e2.type === "text" || e2.type === "interpolation") && e2.prev && (e2.prev.type === "text" || e2.prev.type === "interpolation"))
            return true;
          if (!e2.parent || e2.parent.cssDisplay === "none")
            return false;
          if (ZL(e2.parent))
            return true;
          if (!e2.prev && (e2.parent.type === "root" || ZL(e2) && e2.parent || qL(e2.parent) || ij(e2.parent, t2) || (n3 = e2.parent.cssDisplay, QL(n3) || n3 === "inline-block")))
            return false;
          var n3;
          if (e2.prev && !function(e3) {
            return !QL(e3);
          }(e2.prev.cssDisplay))
            return false;
          return true;
        }();
        return n2 && !e2.prev && e2.parent && e2.parent.tagDefinition && e2.parent.tagDefinition.ignoreFirstLf ? e2.type === "interpolation" : n2;
      }, isPreLikeNode: ZL, isScriptLikeTag: qL, isTextLikeNode: function(e2) {
        return e2.type === "text" || e2.type === "comment";
      }, isTrailingSpaceSensitiveNode: function(e2, t2) {
        return !SL(e2) && (!(e2.type !== "text" && e2.type !== "interpolation" || !e2.next || e2.next.type !== "text" && e2.next.type !== "interpolation") || !(!e2.parent || e2.parent.cssDisplay === "none") && (!!ZL(e2.parent) || !(!e2.next && (e2.parent.type === "root" || ZL(e2) && e2.parent || qL(e2.parent) || ij(e2.parent, t2) || (n2 = e2.parent.cssDisplay, QL(n2) || n2 === "inline-block"))) && !(e2.next && !function(e3) {
          return !QL(e3);
        }(e2.next.cssDisplay))));
        var n2;
      }, isWhitespaceSensitiveNode: function(e2) {
        return qL(e2) || e2.type === "interpolation" || UL(e2);
      }, isUnknownNamespace: ej, preferHardlineAsLeadingSpaces: function(e2) {
        return YL(e2) || e2.prev && GL(e2.prev) || HL(e2);
      }, preferHardlineAsTrailingSpaces: GL, shouldPreserveContent: function(e2, t2) {
        return !(e2.type !== "ieConditionalComment" || !e2.lastChild || e2.lastChild.isSelfClosing || e2.lastChild.endSourceSpan) || (e2.type === "ieConditionalComment" && !e2.complete || (!(!ZL(e2) || !e2.children.some((e3) => e3.type !== "text" && e3.type !== "interpolation")) || !(!oj(e2, t2) || qL(e2) || e2.type === "interpolation")));
      }, unescapeQuoteEntities: function(e2) {
        return e2.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
      }, getTextValueParts: function(e2, t2 = e2.value) {
        return e2.parent.isWhitespaceSensitive ? e2.parent.isIndentationSensitive ? kL(t2) : kL(nj($L(t2)), TL) : NL(BL(wL, ((e3) => e3.split(/[\t\n\f\r ]+/))(t2)));
      } }, aj = r(function(e2, t2) {
        function n2(e3) {
          return t2.$0 <= e3 && e3 <= t2.$9;
        }
        Object.defineProperty(t2, "__esModule", { value: true }), t2.$EOF = 0, t2.$BSPACE = 8, t2.$TAB = 9, t2.$LF = 10, t2.$VTAB = 11, t2.$FF = 12, t2.$CR = 13, t2.$SPACE = 32, t2.$BANG = 33, t2.$DQ = 34, t2.$HASH = 35, t2.$$ = 36, t2.$PERCENT = 37, t2.$AMPERSAND = 38, t2.$SQ = 39, t2.$LPAREN = 40, t2.$RPAREN = 41, t2.$STAR = 42, t2.$PLUS = 43, t2.$COMMA = 44, t2.$MINUS = 45, t2.$PERIOD = 46, t2.$SLASH = 47, t2.$COLON = 58, t2.$SEMICOLON = 59, t2.$LT = 60, t2.$EQ = 61, t2.$GT = 62, t2.$QUESTION = 63, t2.$0 = 48, t2.$7 = 55, t2.$9 = 57, t2.$A = 65, t2.$E = 69, t2.$F = 70, t2.$X = 88, t2.$Z = 90, t2.$LBRACKET = 91, t2.$BACKSLASH = 92, t2.$RBRACKET = 93, t2.$CARET = 94, t2.$_ = 95, t2.$a = 97, t2.$b = 98, t2.$e = 101, t2.$f = 102, t2.$n = 110, t2.$r = 114, t2.$t = 116, t2.$u = 117, t2.$v = 118, t2.$x = 120, t2.$z = 122, t2.$LBRACE = 123, t2.$BAR = 124, t2.$RBRACE = 125, t2.$NBSP = 160, t2.$PIPE = 124, t2.$TILDA = 126, t2.$AT = 64, t2.$BT = 96, t2.isWhitespace = function(e3) {
          return e3 >= t2.$TAB && e3 <= t2.$SPACE || e3 == t2.$NBSP;
        }, t2.isDigit = n2, t2.isAsciiLetter = function(e3) {
          return e3 >= t2.$a && e3 <= t2.$z || e3 >= t2.$A && e3 <= t2.$Z;
        }, t2.isAsciiHexDigit = function(e3) {
          return e3 >= t2.$a && e3 <= t2.$f || e3 >= t2.$A && e3 <= t2.$F || n2(e3);
        }, t2.isNewLine = function(e3) {
          return e3 === t2.$LF || e3 === t2.$CR;
        }, t2.isOctalDigit = function(e3) {
          return t2.$0 <= e3 && e3 <= t2.$7;
        };
      });
      class cj {
        constructor(e2, t2, n2) {
          this.filePath = e2, this.name = t2, this.members = n2;
        }
        assertNoMembers() {
          if (this.members.length)
            throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
        }
      }
      var lj = cj;
      var pj = class {
        constructor() {
          this.cache = new Map();
        }
        get(e2, t2, n2) {
          const r2 = `"${e2}".${t2}${(n2 = n2 || []).length ? `.${n2.join(".")}` : ""}`;
          let i2 = this.cache.get(r2);
          return i2 || (i2 = new cj(e2, t2, n2), this.cache.set(r2, i2)), i2;
        }
      }, fj = Object.defineProperty({ StaticSymbol: lj, StaticSymbolCache: pj }, "__esModule", { value: true });
      const dj = /-+([a-z0-9])/g;
      var hj = function(e2) {
        return e2.replace(dj, (...e3) => e3[1].toUpperCase());
      };
      var gj = function(e2, t2) {
        return yj(e2, ":", t2);
      };
      var mj = function(e2, t2) {
        return yj(e2, ".", t2);
      };
      function yj(e2, t2, n2) {
        const r2 = e2.indexOf(t2);
        return r2 == -1 ? n2 : [e2.slice(0, r2).trim(), e2.slice(r2 + 1).trim()];
      }
      function Dj(e2, t2, n2) {
        return Array.isArray(e2) ? t2.visitArray(e2, n2) : function(e3) {
          return typeof e3 == "object" && e3 !== null && Object.getPrototypeOf(e3) === kj;
        }(e2) ? t2.visitStringMap(e2, n2) : e2 == null || typeof e2 == "string" || typeof e2 == "number" || typeof e2 == "boolean" ? t2.visitPrimitive(e2, n2) : t2.visitOther(e2, n2);
      }
      var Ej = Dj;
      var Cj = function(e2) {
        return e2 != null;
      };
      var bj = function(e2) {
        return e2 === void 0 ? null : e2;
      };
      var Aj = class {
        visitArray(e2, t2) {
          return e2.map((e3) => Dj(e3, this, t2));
        }
        visitStringMap(e2, t2) {
          const n2 = {};
          return Object.keys(e2).forEach((r2) => {
            n2[r2] = Dj(e2[r2], this, t2);
          }), n2;
        }
        visitPrimitive(e2, t2) {
          return e2;
        }
        visitOther(e2, t2) {
          return e2;
        }
      }, vj = { assertSync: (e2) => {
        if (Lj(e2))
          throw new Error("Illegal state: value cannot be a promise");
        return e2;
      }, then: (e2, t2) => Lj(e2) ? e2.then(t2) : t2(e2), all: (e2) => e2.some(Lj) ? Promise.all(e2) : e2 };
      var Fj = function(e2) {
        throw new Error(`Internal Error: ${e2}`);
      };
      var xj = function(e2, t2) {
        const n2 = Error(e2);
        return n2[Sj] = true, t2 && (n2[wj] = t2), n2;
      };
      const Sj = "ngSyntaxError", wj = "ngParseErrors";
      var Tj = function(e2) {
        return e2[Sj];
      };
      var Bj = function(e2) {
        return e2[wj] || [];
      };
      var Nj = function(e2) {
        return e2.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
      };
      const kj = Object.getPrototypeOf({});
      var Pj = function(e2) {
        let t2 = "";
        for (let n2 = 0; n2 < e2.length; n2++) {
          let r2 = e2.charCodeAt(n2);
          if (r2 >= 55296 && r2 <= 56319 && e2.length > n2 + 1) {
            const t3 = e2.charCodeAt(n2 + 1);
            t3 >= 56320 && t3 <= 57343 && (n2++, r2 = (r2 - 55296 << 10) + t3 - 56320 + 65536);
          }
          r2 <= 127 ? t2 += String.fromCharCode(r2) : r2 <= 2047 ? t2 += String.fromCharCode(r2 >> 6 & 31 | 192, 63 & r2 | 128) : r2 <= 65535 ? t2 += String.fromCharCode(r2 >> 12 | 224, r2 >> 6 & 63 | 128, 63 & r2 | 128) : r2 <= 2097151 && (t2 += String.fromCharCode(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128, r2 >> 6 & 63 | 128, 63 & r2 | 128));
        }
        return t2;
      };
      var Oj = function e2(t2) {
        if (typeof t2 == "string")
          return t2;
        if (t2 instanceof Array)
          return "[" + t2.map(e2).join(", ") + "]";
        if (t2 == null)
          return "" + t2;
        if (t2.overriddenName)
          return `${t2.overriddenName}`;
        if (t2.name)
          return `${t2.name}`;
        if (!t2.toString)
          return "object";
        const n2 = t2.toString();
        if (n2 == null)
          return "" + n2;
        const r2 = n2.indexOf("\n");
        return r2 === -1 ? n2 : n2.substring(0, r2);
      };
      var Ij = function(e2) {
        return typeof e2 == "function" && e2.hasOwnProperty("__forward_ref__") ? e2() : e2;
      };
      function Lj(e2) {
        return !!e2 && typeof e2.then == "function";
      }
      var jj = Lj;
      var _j = class {
        constructor(e2) {
          this.full = e2;
          const t2 = e2.split(".");
          this.major = t2[0], this.minor = t2[1], this.patch = t2.slice(2).join(".");
        }
      };
      const Mj = typeof window != "undefined" && window, Rj = typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope && self;
      var $j = t !== void 0 && t || Mj || Rj, Vj = Object.defineProperty({ dashCaseToCamelCase: hj, splitAtColon: gj, splitAtPeriod: mj, visitValue: Ej, isDefined: Cj, noUndefined: bj, ValueTransformer: Aj, SyncAsync: vj, error: Fj, syntaxError: xj, isSyntaxError: Tj, getParseErrors: Bj, escapeRegExp: Nj, utf8Encode: Pj, stringify: Oj, resolveForwardRef: Ij, isPromise: jj, Version: _j, global: $j }, "__esModule", { value: true }), Wj = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true });
        const n2 = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
        function r2(e3) {
          return e3.replace(/\W/g, "_");
        }
        t2.sanitizeIdentifier = r2;
        let i2 = 0;
        function u2(e3) {
          if (!e3 || !e3.reference)
            return null;
          const t3 = e3.reference;
          if (t3 instanceof fj.StaticSymbol)
            return t3.name;
          if (t3.__anonymousType)
            return t3.__anonymousType;
          let n3 = Vj.stringify(t3);
          return n3.indexOf("(") >= 0 ? (n3 = "anonymous_" + i2++, t3.__anonymousType = n3) : n3 = r2(n3), n3;
        }
        var o2;
        t2.identifierName = u2, t2.identifierModuleUrl = function(e3) {
          const t3 = e3.reference;
          return t3 instanceof fj.StaticSymbol ? t3.filePath : `./${Vj.stringify(t3)}`;
        }, t2.viewClassName = function(e3, t3) {
          return `View_${u2({ reference: e3 })}_${t3}`;
        }, t2.rendererTypeName = function(e3) {
          return `RenderType_${u2({ reference: e3 })}`;
        }, t2.hostViewClassName = function(e3) {
          return `HostView_${u2({ reference: e3 })}`;
        }, t2.componentFactoryName = function(e3) {
          return `${u2({ reference: e3 })}NgFactory`;
        }, function(e3) {
          e3[e3.Pipe = 0] = "Pipe", e3[e3.Directive = 1] = "Directive", e3[e3.NgModule = 2] = "NgModule", e3[e3.Injectable = 3] = "Injectable";
        }(o2 = t2.CompileSummaryKind || (t2.CompileSummaryKind = {})), t2.tokenName = function(e3) {
          return e3.value != null ? r2(e3.value) : u2(e3.identifier);
        }, t2.tokenReference = function(e3) {
          return e3.identifier != null ? e3.identifier.reference : e3.value;
        };
        t2.CompileStylesheetMetadata = class {
          constructor({ moduleUrl: e3, styles: t3, styleUrls: n3 } = {}) {
            this.moduleUrl = e3 || null, this.styles = a2(t3), this.styleUrls = a2(n3);
          }
        };
        t2.CompileTemplateMetadata = class {
          constructor({ encapsulation: e3, template: t3, templateUrl: n3, htmlAst: r3, styles: i3, styleUrls: u3, externalStylesheets: o3, animations: s3, ngContentSelectors: l3, interpolation: p2, isInline: f2, preserveWhitespaces: d2 }) {
            if (this.encapsulation = e3, this.template = t3, this.templateUrl = n3, this.htmlAst = r3, this.styles = a2(i3), this.styleUrls = a2(u3), this.externalStylesheets = a2(o3), this.animations = s3 ? c2(s3) : [], this.ngContentSelectors = l3 || [], p2 && p2.length != 2)
              throw new Error("'interpolation' should have a start and an end symbol.");
            this.interpolation = p2, this.isInline = f2, this.preserveWhitespaces = d2;
          }
          toSummary() {
            return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
          }
        };
        class s2 {
          static create({ isHost: e3, type: t3, isComponent: r3, selector: i3, exportAs: u3, changeDetection: o3, inputs: a3, outputs: c3, host: l3, providers: p2, viewProviders: f2, queries: d2, guards: h2, viewQueries: g2, entryComponents: m2, template: y2, componentViewType: D2, rendererType: E2, componentFactory: C2 }) {
            const b2 = {}, A2 = {}, v2 = {};
            l3 != null && Object.keys(l3).forEach((e4) => {
              const t4 = l3[e4], r4 = e4.match(n2);
              r4 === null ? v2[e4] = t4 : r4[1] != null ? A2[r4[1]] = t4 : r4[2] != null && (b2[r4[2]] = t4);
            });
            const F2 = {};
            a3 != null && a3.forEach((e4) => {
              const t4 = Vj.splitAtColon(e4, [e4, e4]);
              F2[t4[0]] = t4[1];
            });
            const x2 = {};
            return c3 != null && c3.forEach((e4) => {
              const t4 = Vj.splitAtColon(e4, [e4, e4]);
              x2[t4[0]] = t4[1];
            }), new s2({ isHost: e3, type: t3, isComponent: !!r3, selector: i3, exportAs: u3, changeDetection: o3, inputs: F2, outputs: x2, hostListeners: b2, hostProperties: A2, hostAttributes: v2, providers: p2, viewProviders: f2, queries: d2, guards: h2, viewQueries: g2, entryComponents: m2, template: y2, componentViewType: D2, rendererType: E2, componentFactory: C2 });
          }
          constructor({ isHost: e3, type: t3, isComponent: n3, selector: r3, exportAs: i3, changeDetection: u3, inputs: o3, outputs: s3, hostListeners: c3, hostProperties: l3, hostAttributes: p2, providers: f2, viewProviders: d2, queries: h2, guards: g2, viewQueries: m2, entryComponents: y2, template: D2, componentViewType: E2, rendererType: C2, componentFactory: b2 }) {
            this.isHost = !!e3, this.type = t3, this.isComponent = n3, this.selector = r3, this.exportAs = i3, this.changeDetection = u3, this.inputs = o3, this.outputs = s3, this.hostListeners = c3, this.hostProperties = l3, this.hostAttributes = p2, this.providers = a2(f2), this.viewProviders = a2(d2), this.queries = a2(h2), this.guards = g2, this.viewQueries = a2(m2), this.entryComponents = a2(y2), this.template = D2, this.componentViewType = E2, this.rendererType = C2, this.componentFactory = b2;
          }
          toSummary() {
            return { summaryKind: o2.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
          }
        }
        t2.CompileDirectiveMetadata = s2;
        t2.CompilePipeMetadata = class {
          constructor({ type: e3, name: t3, pure: n3 }) {
            this.type = e3, this.name = t3, this.pure = !!n3;
          }
          toSummary() {
            return { summaryKind: o2.Pipe, type: this.type, name: this.name, pure: this.pure };
          }
        };
        t2.CompileShallowModuleMetadata = class {
        };
        t2.CompileNgModuleMetadata = class {
          constructor({ type: e3, providers: t3, declaredDirectives: n3, exportedDirectives: r3, declaredPipes: i3, exportedPipes: u3, entryComponents: o3, bootstrapComponents: s3, importedModules: c3, exportedModules: l3, schemas: p2, transitiveModule: f2, id: d2 }) {
            this.type = e3 || null, this.declaredDirectives = a2(n3), this.exportedDirectives = a2(r3), this.declaredPipes = a2(i3), this.exportedPipes = a2(u3), this.providers = a2(t3), this.entryComponents = a2(o3), this.bootstrapComponents = a2(s3), this.importedModules = a2(c3), this.exportedModules = a2(l3), this.schemas = a2(p2), this.id = d2 || null, this.transitiveModule = f2 || null;
          }
          toSummary() {
            const e3 = this.transitiveModule;
            return { summaryKind: o2.NgModule, type: this.type, entryComponents: e3.entryComponents, providers: e3.providers, modules: e3.modules, exportedDirectives: e3.exportedDirectives, exportedPipes: e3.exportedPipes };
          }
        };
        function a2(e3) {
          return e3 || [];
        }
        t2.TransitiveCompileNgModuleMetadata = class {
          constructor() {
            this.directivesSet = new Set(), this.directives = [], this.exportedDirectivesSet = new Set(), this.exportedDirectives = [], this.pipesSet = new Set(), this.pipes = [], this.exportedPipesSet = new Set(), this.exportedPipes = [], this.modulesSet = new Set(), this.modules = [], this.entryComponentsSet = new Set(), this.entryComponents = [], this.providers = [];
          }
          addProvider(e3, t3) {
            this.providers.push({ provider: e3, module: t3 });
          }
          addDirective(e3) {
            this.directivesSet.has(e3.reference) || (this.directivesSet.add(e3.reference), this.directives.push(e3));
          }
          addExportedDirective(e3) {
            this.exportedDirectivesSet.has(e3.reference) || (this.exportedDirectivesSet.add(e3.reference), this.exportedDirectives.push(e3));
          }
          addPipe(e3) {
            this.pipesSet.has(e3.reference) || (this.pipesSet.add(e3.reference), this.pipes.push(e3));
          }
          addExportedPipe(e3) {
            this.exportedPipesSet.has(e3.reference) || (this.exportedPipesSet.add(e3.reference), this.exportedPipes.push(e3));
          }
          addModule(e3) {
            this.modulesSet.has(e3.reference) || (this.modulesSet.add(e3.reference), this.modules.push(e3));
          }
          addEntryComponent(e3) {
            this.entryComponentsSet.has(e3.componentType) || (this.entryComponentsSet.add(e3.componentType), this.entryComponents.push(e3));
          }
        };
        function c2(e3) {
          return e3.reduce((e4, t3) => {
            const n3 = Array.isArray(t3) ? c2(t3) : t3;
            return e4.concat(n3);
          }, []);
        }
        function l2(e3) {
          return e3.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
        }
        t2.ProviderMeta = class {
          constructor(e3, { useClass: t3, useValue: n3, useExisting: r3, useFactory: i3, deps: u3, multi: o3 }) {
            this.token = e3, this.useClass = t3 || null, this.useValue = n3, this.useExisting = r3, this.useFactory = i3 || null, this.dependencies = u3 || null, this.multi = !!o3;
          }
        }, t2.flatten = c2, t2.templateSourceUrl = function(e3, t3, n3) {
          let r3;
          return r3 = n3.isInline ? t3.type.reference instanceof fj.StaticSymbol ? `${t3.type.reference.filePath}.${t3.type.reference.name}.html` : `${u2(e3)}/${u2(t3.type)}.html` : n3.templateUrl, t3.type.reference instanceof fj.StaticSymbol ? r3 : l2(r3);
        }, t2.sharedStylesheetJitUrl = function(e3, t3) {
          const n3 = e3.moduleUrl.split(/\/\\/g);
          return l2(`css/${t3}${n3[n3.length - 1]}.ngstyle.js`);
        }, t2.ngModuleJitUrl = function(e3) {
          return l2(`${u2(e3.type)}/module.ngfactory.js`);
        }, t2.templateJitUrl = function(e3, t3) {
          return l2(`${u2(e3)}/${u2(t3.type)}.ngfactory.js`);
        };
      }), qj = r(function(e2, t2) {
        Object.defineProperty(t2, "__esModule", { value: true });
        class n2 {
          constructor(e3, t3, n3, r3) {
            this.file = e3, this.offset = t3, this.line = n3, this.col = r3;
          }
          toString() {
            return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
          }
          moveBy(e3) {
            const t3 = this.file.content, r3 = t3.length;
            let i3 = this.offset, u3 = this.line, o2 = this.col;
            for (; i3 > 0 && e3 < 0; ) {
              i3--, e3++;
              if (t3.charCodeAt(i3) == aj.$LF) {
                u3--;
                const e4 = t3.substr(0, i3 - 1).lastIndexOf(String.fromCharCode(aj.$LF));
                o2 = e4 > 0 ? i3 - e4 : i3;
              } else
                o2--;
            }
            for (; i3 < r3 && e3 > 0; ) {
              const n3 = t3.charCodeAt(i3);
              i3++, e3--, n3 == aj.$LF ? (u3++, o2 = 0) : o2++;
            }
            return new n2(this.file, i3, u3, o2);
          }
          getContext(e3, t3) {
            const n3 = this.file.content;
            let r3 = this.offset;
            if (r3 != null) {
              r3 > n3.length - 1 && (r3 = n3.length - 1);
              let i3 = r3, u3 = 0, o2 = 0;
              for (; u3 < e3 && r3 > 0 && (r3--, u3++, n3[r3] != "\n" || ++o2 != t3); )
                ;
              for (u3 = 0, o2 = 0; u3 < e3 && i3 < n3.length - 1 && (i3++, u3++, n3[i3] != "\n" || ++o2 != t3); )
                ;
              return { before: n3.substring(r3, this.offset), after: n3.substring(this.offset, i3 + 1) };
            }
            return null;
          }
        }
        t2.ParseLocation = n2;
        class r2 {
          constructor(e3, t3) {
            this.content = e3, this.url = t3;
          }
        }
        t2.ParseSourceFile = r2;
        class i2 {
          constructor(e3, t3, n3 = null) {
            this.start = e3, this.end = t3, this.details = n3;
          }
          toString() {
            return this.start.file.content.substring(this.start.offset, this.end.offset);
          }
        }
        var u2;
        t2.ParseSourceSpan = i2, t2.EMPTY_PARSE_LOCATION = new n2(new r2("", ""), 0, 0, 0), t2.EMPTY_SOURCE_SPAN = new i2(t2.EMPTY_PARSE_LOCATION, t2.EMPTY_PARSE_LOCATION), function(e3) {
          e3[e3.WARNING = 0] = "WARNING", e3[e3.ERROR = 1] = "ERROR";
        }(u2 = t2.ParseErrorLevel || (t2.ParseErrorLevel = {}));
        t2.ParseError = class {
          constructor(e3, t3, n3 = u2.ERROR) {
            this.span = e3, this.msg = t3, this.level = n3;
          }
          contextualMessage() {
            const e3 = this.span.start.getContext(100, 3);
            return e3 ? `${this.msg} ("${e3.before}[${u2[this.level]} ->]${e3.after}")` : this.msg;
          }
          toString() {
            const e3 = this.span.details ? `, ${this.span.details}` : "";
            return `${this.contextualMessage()}: ${this.span.start}${e3}`;
          }
        }, t2.typeSourceSpan = function(e3, t3) {
          const u3 = Wj.identifierModuleUrl(t3), o2 = u3 != null ? `in ${e3} ${Wj.identifierName(t3)} in ${u3}` : `in ${e3} ${Wj.identifierName(t3)}`, s2 = new r2("", o2);
          return new i2(new n2(s2, -1, -1, -1), new n2(s2, -1, -1, -1));
        }, t2.r3JitTypeSourceSpan = function(e3, t3, u3) {
          const o2 = new r2("", `in ${e3} ${t3} in ${u3}`);
          return new i2(new n2(o2, -1, -1, -1), new n2(o2, -1, -1, -1));
        };
      });
      const { ParseSourceSpan: Uj } = qj, { htmlTrim: zj, getLeadingAndTrailingHtmlWhitespace: Gj, hasHtmlWhitespace: Hj, canHaveInterpolation: Jj, getNodeCssStyleDisplay: Xj, isDanglingSpaceSensitiveNode: Yj, isIndentationSensitiveNode: Kj, isLeadingSpaceSensitiveNode: Qj, isTrailingSpaceSensitiveNode: Zj, isWhitespaceSensitiveNode: e_ } = sj, t_ = [function(e2) {
        e2.walk((e3) => {
          if (e3.type === "element" && e3.tagDefinition.ignoreFirstLf && e3.children.length > 0 && e3.children[0].type === "text" && e3.children[0].value[0] === "\n") {
            const [t2, ...n2] = e3.children;
            e3.setChildren(t2.value.length === 1 ? n2 : [t2.clone({ value: t2.value.slice(1) }), ...n2]);
          }
        });
      }, function(e2) {
        const t2 = (e3) => e3.type === "element" && e3.prev && e3.prev.type === "ieConditionalStartComment" && e3.prev.sourceSpan.end.offset === e3.startSourceSpan.start.offset && e3.firstChild && e3.firstChild.type === "ieConditionalEndComment" && e3.firstChild.sourceSpan.start.offset === e3.startSourceSpan.end.offset;
        e2.walk((e3) => {
          if (e3.children) {
            const n2 = e3.children.map(t2);
            if (n2.some(Boolean)) {
              const t3 = [];
              for (let r2 = 0; r2 < e3.children.length; r2++) {
                const i2 = e3.children[r2];
                if (!n2[r2 + 1])
                  if (n2[r2]) {
                    const e4 = i2.prev, n3 = i2.firstChild, r3 = new Uj(e4.sourceSpan.start, n3.sourceSpan.end), u2 = new Uj(r3.start, i2.sourceSpan.end);
                    t3.push(i2.clone({ condition: e4.condition, sourceSpan: u2, startSourceSpan: r3, children: i2.children.slice(1) }));
                  } else
                    t3.push(i2);
              }
              e3.setChildren(t3);
            }
          }
        });
      }, function(e2) {
        return function(e3, t2, n2) {
          e3.walk((e4) => {
            if (e4.children) {
              const r2 = e4.children.map(t2);
              if (r2.some(Boolean)) {
                const t3 = [];
                for (let i2 = 0; i2 < e4.children.length; i2++) {
                  const u2 = e4.children[i2];
                  if (u2.type !== "text" && !r2[i2]) {
                    t3.push(u2);
                    continue;
                  }
                  const o2 = u2.type === "text" ? u2 : u2.clone({ type: "text", value: n2(u2) });
                  if (t3.length === 0 || _n(t3).type !== "text") {
                    t3.push(o2);
                    continue;
                  }
                  const s2 = t3.pop();
                  t3.push(s2.clone({ value: s2.value + o2.value, sourceSpan: new Uj(s2.sourceSpan.start, o2.sourceSpan.end) }));
                }
                e4.setChildren(t3);
              }
            }
          });
        }(e2, (e3) => e3.type === "cdata", (e3) => `<![CDATA[${e3.value}]]>`);
      }, function(e2, t2) {
        if (t2.parser === "html")
          return;
        const n2 = /{{(.+?)}}/s;
        e2.walk((e3) => {
          if (!Jj(e3))
            return;
          const t3 = [];
          for (const r2 of e3.children) {
            if (r2.type !== "text") {
              t3.push(r2);
              continue;
            }
            let e4 = r2.sourceSpan.start, i2 = null;
            const u2 = r2.value.split(n2);
            for (let n3 = 0; n3 < u2.length; n3++, e4 = i2) {
              const r3 = u2[n3];
              n3 % 2 != 0 ? (i2 = e4.moveBy(r3.length + 4), t3.push({ type: "interpolation", sourceSpan: new Uj(e4, i2), children: r3.length === 0 ? [] : [{ type: "text", value: r3, sourceSpan: new Uj(e4.moveBy(2), i2.moveBy(-2)) }] })) : (i2 = e4.moveBy(r3.length), r3.length > 0 && t3.push({ type: "text", value: r3, sourceSpan: new Uj(e4, i2) }));
            }
          }
          e3.setChildren(t3);
        });
      }, function(e2) {
        e2.walk((e3) => {
          if (!e3.children)
            return;
          if (e3.children.length === 0 || e3.children.length === 1 && e3.children[0].type === "text" && zj(e3.children[0].value).length === 0)
            return e3.hasDanglingSpaces = e3.children.length > 0, void (e3.children = []);
          const t2 = e_(e3), n2 = Kj(e3);
          e3.setChildren(e3.children.flatMap((e4) => {
            if (e4.type !== "text" || t2)
              return e4;
            const n3 = [], { leadingWhitespace: r2, text: i2, trailingWhitespace: u2 } = Gj(e4.value);
            return r2 && n3.push(n_), i2 && n3.push({ type: "text", value: i2, sourceSpan: new Uj(e4.sourceSpan.start.moveBy(r2.length), e4.sourceSpan.end.moveBy(-u2.length)) }), u2 && n3.push(n_), n3;
          }).map((e4, t3, n3) => {
            if (e4 !== n_)
              return Object.assign(Object.assign({}, e4), {}, { hasLeadingSpaces: n3[t3 - 1] === n_, hasTrailingSpaces: n3[t3 + 1] === n_ });
          }).filter(Boolean)), e3.isWhitespaceSensitive = t2, e3.isIndentationSensitive = n2;
        });
      }, function(e2, t2) {
        e2.walk((e3) => Object.assign(e3, { cssDisplay: Xj(e3, t2) }));
      }, function(e2) {
        e2.walk((e3) => Object.assign(e3, { isSelfClosing: !e3.children || e3.type === "element" && (e3.tagDefinition.isVoid || e3.startSourceSpan === e3.endSourceSpan) }));
      }, function(e2, t2) {
        e2.walk((e3) => e3.type !== "element" ? e3 : Object.assign(e3, { hasHtmComponentClosingTag: e3.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(t2.originalText.slice(e3.endSourceSpan.start.offset, e3.endSourceSpan.end.offset)) }));
      }, function(e2, t2) {
        e2.walk((e3) => {
          e3.children && (e3.children.length !== 0 ? e3.setChildren(e3.children.map((e4) => Object.assign(Object.assign({}, e4), {}, { isLeadingSpaceSensitive: Qj(e4, t2), isTrailingSpaceSensitive: Zj(e4, t2) })).map((e4, t3, n2) => Object.assign(Object.assign({}, e4), {}, { isLeadingSpaceSensitive: (t3 === 0 || n2[t3 - 1].isTrailingSpaceSensitive) && e4.isLeadingSpaceSensitive, isTrailingSpaceSensitive: (t3 === n2.length - 1 || n2[t3 + 1].isLeadingSpaceSensitive) && e4.isTrailingSpaceSensitive }))) : e3.isDanglingSpaceSensitive = Yj(e3));
        });
      }, function(e2) {
        const t2 = (e3) => e3.type === "element" && e3.attrs.length === 0 && e3.children.length === 1 && e3.firstChild.type === "text" && !Hj(e3.children[0].value) && !e3.firstChild.hasLeadingSpaces && !e3.firstChild.hasTrailingSpaces && e3.isLeadingSpaceSensitive && !e3.hasLeadingSpaces && e3.isTrailingSpaceSensitive && !e3.hasTrailingSpaces && e3.prev && e3.prev.type === "text" && e3.next && e3.next.type === "text";
        e2.walk((e3) => {
          if (e3.children) {
            const n2 = e3.children.map(t2);
            if (n2.some(Boolean)) {
              const t3 = [];
              for (let r2 = 0; r2 < e3.children.length; r2++) {
                const i2 = e3.children[r2];
                if (n2[r2]) {
                  const n3 = t3.pop(), u2 = e3.children[++r2], { isTrailingSpaceSensitive: o2, hasTrailingSpaces: s2 } = u2;
                  t3.push(n3.clone({ value: n3.value + `<${i2.rawName}>` + i2.firstChild.value + `</${i2.rawName}>` + u2.value, sourceSpan: new Uj(n3.sourceSpan.start, u2.sourceSpan.end), isTrailingSpaceSensitive: o2, hasTrailingSpaces: s2 }));
                } else
                  t3.push(i2);
              }
              e3.setChildren(t3);
            }
          }
        });
      }];
      const n_ = { type: "whitespace" };
      var r_ = function(e2, t2) {
        const n2 = e2.map((e3) => e3);
        for (const e3 of t_)
          e3(n2, t2);
        return n2;
      };
      var i_ = { hasPragma: function(e2) {
        return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(e2);
      }, insertPragma: function(e2) {
        return "<!-- @format -->\n\n" + e2.replace(/^\s*\n/, "");
      } };
      var u_ = { locStart: function(e2) {
        return e2.sourceSpan.start.offset;
      }, locEnd: function(e2) {
        return e2.sourceSpan.end.offset;
      } };
      const { isNonEmptyArray: o_ } = Fi, { builders: { indent: s_, join: a_, line: c_, softline: l_ }, utils: { replaceTextEndOfLine: p_ } } = su, { locStart: f_, locEnd: d_ } = u_, { isTextLikeNode: h_, getLastDescendant: g_, isPreLikeNode: m_, hasPrettierIgnore: y_, shouldPreserveContent: D_ } = sj;
      function E_(e2, t2) {
        return e2.lastChild && T_(e2.lastChild) ? "" : [b_(e2, t2), v_(e2, t2)];
      }
      function C_(e2, t2) {
        return (e2.next ? S_(e2.next) : w_(e2.parent)) ? "" : [F_(e2, t2), A_(e2, t2)];
      }
      function b_(e2, t2) {
        return w_(e2) ? F_(e2.lastChild, t2) : "";
      }
      function A_(e2, t2) {
        return T_(e2) ? v_(e2.parent, t2) : B_(e2) ? L_(e2.next) : "";
      }
      function v_(e2, t2) {
        if (Ff(!e2.isSelfClosing), x_(e2, t2))
          return "";
        switch (e2.type) {
          case "ieConditionalComment":
            return "<!";
          case "element":
            if (e2.hasHtmComponentClosingTag)
              return "<//";
          default:
            return `</${e2.rawName}`;
        }
      }
      function F_(e2, t2) {
        if (x_(e2, t2))
          return "";
        switch (e2.type) {
          case "ieConditionalComment":
          case "ieConditionalEndComment":
            return "[endif]-->";
          case "ieConditionalStartComment":
            return "]><!-->";
          case "interpolation":
            return "}}";
          case "element":
            if (e2.isSelfClosing)
              return "/>";
          default:
            return ">";
        }
      }
      function x_(e2, t2) {
        return !e2.isSelfClosing && !e2.endSourceSpan && (y_(e2) || D_(e2.parent, t2));
      }
      function S_(e2) {
        return e2.prev && e2.prev.type !== "docType" && !h_(e2.prev) && e2.isLeadingSpaceSensitive && !e2.hasLeadingSpaces;
      }
      function w_(e2) {
        return e2.lastChild && e2.lastChild.isTrailingSpaceSensitive && !e2.lastChild.hasTrailingSpaces && !h_(g_(e2.lastChild)) && !m_(e2);
      }
      function T_(e2) {
        return !e2.next && !e2.hasTrailingSpaces && e2.isTrailingSpaceSensitive && h_(g_(e2));
      }
      function B_(e2) {
        return e2.next && !h_(e2.next) && h_(e2) && e2.isTrailingSpaceSensitive && !e2.hasTrailingSpaces;
      }
      function N_(e2) {
        return !e2.prev && e2.isLeadingSpaceSensitive && !e2.hasLeadingSpaces;
      }
      function k_(e2, t2, n2) {
        const r2 = e2.getValue();
        if (!o_(r2.attrs))
          return r2.isSelfClosing ? " " : "";
        const i2 = r2.prev && r2.prev.type === "comment" && function(e3) {
          const t3 = e3.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
          return !!t3 && (!t3[1] || t3[1].split(/\s+/));
        }(r2.prev.value), u2 = typeof i2 == "boolean" ? () => i2 : Array.isArray(i2) ? (e3) => i2.includes(e3.rawName) : () => false, o2 = e2.map((e3) => {
          const r3 = e3.getValue();
          return u2(r3) ? p_(t2.originalText.slice(f_(r3), d_(r3))) : n2();
        }, "attrs"), s2 = r2.type === "element" && r2.fullName === "script" && r2.attrs.length === 1 && r2.attrs[0].fullName === "src" && r2.children.length === 0, a2 = [s_([s2 ? " " : c_, a_(c_, o2)])];
        return r2.firstChild && N_(r2.firstChild) || r2.isSelfClosing && w_(r2.parent) || s2 ? a2.push(r2.isSelfClosing ? " " : "") : a2.push(t2.bracketSameLine ? r2.isSelfClosing ? " " : "" : r2.isSelfClosing ? c_ : l_), a2;
      }
      function P_(e2) {
        return e2.firstChild && N_(e2.firstChild) ? "" : j_(e2);
      }
      function O_(e2, t2) {
        return e2.prev && B_(e2.prev) ? "" : [I_(e2, t2), L_(e2)];
      }
      function I_(e2, t2) {
        return N_(e2) ? j_(e2.parent) : S_(e2) ? F_(e2.prev, t2) : "";
      }
      function L_(e2) {
        switch (e2.type) {
          case "ieConditionalComment":
          case "ieConditionalStartComment":
            return `<!--[if ${e2.condition}`;
          case "ieConditionalEndComment":
            return "<!--<!";
          case "interpolation":
            return "{{";
          case "docType":
            return "<!DOCTYPE";
          case "element":
            if (e2.condition)
              return `<!--[if ${e2.condition}]><!--><${e2.rawName}`;
          default:
            return `<${e2.rawName}`;
        }
      }
      function j_(e2) {
        switch (Ff(!e2.isSelfClosing), e2.type) {
          case "ieConditionalComment":
            return "]>";
          case "element":
            if (e2.condition)
              return "><!--<![endif]-->";
          default:
            return ">";
        }
      }
      var __ = { printClosingTag: function(e2, t2) {
        return [e2.isSelfClosing ? "" : E_(e2, t2), C_(e2, t2)];
      }, printClosingTagStart: E_, printClosingTagStartMarker: v_, printClosingTagEndMarker: F_, printClosingTagSuffix: A_, printClosingTagEnd: C_, needsToBorrowLastChildClosingTagEndMarker: w_, needsToBorrowParentClosingTagStartMarker: T_, needsToBorrowPrevClosingTagEndMarker: S_, printOpeningTag: function(e2, t2, n2) {
        const r2 = e2.getValue();
        return [O_(r2, t2), k_(e2, t2, n2), r2.isSelfClosing ? "" : P_(r2)];
      }, printOpeningTagStart: O_, printOpeningTagPrefix: I_, printOpeningTagStartMarker: L_, printOpeningTagEndMarker: j_, needsToBorrowNextOpeningTagStartMarker: B_, needsToBorrowParentOpeningTagEndMarker: N_ }, M_ = r(function(e2) {
        var n2, r2;
        n2 = t, r2 = function() {
          return function(e3, t2) {
            var n3 = t2 && t2.logger || console;
            function r3(e4) {
              return e4 === " " || e4 === "	" || e4 === "\n" || e4 === "\f" || e4 === "\r";
            }
            function i2(t3) {
              var n4, r4 = t3.exec(e3.substring(y2));
              if (r4)
                return n4 = r4[0], y2 += n4.length, n4;
            }
            for (var u2, o2, s2, a2, c2, l2 = e3.length, p2 = /^[ \t\n\r\u000c]+/, f2 = /^[, \t\n\r\u000c]+/, d2 = /^[^ \t\n\r\u000c]+/, h2 = /[,]+$/, g2 = /^\d+$/, m2 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, y2 = 0, D2 = []; ; ) {
              if (i2(f2), y2 >= l2)
                return D2;
              u2 = i2(d2), o2 = [], u2.slice(-1) === "," ? (u2 = u2.replace(h2, ""), C2()) : E2();
            }
            function E2() {
              for (i2(p2), s2 = "", a2 = "in descriptor"; ; ) {
                if (c2 = e3.charAt(y2), a2 === "in descriptor")
                  if (r3(c2))
                    s2 && (o2.push(s2), s2 = "", a2 = "after descriptor");
                  else {
                    if (c2 === ",")
                      return y2 += 1, s2 && o2.push(s2), void C2();
                    if (c2 === "(")
                      s2 += c2, a2 = "in parens";
                    else {
                      if (c2 === "")
                        return s2 && o2.push(s2), void C2();
                      s2 += c2;
                    }
                  }
                else if (a2 === "in parens")
                  if (c2 === ")")
                    s2 += c2, a2 = "in descriptor";
                  else {
                    if (c2 === "")
                      return o2.push(s2), void C2();
                    s2 += c2;
                  }
                else if (a2 === "after descriptor")
                  if (r3(c2))
                    ;
                  else {
                    if (c2 === "")
                      return void C2();
                    a2 = "in descriptor", y2 -= 1;
                  }
                y2 += 1;
              }
            }
            function C2() {
              var t3, r4, i3, s3, a3, c3, l3, p3, f3, d3 = false, h3 = {};
              for (s3 = 0; s3 < o2.length; s3++)
                c3 = (a3 = o2[s3])[a3.length - 1], l3 = a3.substring(0, a3.length - 1), p3 = parseInt(l3, 10), f3 = parseFloat(l3), g2.test(l3) && c3 === "w" ? ((t3 || r4) && (d3 = true), p3 === 0 ? d3 = true : t3 = p3) : m2.test(l3) && c3 === "x" ? ((t3 || r4 || i3) && (d3 = true), f3 < 0 ? d3 = true : r4 = f3) : g2.test(l3) && c3 === "h" ? ((i3 || r4) && (d3 = true), p3 === 0 ? d3 = true : i3 = p3) : d3 = true;
              d3 ? n3 && n3.error && n3.error("Invalid srcset descriptor found in '" + e3 + "' at '" + a3 + "'.") : (h3.url = u2, t3 && (h3.w = t3), r4 && (h3.d = r4), i3 && (h3.h = i3), D2.push(h3));
            }
          };
        }, e2.exports ? e2.exports = r2() : n2.parseSrcset = r2();
      });
      const { builders: { group: R_, ifBreak: $_, indent: V_, join: W_, line: q_, softline: U_ } } = su;
      const z_ = [":", "__", "--", "_", "-"];
      function G_(e2) {
        const t2 = e2.search(/[^_-]/);
        if (t2 !== -1)
          for (const n2 of z_) {
            const r2 = e2.indexOf(n2, t2);
            if (r2 !== -1)
              return e2.slice(0, r2);
          }
        return e2;
      }
      var H_ = { printImgSrcset: function(e2) {
        const t2 = M_(e2, { logger: { error(e3) {
          throw new Error(e3);
        } } }), n2 = t2.some(({ w: e3 }) => e3), r2 = t2.some(({ h: e3 }) => e3);
        if (n2 + r2 + t2.some(({ d: e3 }) => e3) > 1)
          throw new Error("Mixed descriptor in srcset is not supported");
        const i2 = n2 ? "w" : r2 ? "h" : "d", u2 = n2 ? "w" : r2 ? "h" : "x", o2 = (e3) => Math.max(...e3), s2 = t2.map((e3) => e3.url), a2 = o2(s2.map((e3) => e3.length)), c2 = t2.map((e3) => e3[i2]).map((e3) => e3 ? e3.toString() : ""), l2 = c2.map((e3) => {
          const t3 = e3.indexOf(".");
          return t3 === -1 ? e3.length : t3;
        }), p2 = o2(l2);
        return W_([",", q_], s2.map((e3, t3) => {
          const n3 = [e3], r3 = c2[t3];
          if (r3) {
            const i3 = a2 - e3.length + 1, o3 = p2 - l2[t3], s3 = " ".repeat(i3 + o3);
            n3.push($_(s3, " "), r3 + u2);
          }
          return n3;
        }));
      }, printClassNames: function(e2) {
        const t2 = e2.trim().split(/\s+/), n2 = [];
        let r2;
        for (let e3 = 0; e3 < t2.length; e3++) {
          const i2 = G_(t2[e3]);
          i2 !== r2 && i2 !== t2[e3 - 1] && n2.push([]), _n(n2).push(t2[e3]), r2 = i2;
        }
        return [V_([U_, W_(q_, n2.map((e3) => R_(W_(q_, e3))))]), U_];
      } };
      const { builders: { group: J_ } } = su;
      var X_ = { isVueEventBindingExpression: function(e2) {
        const t2 = e2.trim();
        return /^(?:[\w$]+|\([^)]*?\))\s*=>|^function\s*\(/.test(t2) || /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/.test(t2);
      }, printVueFor: function(e2, t2) {
        const { left: n2, operator: r2, right: i2 } = function(e3) {
          const t3 = /(.*?)\s+(in|of)\s+(.*)/s, n3 = /,([^,\]}]*)(?:,([^,\]}]*))?$/, r3 = /^\(|\)$/g, i3 = e3.match(t3);
          if (!i3)
            return;
          const u2 = {};
          u2.for = i3[3].trim();
          const o2 = i3[1].trim().replace(r3, ""), s2 = o2.match(n3);
          s2 ? (u2.alias = o2.replace(n3, ""), u2.iterator1 = s2[1].trim(), s2[2] && (u2.iterator2 = s2[2].trim())) : u2.alias = o2;
          return { left: `${[u2.alias, u2.iterator1, u2.iterator2].filter(Boolean).join(",")}`, operator: i3[2], right: u2.for };
        }(e2);
        return [J_(t2(`function _(${n2}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", r2, " ", t2(i2, { parser: "__js_expression" }, { stripTrailingHardline: true })];
      }, printVueBindings: function(e2, t2) {
        return t2(`function _(${e2}) {}`, { parser: "babel", __isVueBindings: true });
      } };
      const { needsToBorrowParentClosingTagStartMarker: Y_, printClosingTagStartMarker: K_, needsToBorrowLastChildClosingTagEndMarker: Q_, printClosingTagEndMarker: Z_, needsToBorrowParentOpeningTagEndMarker: eM, printOpeningTagEndMarker: tM } = __;
      var nM = function(e2, t2) {
        let n2 = e2.startSourceSpan.end.offset;
        e2.firstChild && eM(e2.firstChild) && (n2 -= tM(e2).length);
        let r2 = e2.endSourceSpan.start.offset;
        return e2.lastChild && Y_(e2.lastChild) ? r2 += K_(e2, t2).length : Q_(e2) && (r2 -= Z_(e2.lastChild, t2).length), t2.originalText.slice(n2, r2);
      };
      const { builders: { breakParent: rM, group: iM, hardline: uM, indent: oM, line: sM, fill: aM, softline: cM }, utils: { mapDoc: lM, replaceTextEndOfLine: pM } } = su, { printClosingTag: fM, printClosingTagSuffix: dM, needsToBorrowPrevClosingTagEndMarker: hM, printOpeningTagPrefix: gM, printOpeningTag: mM } = __, { printImgSrcset: yM, printClassNames: DM } = H_, { printVueFor: EM, printVueBindings: CM, isVueEventBindingExpression: bM } = X_, { isScriptLikeTag: AM, isVueNonHtmlBlock: vM, inferScriptParser: FM, htmlTrimPreserveIndentation: xM, dedentString: SM, unescapeQuoteEntities: wM, isVueSlotAttribute: TM, isVueSfcBindingsAttribute: BM, getTextValueParts: NM } = sj;
      function kM(e2, t2, n2) {
        const r2 = (t3) => new RegExp(t3.join("|")).test(e2.fullName), i2 = () => wM(e2.value);
        let u2 = false;
        const o2 = (e3, t3) => {
          const n3 = e3.type === "NGRoot" ? e3.node.type === "NGMicrosyntax" && e3.node.body.length === 1 && e3.node.body[0].type === "NGMicrosyntaxExpression" ? e3.node.body[0].expression : e3.node : e3.type === "JsExpressionRoot" ? e3.node : e3;
          !n3 || n3.type !== "ObjectExpression" && n3.type !== "ArrayExpression" && (t3.parser !== "__vue_expression" || n3.type !== "TemplateLiteral" && n3.type !== "StringLiteral") || (u2 = true);
        }, s2 = (e3, t3 = true) => iM([oM([cM, e3]), t3 ? cM : ""]), a2 = (e3) => u2 ? ((e4) => iM(e4))(e3) : s2(e3), c2 = (e3, n3) => t2(e3, Object.assign({ __onHtmlBindingRoot: o2, __embeddedInHtml: true }, n3), { stripTrailingHardline: true });
        if (e2.fullName === "srcset" && (e2.parent.fullName === "img" || e2.parent.fullName === "source"))
          return s2(yM(i2()));
        if (e2.fullName === "class" && !n2.parentParser) {
          const e3 = i2();
          if (!e3.includes("{{"))
            return DM(e3);
        }
        if (e2.fullName === "style" && !n2.parentParser) {
          const e3 = i2();
          if (!e3.includes("{{"))
            return s2(c2(e3, { parser: "css", __isHTMLStyleAttribute: true }));
        }
        if (n2.parser === "vue") {
          if (e2.fullName === "v-for")
            return EM(i2(), c2);
          if (TM(e2) || BM(e2, n2))
            return CM(i2(), c2);
          const t3 = ["^:", "^v-bind:"], u3 = ["^v-"];
          if (r2(["^@", "^v-on:"])) {
            const e3 = i2();
            return a2(c2(e3, { parser: bM(e3) ? "__js_expression" : "__vue_event_binding" }));
          }
          if (r2(t3))
            return a2(c2(i2(), { parser: "__vue_expression" }));
          if (r2(u3))
            return a2(c2(i2(), { parser: "__js_expression" }));
        }
        if (n2.parser === "angular") {
          const t3 = (e3, t4) => c2(e3, Object.assign(Object.assign({}, t4), {}, { trailingComma: "none" })), n3 = ["^\\*"], u3 = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], o3 = ["^i18n(-.+)?$"];
          if (r2(["^\\(.+\\)$", "^on-"]))
            return a2(t3(i2(), { parser: "__ng_action" }));
          if (r2(u3))
            return a2(t3(i2(), { parser: "__ng_binding" }));
          if (r2(o3)) {
            const t4 = i2().trim();
            return s2(aM(NM(e2, t4)), !t4.includes("@@"));
          }
          if (r2(n3))
            return a2(t3(i2(), { parser: "__ng_directive" }));
          const l2 = /{{(.+?)}}/s, p2 = i2();
          if (l2.test(p2)) {
            const e3 = [];
            for (const [n4, r3] of p2.split(l2).entries())
              if (n4 % 2 == 0)
                e3.push(pM(r3));
              else
                try {
                  e3.push(iM(["{{", oM([sM, t3(r3, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), sM, "}}"]));
                } catch {
                  e3.push("{{", pM(r3), "}}");
                }
            return iM(e3);
          }
        }
        return null;
      }
      var PM = function(e2, t2, n2, r2) {
        const i2 = e2.getValue();
        switch (i2.type) {
          case "element":
            if (AM(i2) || i2.type === "interpolation")
              return;
            if (!i2.isSelfClosing && vM(i2, r2)) {
              const u2 = FM(i2, r2);
              if (!u2)
                return;
              const o2 = nM(i2, r2);
              let s2 = /^\s*$/.test(o2), a2 = "";
              return s2 || (a2 = n2(xM(o2), { parser: u2, __embeddedInHtml: true }, { stripTrailingHardline: true }), s2 = a2 === ""), [gM(i2, r2), iM(mM(e2, r2, t2)), s2 ? "" : uM, a2, s2 ? "" : uM, fM(i2, r2), dM(i2, r2)];
            }
            break;
          case "text":
            if (AM(i2.parent)) {
              const e3 = FM(i2.parent);
              if (e3) {
                const t3 = e3 === "markdown" ? SM(i2.value.replace(/^[^\S\n]*?\n/, "")) : i2.value, u2 = { parser: e3, __embeddedInHtml: true };
                if (r2.parser === "html" && e3 === "babel") {
                  let e4 = "script";
                  const { attrMap: t4 } = i2.parent;
                  t4 && (t4.type === "module" || t4.type === "text/babel" && t4["data-type"] === "module") && (e4 = "module"), u2.__babelSourceType = e4;
                }
                return [rM, gM(i2, r2), n2(t3, u2, { stripTrailingHardline: true }), dM(i2, r2)];
              }
            } else if (i2.parent.type === "interpolation") {
              const e3 = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
              return r2.parser === "angular" ? (e3.parser = "__ng_interpolation", e3.trailingComma = "none") : r2.parser === "vue" ? e3.parser = "__vue_expression" : e3.parser = "__js_expression", [oM([sM, n2(i2.value, e3, { stripTrailingHardline: true })]), i2.parent.next && hM(i2.parent.next) ? " " : sM];
            }
            break;
          case "attribute": {
            if (!i2.value)
              break;
            if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(r2.originalText.slice(i2.valueSpan.start.offset, i2.valueSpan.end.offset)))
              return [i2.rawName, "=", i2.value];
            if (r2.parser === "lwc") {
              if (/^{.*}$/s.test(r2.originalText.slice(i2.valueSpan.start.offset, i2.valueSpan.end.offset)))
                return [i2.rawName, "=", i2.value];
            }
            const e3 = kM(i2, (e4, t3) => n2(e4, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, t3), { stripTrailingHardline: true }), r2);
            if (e3)
              return [i2.rawName, '="', iM(lM(e3, (e4) => typeof e4 == "string" ? e4.replace(/"/g, "&quot;") : e4)), '"'];
            break;
          }
          case "front-matter":
            return dN(i2, n2);
        }
      };
      const { builders: { breakParent: OM, group: IM, ifBreak: LM, line: jM, softline: _M, hardline: MM }, utils: { replaceTextEndOfLine: RM } } = su, { locStart: $M, locEnd: VM } = u_, { forceBreakChildren: WM, forceNextEmptyLine: qM, isTextLikeNode: UM, hasPrettierIgnore: zM, preferHardlineAsLeadingSpaces: GM } = sj, { printOpeningTagPrefix: HM, needsToBorrowNextOpeningTagStartMarker: JM, printOpeningTagStartMarker: XM, needsToBorrowPrevClosingTagEndMarker: YM, printClosingTagEndMarker: KM, printClosingTagSuffix: QM, needsToBorrowParentClosingTagStartMarker: ZM } = __;
      function eR(e2, t2, n2) {
        const r2 = e2.getValue();
        return zM(r2) ? [HM(r2, t2), ...RM(t2.originalText.slice($M(r2) + (r2.prev && JM(r2.prev) ? XM(r2).length : 0), VM(r2) - (r2.next && YM(r2.next) ? KM(r2, t2).length : 0))), QM(r2, t2)] : n2();
      }
      function tR(e2, t2) {
        return UM(e2) && UM(t2) ? e2.isTrailingSpaceSensitive ? e2.hasTrailingSpaces ? GM(t2) ? MM : jM : "" : GM(t2) ? MM : _M : JM(e2) && (zM(t2) || t2.firstChild || t2.isSelfClosing || t2.type === "element" && t2.attrs.length > 0) || e2.type === "element" && e2.isSelfClosing && YM(t2) ? "" : !t2.isLeadingSpaceSensitive || GM(t2) || YM(t2) && e2.lastChild && ZM(e2.lastChild) && e2.lastChild.lastChild && ZM(e2.lastChild.lastChild) ? MM : t2.hasLeadingSpaces ? jM : _M;
      }
      var nR = { printChildren: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (WM(r2))
          return [OM, ...e2.map((e3) => {
            const r3 = e3.getValue(), i3 = r3.prev ? tR(r3.prev, r3) : "";
            return [i3 ? [i3, qM(r3.prev) ? MM : ""] : "", eR(e3, t2, n2)];
          }, "children")];
        const i2 = r2.children.map(() => Symbol(""));
        return e2.map((e3, r3) => {
          const u2 = e3.getValue();
          if (UM(u2)) {
            if (u2.prev && UM(u2.prev)) {
              const r4 = tR(u2.prev, u2);
              if (r4)
                return qM(u2.prev) ? [MM, MM, eR(e3, t2, n2)] : [r4, eR(e3, t2, n2)];
            }
            return eR(e3, t2, n2);
          }
          const o2 = [], s2 = [], a2 = [], c2 = [], l2 = u2.prev ? tR(u2.prev, u2) : "", p2 = u2.next ? tR(u2, u2.next) : "";
          return l2 && (qM(u2.prev) ? o2.push(MM, MM) : l2 === MM ? o2.push(MM) : UM(u2.prev) ? s2.push(l2) : s2.push(LM("", _M, { groupId: i2[r3 - 1] }))), p2 && (qM(u2) ? UM(u2.next) && c2.push(MM, MM) : p2 === MM ? UM(u2.next) && c2.push(MM) : a2.push(p2)), [...o2, IM([...s2, IM([eR(e3, t2, n2), ...a2], { id: i2[r3] })]), ...c2];
        }, "children");
      } };
      const { builders: { breakParent: rR, dedentToRoot: iR, group: uR, ifBreak: oR, indentIfBreak: sR, indent: aR, line: cR, softline: lR }, utils: { replaceTextEndOfLine: pR } } = su, { shouldPreserveContent: fR, isScriptLikeTag: dR, isVueCustomBlock: hR, countParents: gR, forceBreakContent: mR } = sj, { printOpeningTagPrefix: yR, printOpeningTag: DR, printClosingTagSuffix: ER, printClosingTag: CR, needsToBorrowPrevClosingTagEndMarker: bR, needsToBorrowLastChildClosingTagEndMarker: AR } = __, { printChildren: vR } = nR;
      var FR = { printElement: function(e2, t2, n2) {
        const r2 = e2.getValue();
        if (fR(r2, t2))
          return [yR(r2, t2), uR(DR(e2, t2, n2)), ...pR(nM(r2, t2)), ...CR(r2, t2), ER(r2, t2)];
        const i2 = r2.children.length === 1 && r2.firstChild.type === "interpolation" && r2.firstChild.isLeadingSpaceSensitive && !r2.firstChild.hasLeadingSpaces && r2.lastChild.isTrailingSpaceSensitive && !r2.lastChild.hasTrailingSpaces, u2 = Symbol("element-attr-group-id"), o2 = (i3) => uR([uR(DR(e2, t2, n2), { id: u2 }), i3, CR(r2, t2)]);
        return r2.children.length === 0 ? o2(r2.hasDanglingSpaces && r2.isDanglingSpaceSensitive ? cR : "") : o2([mR(r2) ? rR : "", (s2 = [i2 ? oR(lR, "", { groupId: u2 }) : r2.firstChild.hasLeadingSpaces && r2.firstChild.isLeadingSpaceSensitive ? cR : r2.firstChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive ? iR(lR) : lR, vR(e2, t2, n2)], i2 ? sR(s2, { groupId: u2 }) : !dR(r2) && !hR(r2, t2) || r2.parent.type !== "root" || t2.parser !== "vue" || t2.vueIndentScriptAndStyle ? aR(s2) : s2), (r2.next ? bR(r2.next) : AR(r2.parent)) ? r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? " " : "" : i2 ? oR(lR, "", { groupId: u2 }) : r2.lastChild.hasTrailingSpaces && r2.lastChild.isTrailingSpaceSensitive ? cR : (r2.lastChild.type === "comment" || r2.lastChild.type === "text" && r2.isWhitespaceSensitive && r2.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${t2.tabWidth * gR(e2, (e3) => e3.parent && e3.parent.type !== "root")}}$`).test(r2.lastChild.value) ? "" : lR]);
        var s2;
      } };
      const { builders: { fill: xR, group: SR, hardline: wR, literalline: TR }, utils: { cleanDoc: BR, getDocParts: NR, isConcat: kR, replaceTextEndOfLine: PR } } = su, { countChars: OR, unescapeQuoteEntities: IR, getTextValueParts: LR } = sj, { insertPragma: jR } = i_, { locStart: _R, locEnd: MR } = u_, { printClosingTagSuffix: RR, printClosingTagEnd: $R, printOpeningTagPrefix: VR, printOpeningTagStart: WR } = __, { printElement: qR } = FR, { printChildren: UR } = nR;
      var zR = { preprocess: r_, print: function(e2, t2, n2) {
        const r2 = e2.getValue();
        switch (r2.type) {
          case "front-matter":
            return PR(r2.raw);
          case "root":
            return t2.__onHtmlRoot && t2.__onHtmlRoot(r2), [SR(UR(e2, t2, n2)), wR];
          case "element":
          case "ieConditionalComment":
            return qR(e2, t2, n2);
          case "ieConditionalStartComment":
          case "ieConditionalEndComment":
            return [WR(r2), $R(r2)];
          case "interpolation":
            return [WR(r2, t2), ...e2.map(n2, "children"), $R(r2, t2)];
          case "text": {
            if (r2.parent.type === "interpolation") {
              const e4 = /\n[^\S\n]*?$/, t3 = e4.test(r2.value), n3 = t3 ? r2.value.replace(e4, "") : r2.value;
              return [...PR(n3), t3 ? wR : ""];
            }
            const e3 = BR([VR(r2, t2), ...LR(r2), RR(r2, t2)]);
            return kR(e3) || e3.type === "fill" ? xR(NR(e3)) : e3;
          }
          case "docType":
            return [SR([WR(r2, t2), " ", r2.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), $R(r2, t2)];
          case "comment":
            return [VR(r2, t2), ...PR(t2.originalText.slice(_R(r2), MR(r2)), TR), RR(r2, t2)];
          case "attribute": {
            if (r2.value === null)
              return r2.rawName;
            const e3 = IR(r2.value), t3 = OR(e3, "'") < OR(e3, '"') ? "'" : '"';
            return [r2.rawName, "=", t3, ...PR(t3 === '"' ? e3.replace(/"/g, "&quot;") : e3.replace(/'/g, "&apos;")), t3];
          }
          default:
            throw new Error(`Unexpected node type ${r2.type}`);
        }
      }, insertPragma: jR, massageAstNode: vL, embed: PM };
      const GR = "HTML";
      var HR = { bracketSameLine: KB.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: GR, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, vueIndentScriptAndStyle: { since: "1.19.0", category: GR, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } }, JR = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 }, XR = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
      var YR = { languages: [rh(JR, () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), rh(JR, (e2) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...e2.extensions, ".mjml"] })), rh(JR, () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), rh(XR, () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], printers: { html: zR }, options: HR, parsers: void 0 };
      var KR = { isPragma: function(e2) {
        return /^\s*@(?:prettier|format)\s*$/.test(e2);
      }, hasPragma: function(e2) {
        return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(e2);
      }, insertPragma: function(e2) {
        return `# @format

${e2}`;
      } };
      var QR = { locStart: function(e2) {
        return e2.position.start.offset;
      }, locEnd: function(e2) {
        return e2.position.end.offset;
      } };
      var ZR = function(e2, t2, n2, r2) {
        if (e2.getValue().type === "root" && r2.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(r2.filepath))
          return n2(r2.originalText, Object.assign(Object.assign({}, r2), {}, { parser: "json" }));
      };
      const { getLast: e$, isNonEmptyArray: t$ } = Fi;
      function n$(e2, t2) {
        return e2 && typeof e2.type == "string" && (!t2 || t2.includes(e2.type));
      }
      function r$(e2) {
        return e2.value.trim() === "prettier-ignore";
      }
      function i$(e2) {
        return e2 && t$(e2.leadingComments);
      }
      function u$(e2) {
        return e2 && t$(e2.middleComments);
      }
      function o$(e2) {
        return e2 && e2.indicatorComment;
      }
      function s$(e2) {
        return e2 && e2.trailingComment;
      }
      function a$(e2) {
        return e2 && t$(e2.endComments);
      }
      function c$(e2) {
        const t2 = [];
        let n2;
        for (const r2 of e2.split(/( +)/))
          r2 !== " " ? n2 === " " ? t2.push(r2) : t2.push((t2.pop() || "") + r2) : n2 === void 0 && t2.unshift(""), n2 = r2;
        return n2 === " " && t2.push((t2.pop() || "") + " "), t2[0] === "" && (t2.shift(), t2.unshift(" " + (t2.shift() || ""))), t2;
      }
      var l$ = { getLast: e$, getAncestorCount: function(e2, t2) {
        let n2 = 0;
        const r2 = e2.stack.length - 1;
        for (let i2 = 0; i2 < r2; i2++) {
          const r3 = e2.stack[i2];
          n$(r3) && t2(r3) && n2++;
        }
        return n2;
      }, isNode: n$, isEmptyNode: function(e2) {
        return !t$(e2.children) && !function(e3) {
          return i$(e3) || u$(e3) || o$(e3) || s$(e3) || a$(e3);
        }(e2);
      }, isInlineNode: function(e2) {
        if (!e2)
          return true;
        switch (e2.type) {
          case "plain":
          case "quoteDouble":
          case "quoteSingle":
          case "alias":
          case "flowMapping":
          case "flowSequence":
            return true;
          default:
            return false;
        }
      }, mapNode: function e2(t2, n2, r2) {
        return n2("children" in t2 ? Object.assign(Object.assign({}, t2), {}, { children: t2.children.map((r3) => e2(r3, n2, t2)) }) : t2, r2);
      }, defineShortcut: function(e2, t2, n2) {
        Object.defineProperty(e2, t2, { get: n2, enumerable: false });
      }, isNextLineEmpty: function(e2, t2) {
        let n2 = 0;
        const r2 = t2.length;
        for (let i2 = e2.position.end.offset - 1; i2 < r2; i2++) {
          const e3 = t2[i2];
          if (e3 === "\n" && n2++, n2 === 1 && /\S/.test(e3))
            return false;
          if (n2 === 2)
            return true;
        }
        return false;
      }, isLastDescendantNode: function(e2) {
        switch (e2.getValue().type) {
          case "tag":
          case "anchor":
          case "comment":
            return false;
        }
        const t2 = e2.stack.length;
        for (let n2 = 1; n2 < t2; n2++) {
          const t3 = e2.stack[n2], r2 = e2.stack[n2 - 1];
          if (Array.isArray(r2) && typeof t3 == "number" && t3 !== r2.length - 1)
            return false;
        }
        return true;
      }, getBlockValueLineContents: function(e2, { parentIndent: t2, isLastDescendant: n2, options: r2 }) {
        const i2 = e2.position.start.line === e2.position.end.line ? "" : r2.originalText.slice(e2.position.start.offset, e2.position.end.offset).match(/^[^\n]*?\n(.*)$/s)[1], u2 = e2.indent === null ? ((e3) => e3 ? e3[1].length : Number.POSITIVE_INFINITY)(i2.match(/^( *)\S/m)) : e2.indent - 1 + t2, o2 = i2.split("\n").map((e3) => e3.slice(u2));
        return r2.proseWrap === "preserve" || e2.type === "blockLiteral" ? s2(o2.map((e3) => e3.length === 0 ? [] : [e3])) : s2(o2.map((e3) => e3.length === 0 ? [] : c$(e3)).reduce((e3, t3, n3) => n3 !== 0 && o2[n3 - 1].length > 0 && t3.length > 0 && !/^\s/.test(t3[0]) && !/^\s|\s$/.test(e$(e3)) ? [...e3.slice(0, -1), [...e$(e3), ...t3]] : [...e3, t3], []).map((e3) => e3.reduce((e4, t3) => e4.length > 0 && /\s$/.test(e$(e4)) ? [...e4.slice(0, -1), e$(e4) + " " + t3] : [...e4, t3], [])).map((e3) => r2.proseWrap === "never" ? [e3.join(" ")] : e3));
        function s2(t3) {
          if (e2.chomping === "keep")
            return e$(t3).length === 0 ? t3.slice(0, -1) : t3;
          let r3 = 0;
          for (let e3 = t3.length - 1; e3 >= 0 && t3[e3].length === 0; e3--)
            r3++;
          return r3 === 0 ? t3 : r3 >= 2 && !n2 ? t3.slice(0, -(r3 - 1)) : t3.slice(0, -r3);
        }
      }, getFlowScalarLineContents: function(e2, t2, n2) {
        const r2 = t2.split("\n").map((e3, t3, n3) => t3 === 0 && t3 === n3.length - 1 ? e3 : t3 !== 0 && t3 !== n3.length - 1 ? e3.trim() : t3 === 0 ? e3.trimEnd() : e3.trimStart());
        return n2.proseWrap === "preserve" ? r2.map((e3) => e3.length === 0 ? [] : [e3]) : r2.map((e3) => e3.length === 0 ? [] : c$(e3)).reduce((t3, n3, i2) => i2 !== 0 && r2[i2 - 1].length > 0 && n3.length > 0 && (e2 !== "quoteDouble" || !e$(e$(t3)).endsWith("\\")) ? [...t3.slice(0, -1), [...e$(t3), ...n3]] : [...t3, n3], []).map((e3) => n2.proseWrap === "never" ? [e3.join(" ")] : e3);
      }, getLastDescendantNode: function e2(t2) {
        return t$(t2.children) ? e2(e$(t2.children)) : t2;
      }, hasPrettierIgnore: function(e2) {
        const t2 = e2.getValue();
        if (t2.type === "documentBody") {
          const t3 = e2.getParentNode();
          return a$(t3.head) && r$(e$(t3.head.endComments));
        }
        return i$(t2) && r$(e$(t2.leadingComments));
      }, hasLeadingComments: i$, hasMiddleComments: u$, hasIndicatorComment: o$, hasTrailingComment: s$, hasEndComments: a$ };
      const { defineShortcut: p$, mapNode: f$ } = l$;
      function d$(e2) {
        switch (e2.type) {
          case "document":
            p$(e2, "head", () => e2.children[0]), p$(e2, "body", () => e2.children[1]);
            break;
          case "documentBody":
          case "sequenceItem":
          case "flowSequenceItem":
          case "mappingKey":
          case "mappingValue":
            p$(e2, "content", () => e2.children[0]);
            break;
          case "mappingItem":
          case "flowMappingItem":
            p$(e2, "key", () => e2.children[0]), p$(e2, "value", () => e2.children[1]);
        }
        return e2;
      }
      var h$ = function(e2) {
        return f$(e2, d$);
      };
      const { builders: { softline: g$, align: m$ } } = su, { hasEndComments: y$, isNextLineEmpty: D$, isNode: E$ } = l$, C$ = new WeakMap();
      function b$(e2) {
        return y$(e2) && !E$(e2, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
      }
      var A$ = { alignWithSpaces: function(e2, t2) {
        return m$(" ".repeat(e2), t2);
      }, shouldPrintEndComments: b$, printNextEmptyLine: function(e2, t2) {
        const n2 = e2.getValue(), r2 = e2.stack[0];
        let i2;
        return C$.has(r2) ? i2 = C$.get(r2) : (i2 = new Set(), C$.set(r2, i2)), i2.has(n2.position.end.line) || (i2.add(n2.position.end.line), !D$(n2, t2) || b$(e2.getParentNode())) ? "" : g$;
      } };
      const { builders: { ifBreak: v$, line: F$, softline: x$, hardline: S$, join: w$ } } = su, { isEmptyNode: T$, getLast: B$, hasEndComments: N$ } = l$, { printNextEmptyLine: k$, alignWithSpaces: P$ } = A$;
      function O$(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = r2.type === "flowMapping", u2 = i2 ? "{" : "[", o2 = i2 ? "}" : "]";
        let s2 = x$;
        i2 && r2.children.length > 0 && n2.bracketSpacing && (s2 = F$);
        const a2 = B$(r2.children), c2 = a2 && a2.type === "flowMappingItem" && T$(a2.key) && T$(a2.value);
        return [u2, P$(n2.tabWidth, [s2, I$(e2, t2, n2), n2.trailingComma === "none" ? "" : v$(","), N$(r2) ? [S$, w$(S$, e2.map(t2, "endComments"))] : ""]), c2 ? "" : s2, o2];
      }
      function I$(e2, t2, n2) {
        const r2 = e2.getValue();
        return e2.map((e3, i2) => [t2(), i2 === r2.children.length - 1 ? "" : [",", F$, r2.children[i2].position.start.line !== r2.children[i2 + 1].position.start.line ? k$(e3, n2.originalText) : ""]], "children");
      }
      var L$ = { printFlowMapping: O$, printFlowSequence: O$ };
      const { builders: { conditionalGroup: j$, group: _$, hardline: M$, ifBreak: R$, join: $$, line: V$ } } = su, { hasLeadingComments: W$, hasMiddleComments: q$, hasTrailingComment: U$, hasEndComments: z$, isNode: G$, isEmptyNode: H$, isInlineNode: J$ } = l$, { alignWithSpaces: X$ } = A$;
      function Y$(e2, t2) {
        if (!e2)
          return true;
        switch (e2.type) {
          case "plain":
          case "quoteSingle":
          case "quoteDouble":
            break;
          case "alias":
            return true;
          default:
            return false;
        }
        if (t2.proseWrap === "preserve")
          return e2.position.start.line === e2.position.end.line;
        if (/\\$/m.test(t2.originalText.slice(e2.position.start.offset, e2.position.end.offset)))
          return false;
        switch (t2.proseWrap) {
          case "never":
            return !e2.value.includes("\n");
          case "always":
            return !/[\n ]/.test(e2.value);
          default:
            return false;
        }
      }
      var K$ = function(e2, t2, n2, r2, i2) {
        const { key: u2, value: o2 } = e2, s2 = H$(u2), a2 = H$(o2);
        if (s2 && a2)
          return ": ";
        const c2 = r2("key"), l2 = function(e3) {
          return e3.key.content && e3.key.content.type === "alias";
        }(e2) ? " " : "";
        if (a2)
          return e2.type === "flowMappingItem" && t2.type === "flowMapping" ? c2 : e2.type !== "mappingItem" || !Y$(u2.content, i2) || U$(u2.content) || t2.tag && t2.tag.value === "tag:yaml.org,2002:set" ? ["? ", X$(2, c2)] : [c2, l2, ":"];
        const p2 = r2("value");
        if (s2)
          return [": ", X$(2, p2)];
        if (W$(o2) || !J$(u2.content))
          return ["? ", X$(2, c2), M$, $$("", n2.map(r2, "value", "leadingComments").map((e3) => [e3, M$])), ": ", X$(2, p2)];
        if (function(e3) {
          if (!e3)
            return true;
          switch (e3.type) {
            case "plain":
            case "quoteDouble":
            case "quoteSingle":
              return e3.position.start.line === e3.position.end.line;
            case "alias":
              return true;
            default:
              return false;
          }
        }(u2.content) && !W$(u2.content) && !q$(u2.content) && !U$(u2.content) && !z$(u2) && !W$(o2.content) && !q$(o2.content) && !z$(o2) && Y$(o2.content, i2))
          return [c2, l2, ": ", p2];
        const f2 = Symbol("mappingKey"), d2 = _$([R$("? "), _$(X$(2, c2), { id: f2 })]), h2 = [M$, ": ", X$(2, p2)], g2 = [l2, ":"];
        W$(o2.content) || z$(o2) && o2.content && !G$(o2.content, ["mapping", "sequence"]) || t2.type === "mapping" && U$(u2.content) && J$(o2.content) || G$(o2.content, ["mapping", "sequence"]) && o2.content.tag === null && o2.content.anchor === null ? g2.push(M$) : o2.content && g2.push(V$), g2.push(p2);
        const m2 = X$(i2.tabWidth, g2);
        return !Y$(u2.content, i2) || W$(u2.content) || q$(u2.content) || z$(u2) ? j$([[d2, R$(h2, m2, { groupId: f2 })]]) : j$([[c2, m2]]);
      };
      const { builders: { dedent: Q$, dedentToRoot: Z$, fill: eV, hardline: tV, join: nV, line: rV, literalline: iV, markAsRoot: uV }, utils: { getDocParts: oV } } = su, { getAncestorCount: sV, getBlockValueLineContents: aV, hasIndicatorComment: cV, isLastDescendantNode: lV, isNode: pV } = l$, { alignWithSpaces: fV } = A$;
      var dV = function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = sV(e2, (e3) => pV(e3, ["sequence", "mapping"])), u2 = lV(e2), o2 = [r2.type === "blockFolded" ? ">" : "|"];
        r2.indent !== null && o2.push(r2.indent.toString()), r2.chomping !== "clip" && o2.push(r2.chomping === "keep" ? "+" : "-"), cV(r2) && o2.push(" ", t2("indicatorComment"));
        const s2 = aV(r2, { parentIndent: i2, isLastDescendant: u2, options: n2 }), a2 = [];
        for (const [e3, t3] of s2.entries())
          e3 === 0 && a2.push(tV), a2.push(eV(oV(nV(rV, t3)))), e3 !== s2.length - 1 ? a2.push(t3.length === 0 ? tV : uV(iV)) : r2.chomping === "keep" && u2 && a2.push(Z$(t3.length === 0 ? tV : iV));
        return r2.indent === null ? o2.push(Q$(fV(n2.tabWidth, a2))) : o2.push(Z$(fV(r2.indent - 1 + i2, a2))), o2;
      };
      const { builders: { breakParent: hV, fill: gV, group: mV, hardline: yV, join: DV, line: EV, lineSuffix: CV, literalline: bV }, utils: { getDocParts: AV, replaceTextEndOfLine: vV } } = su, { isPreviousLineEmpty: FV } = Fi, { insertPragma: xV, isPragma: SV } = KR, { locStart: wV } = QR, { getFlowScalarLineContents: TV, getLastDescendantNode: BV, hasLeadingComments: NV, hasMiddleComments: kV, hasTrailingComment: PV, hasEndComments: OV, hasPrettierIgnore: IV, isLastDescendantNode: LV, isNode: jV, isInlineNode: _V } = l$, { alignWithSpaces: MV, printNextEmptyLine: RV, shouldPrintEndComments: $V } = A$, { printFlowMapping: VV, printFlowSequence: WV } = L$;
      function qV(e2, t2) {
        return PV(e2) || t2 && (t2.head.children.length > 0 || OV(t2.head));
      }
      function UV(e2, t2, n2) {
        const r2 = TV(e2, t2, n2);
        return DV(yV, r2.map((e3) => gV(AV(DV(EV, e3)))));
      }
      var zV = { preprocess: h$, embed: ZR, print: function(e2, t2, n2) {
        const r2 = e2.getValue(), i2 = [];
        r2.type !== "mappingValue" && NV(r2) && i2.push([DV(yV, e2.map(n2, "leadingComments")), yV]);
        const { tag: u2, anchor: o2 } = r2;
        u2 && i2.push(n2("tag")), u2 && o2 && i2.push(" "), o2 && i2.push(n2("anchor"));
        let s2 = "";
        jV(r2, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !LV(e2) && (s2 = RV(e2, t2.originalText)), (u2 || o2) && (jV(r2, ["sequence", "mapping"]) && !kV(r2) ? i2.push(yV) : i2.push(" ")), kV(r2) && i2.push([r2.middleComments.length === 1 ? "" : yV, DV(yV, e2.map(n2, "middleComments")), yV]);
        const a2 = e2.getParentNode();
        return IV(e2) ? i2.push(vV(t2.originalText.slice(r2.position.start.offset, r2.position.end.offset).trimEnd(), bV)) : i2.push(mV(function(e3, t3, n3, r3, i3) {
          switch (e3.type) {
            case "root": {
              const { children: t4 } = e3, r4 = [];
              n3.each((e4, n4) => {
                const u4 = t4[n4], o3 = t4[n4 + 1];
                n4 !== 0 && r4.push(yV), r4.push(i3()), qV(u4, o3) ? (r4.push(yV, "..."), PV(u4) && r4.push(" ", i3("trailingComment"))) : o3 && !PV(o3.head) && r4.push(yV, "---");
              }, "children");
              const u3 = BV(e3);
              return jV(u3, ["blockLiteral", "blockFolded"]) && u3.chomping === "keep" || r4.push(yV), r4;
            }
            case "document": {
              const u3 = [];
              return function(e4, t4, n4, r4) {
                if (n4.children[0] === e4 && /---(?:\s|$)/.test(r4.originalText.slice(wV(e4), wV(e4) + 4)) || e4.head.children.length > 0 || OV(e4.head) || PV(e4.head))
                  return "head";
                if (qV(e4, t4))
                  return false;
                return !!t4 && "root";
              }(e3, t3.children[n3.getName() + 1], t3, r3) === "head" && ((e3.head.children.length > 0 || e3.head.endComments.length > 0) && u3.push(i3("head")), PV(e3.head) ? u3.push(["---", " ", i3(["head", "trailingComment"])]) : u3.push("---")), function(e4) {
                return e4.body.children.length > 0 || OV(e4.body);
              }(e3) && u3.push(i3("body")), DV(yV, u3);
            }
            case "documentHead":
              return DV(yV, [...n3.map(i3, "children"), ...n3.map(i3, "endComments")]);
            case "documentBody": {
              const { children: t4, endComments: r4 } = e3;
              let u3 = "";
              if (t4.length > 0 && r4.length > 0) {
                const t5 = BV(e3);
                jV(t5, ["blockFolded", "blockLiteral"]) ? t5.chomping !== "keep" && (u3 = [yV, yV]) : u3 = yV;
              }
              return [DV(yV, n3.map(i3, "children")), u3, DV(yV, n3.map(i3, "endComments"))];
            }
            case "directive":
              return ["%", DV(" ", [e3.name, ...e3.parameters])];
            case "comment":
              return ["#", e3.value];
            case "alias":
              return ["*", e3.value];
            case "tag":
              return r3.originalText.slice(e3.position.start.offset, e3.position.end.offset);
            case "anchor":
              return ["&", e3.value];
            case "plain":
              return UV(e3.type, r3.originalText.slice(e3.position.start.offset, e3.position.end.offset), r3);
            case "quoteDouble":
            case "quoteSingle": {
              const t4 = "'", n4 = '"', i4 = r3.originalText.slice(e3.position.start.offset + 1, e3.position.end.offset - 1);
              if (e3.type === "quoteSingle" && i4.includes("\\") || e3.type === "quoteDouble" && /\\[^"]/.test(i4)) {
                const u4 = e3.type === "quoteDouble" ? n4 : t4;
                return [u4, UV(e3.type, i4, r3), u4];
              }
              if (i4.includes(n4))
                return [t4, UV(e3.type, e3.type === "quoteDouble" ? i4.replace(/\\"/g, n4).replace(/'/g, t4.repeat(2)) : i4, r3), t4];
              if (i4.includes(t4))
                return [n4, UV(e3.type, e3.type === "quoteSingle" ? i4.replace(/''/g, t4) : i4, r3), n4];
              const u3 = r3.singleQuote ? t4 : n4;
              return [u3, UV(e3.type, i4, r3), u3];
            }
            case "blockFolded":
            case "blockLiteral":
              return dV(n3, i3, r3);
            case "mapping":
            case "sequence":
              return DV(yV, n3.map(i3, "children"));
            case "sequenceItem":
              return ["- ", MV(2, e3.content ? i3("content") : "")];
            case "mappingKey":
            case "mappingValue":
              return e3.content ? i3("content") : "";
            case "mappingItem":
            case "flowMappingItem":
              return K$(e3, t3, n3, i3, r3);
            case "flowMapping":
              return VV(n3, i3, r3);
            case "flowSequence":
              return WV(n3, i3, r3);
            case "flowSequenceItem":
              return i3("content");
            default:
              throw new Error(`Unexpected node type ${e3.type}`);
          }
        }(r2, a2, e2, t2, n2))), PV(r2) && !jV(r2, ["document", "documentHead"]) && i2.push(CV([r2.type !== "mappingValue" || r2.content ? " " : "", a2.type === "mappingKey" && e2.getParentNode(2).type === "mapping" && _V(r2) ? "" : hV, n2("trailingComment")])), $V(r2) && i2.push(MV(r2.type === "sequenceItem" ? 2 : 0, [yV, DV(yV, e2.map((e3) => [FV(t2.originalText, e3.getValue(), wV) ? yV : "", n2()], "endComments"))])), i2.push(s2), i2;
      }, massageAstNode: function(e2, t2) {
        if (jV(t2))
          switch (delete t2.position, t2.type) {
            case "comment":
              if (SV(t2.value))
                return null;
              break;
            case "quoteDouble":
            case "quoteSingle":
              t2.type = "quote";
          }
      }, insertPragma: xV }, GV = { bracketSpacing: KB.bracketSpacing, singleQuote: KB.singleQuote, proseWrap: KB.proseWrap };
      var HV = [oN, fP, AO, qO, EL, YR, { languages: [rh({ name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 }, (e2) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...e2.filenames.filter((e3) => e3 !== "yarn.lock"), ".prettierrc", ".stylelintrc"] }))], printers: { yaml: zV }, options: GV, parsers: void 0 }];
      const { version: JV } = e, { getSupportInfo: XV } = ui;
      function YV(e2, t2 = 1) {
        return (...n2) => {
          const r2 = n2[t2] || {}, i2 = r2.plugins || [];
          return n2[t2] = Object.assign(Object.assign({}, r2), {}, { plugins: [...HV, ...Array.isArray(i2) ? i2 : Object.values(i2)] }), e2(...n2);
        };
      }
      const KV = YV(kd.formatWithCursor);
      return { formatWithCursor: KV, format: (e2, t2) => KV(e2, t2).formatted, check(e2, t2) {
        const { formatted: n2 } = KV(e2, t2);
        return n2 === e2;
      }, doc: su, getSupportInfo: YV(XV, 0), version: JV, util: th, __debug: { parse: YV(kd.parse), formatAST: YV(kd.formatAST), formatDoc: YV(kd.formatDoc), printToDoc: YV(kd.printToDoc), printDocToString: YV(kd.printDocToString) } };
    });
  }
});

// dep:prettier
var prettier_default = require_standalone();
export {
  prettier_default as default
};
/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */
/**
	   * @license
	   * Copyright Google Inc. All Rights Reserved.
	   *
	   * Use of this source code is governed by an MIT-style license that can be
	   * found in the LICENSE file at https://angular.io/license
	   */
/**
	 * @license
	 * Copyright Google Inc. All Rights Reserved.
	 *
	 * Use of this source code is governed by an MIT-style license that can be
	 * found in the LICENSE file at https://angular.io/license
	 */
//# sourceMappingURL=prettier.js.map
