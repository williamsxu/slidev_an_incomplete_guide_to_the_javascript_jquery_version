import "./chunk-A2XPJTG4.js";

// node_modules/prettier/esm/parser-babel.mjs
var e = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function t(e6) {
  return e6 && Object.prototype.hasOwnProperty.call(e6, "default") ? e6.default : e6;
}
function s(e6) {
  var t2 = { exports: {} };
  return e6(t2, t2.exports), t2.exports;
}
var r;
var i;
var a = function(e6) {
  return e6 && e6.Math == Math && e6;
};
var n = a(typeof globalThis == "object" && globalThis) || a(typeof window == "object" && window) || a(typeof self == "object" && self) || a(typeof e == "object" && e) || function() {
  return this;
}() || Function("return this")();
var o = function(e6) {
  try {
    return !!e6();
  } catch (e7) {
    return true;
  }
};
var u = !o(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var h = {}.propertyIsEnumerable;
var c = Object.getOwnPropertyDescriptor;
var p = { f: c && !h.call({ 1: 2 }, 1) ? function(e6) {
  var t2 = c(this, e6);
  return !!t2 && t2.enumerable;
} : h };
var l = function(e6, t2) {
  return { enumerable: !(1 & e6), configurable: !(2 & e6), writable: !(4 & e6), value: t2 };
};
var d = {}.toString;
var D = function(e6) {
  return d.call(e6).slice(8, -1);
};
var m = "".split;
var f = o(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(e6) {
  return D(e6) == "String" ? m.call(e6, "") : Object(e6);
} : Object;
var y = function(e6) {
  if (e6 == null)
    throw TypeError("Can't call method on " + e6);
  return e6;
};
var A = function(e6) {
  return f(y(e6));
};
var E = function(e6) {
  return typeof e6 == "object" ? e6 !== null : typeof e6 == "function";
};
var C = function(e6) {
  return typeof e6 == "function" ? e6 : void 0;
};
var x = function(e6, t2) {
  return arguments.length < 2 ? C(n[e6]) : n[e6] && n[e6][t2];
};
var F = x("navigator", "userAgent") || "";
var g = n.process;
var b = n.Deno;
var P = g && g.versions || b && b.version;
var T = P && P.v8;
T ? i = (r = T.split("."))[0] < 4 ? 1 : r[0] + r[1] : F && (!(r = F.match(/Edge\/(\d+)/)) || r[1] >= 74) && (r = F.match(/Chrome\/(\d+)/)) && (i = r[1]);
var w = i && +i;
var S = !!Object.getOwnPropertySymbols && !o(function() {
  var e6 = Symbol();
  return !String(e6) || !(Object(e6) instanceof Symbol) || !Symbol.sham && w && w < 41;
});
var B = S && !Symbol.sham && typeof Symbol.iterator == "symbol";
var N = B ? function(e6) {
  return typeof e6 == "symbol";
} : function(e6) {
  var t2 = x("Symbol");
  return typeof t2 == "function" && Object(e6) instanceof t2;
};
var I = function(e6, t2) {
  try {
    Object.defineProperty(n, e6, { value: t2, configurable: true, writable: true });
  } catch (s2) {
    n[e6] = t2;
  }
  return t2;
};
var v = n["__core-js_shared__"] || I("__core-js_shared__", {});
var k = s(function(e6) {
  (e6.exports = function(e7, t2) {
    return v[e7] || (v[e7] = t2 !== void 0 ? t2 : {});
  })("versions", []).push({ version: "3.17.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
});
var L = function(e6) {
  return Object(y(e6));
};
var O = {}.hasOwnProperty;
var M = Object.hasOwn || function(e6, t2) {
  return O.call(L(e6), t2);
};
var R = 0;
var j = Math.random();
var _ = function(e6) {
  return "Symbol(" + String(e6 === void 0 ? "" : e6) + ")_" + (++R + j).toString(36);
};
var U = k("wks");
var q = n.Symbol;
var $ = B ? q : q && q.withoutSetter || _;
var H = function(e6) {
  return M(U, e6) && (S || typeof U[e6] == "string") || (S && M(q, e6) ? U[e6] = q[e6] : U[e6] = $("Symbol." + e6)), U[e6];
};
var V = H("toPrimitive");
var z = function(e6, t2) {
  if (!E(e6) || N(e6))
    return e6;
  var s2, r2 = e6[V];
  if (r2 !== void 0) {
    if (t2 === void 0 && (t2 = "default"), s2 = r2.call(e6, t2), !E(s2) || N(s2))
      return s2;
    throw TypeError("Can't convert object to primitive value");
  }
  return t2 === void 0 && (t2 = "number"), function(e7, t3) {
    var s3, r3;
    if (t3 === "string" && typeof (s3 = e7.toString) == "function" && !E(r3 = s3.call(e7)))
      return r3;
    if (typeof (s3 = e7.valueOf) == "function" && !E(r3 = s3.call(e7)))
      return r3;
    if (t3 !== "string" && typeof (s3 = e7.toString) == "function" && !E(r3 = s3.call(e7)))
      return r3;
    throw TypeError("Can't convert object to primitive value");
  }(e6, t2);
};
var W = function(e6) {
  var t2 = z(e6, "string");
  return N(t2) ? t2 : String(t2);
};
var G = n.document;
var K = E(G) && E(G.createElement);
var X = !u && !o(function() {
  return Object.defineProperty((e6 = "div", K ? G.createElement(e6) : {}), "a", { get: function() {
    return 7;
  } }).a != 7;
  var e6;
});
var J = Object.getOwnPropertyDescriptor;
var Y = { f: u ? J : function(e6, t2) {
  if (e6 = A(e6), t2 = W(t2), X)
    try {
      return J(e6, t2);
    } catch (e7) {
    }
  if (M(e6, t2))
    return l(!p.f.call(e6, t2), e6[t2]);
} };
var Q = function(e6) {
  if (!E(e6))
    throw TypeError(String(e6) + " is not an object");
  return e6;
};
var Z = Object.defineProperty;
var ee = { f: u ? Z : function(e6, t2, s2) {
  if (Q(e6), t2 = W(t2), Q(s2), X)
    try {
      return Z(e6, t2, s2);
    } catch (e7) {
    }
  if ("get" in s2 || "set" in s2)
    throw TypeError("Accessors not supported");
  return "value" in s2 && (e6[t2] = s2.value), e6;
} };
var te = u ? function(e6, t2, s2) {
  return ee.f(e6, t2, l(1, s2));
} : function(e6, t2, s2) {
  return e6[t2] = s2, e6;
};
var se = Function.toString;
typeof v.inspectSource != "function" && (v.inspectSource = function(e6) {
  return se.call(e6);
});
var re;
var ie;
var ae;
var ne;
var oe = v.inspectSource;
var ue = n.WeakMap;
var he = typeof ue == "function" && /native code/.test(oe(ue));
var ce = k("keys");
var pe = {};
var le = n.WeakMap;
if (he || v.state) {
  de = v.state || (v.state = new le()), De = de.get, me = de.has, fe = de.set;
  re = function(e6, t2) {
    if (me.call(de, e6))
      throw new TypeError("Object already initialized");
    return t2.facade = e6, fe.call(de, e6, t2), t2;
  }, ie = function(e6) {
    return De.call(de, e6) || {};
  }, ae = function(e6) {
    return me.call(de, e6);
  };
} else {
  ye = ce[ne = "state"] || (ce[ne] = _(ne));
  pe[ye] = true, re = function(e6, t2) {
    if (M(e6, ye))
      throw new TypeError("Object already initialized");
    return t2.facade = e6, te(e6, ye, t2), t2;
  }, ie = function(e6) {
    return M(e6, ye) ? e6[ye] : {};
  }, ae = function(e6) {
    return M(e6, ye);
  };
}
var de;
var De;
var me;
var fe;
var ye;
var Ae = { set: re, get: ie, has: ae, enforce: function(e6) {
  return ae(e6) ? ie(e6) : re(e6, {});
}, getterFor: function(e6) {
  return function(t2) {
    var s2;
    if (!E(t2) || (s2 = ie(t2)).type !== e6)
      throw TypeError("Incompatible receiver, " + e6 + " required");
    return s2;
  };
} };
var Ee = s(function(e6) {
  var t2 = Ae.get, s2 = Ae.enforce, r2 = String(String).split("String");
  (e6.exports = function(e7, t3, i2, a2) {
    var o2, u2 = !!a2 && !!a2.unsafe, h2 = !!a2 && !!a2.enumerable, c2 = !!a2 && !!a2.noTargetGet;
    typeof i2 == "function" && (typeof t3 != "string" || M(i2, "name") || te(i2, "name", t3), (o2 = s2(i2)).source || (o2.source = r2.join(typeof t3 == "string" ? t3 : ""))), e7 !== n ? (u2 ? !c2 && e7[t3] && (h2 = true) : delete e7[t3], h2 ? e7[t3] = i2 : te(e7, t3, i2)) : h2 ? e7[t3] = i2 : I(t3, i2);
  })(Function.prototype, "toString", function() {
    return typeof this == "function" && t2(this).source || oe(this);
  });
});
var Ce = Math.ceil;
var xe = Math.floor;
var Fe = function(e6) {
  return isNaN(e6 = +e6) ? 0 : (e6 > 0 ? xe : Ce)(e6);
};
var ge = Math.min;
var be = function(e6) {
  return e6 > 0 ? ge(Fe(e6), 9007199254740991) : 0;
};
var Pe = Math.max;
var Te = Math.min;
var we = function(e6) {
  return function(t2, s2, r2) {
    var i2, a2 = A(t2), n2 = be(a2.length), o2 = function(e7, t3) {
      var s3 = Fe(e7);
      return s3 < 0 ? Pe(s3 + t3, 0) : Te(s3, t3);
    }(r2, n2);
    if (e6 && s2 != s2) {
      for (; n2 > o2; )
        if ((i2 = a2[o2++]) != i2)
          return true;
    } else
      for (; n2 > o2; o2++)
        if ((e6 || o2 in a2) && a2[o2] === s2)
          return e6 || o2 || 0;
    return !e6 && -1;
  };
};
var Se = { includes: we(true), indexOf: we(false) }.indexOf;
var Be = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"].concat("length", "prototype");
var Ne = { f: Object.getOwnPropertyNames || function(e6) {
  return function(e7, t2) {
    var s2, r2 = A(e7), i2 = 0, a2 = [];
    for (s2 in r2)
      !M(pe, s2) && M(r2, s2) && a2.push(s2);
    for (; t2.length > i2; )
      M(r2, s2 = t2[i2++]) && (~Se(a2, s2) || a2.push(s2));
    return a2;
  }(e6, Be);
} };
var Ie = { f: Object.getOwnPropertySymbols };
var ve = x("Reflect", "ownKeys") || function(e6) {
  var t2 = Ne.f(Q(e6)), s2 = Ie.f;
  return s2 ? t2.concat(s2(e6)) : t2;
};
var ke = function(e6, t2) {
  for (var s2 = ve(t2), r2 = ee.f, i2 = Y.f, a2 = 0; a2 < s2.length; a2++) {
    var n2 = s2[a2];
    M(e6, n2) || r2(e6, n2, i2(t2, n2));
  }
};
var Le = /#|\.prototype\./;
var Oe = function(e6, t2) {
  var s2 = Re[Me(e6)];
  return s2 == _e || s2 != je && (typeof t2 == "function" ? o(t2) : !!t2);
};
var Me = Oe.normalize = function(e6) {
  return String(e6).replace(Le, ".").toLowerCase();
};
var Re = Oe.data = {};
var je = Oe.NATIVE = "N";
var _e = Oe.POLYFILL = "P";
var Ue = Oe;
var qe = Y.f;
var $e = function(e6, t2) {
  var s2, r2, i2, a2, o2, u2 = e6.target, h2 = e6.global, c2 = e6.stat;
  if (s2 = h2 ? n : c2 ? n[u2] || I(u2, {}) : (n[u2] || {}).prototype)
    for (r2 in t2) {
      if (a2 = t2[r2], i2 = e6.noTargetGet ? (o2 = qe(s2, r2)) && o2.value : s2[r2], !Ue(h2 ? r2 : u2 + (c2 ? "." : "#") + r2, e6.forced) && i2 !== void 0) {
        if (typeof a2 == typeof i2)
          continue;
        ke(a2, i2);
      }
      (e6.sham || i2 && i2.sham) && te(a2, "sham", true), Ee(s2, r2, a2, e6);
    }
};
var He = Array.isArray || function(e6) {
  return D(e6) == "Array";
};
var Ve = function(e6) {
  if (typeof e6 != "function")
    throw TypeError(String(e6) + " is not a function");
  return e6;
};
var ze = function(e6, t2, s2) {
  if (Ve(e6), t2 === void 0)
    return e6;
  switch (s2) {
    case 0:
      return function() {
        return e6.call(t2);
      };
    case 1:
      return function(s3) {
        return e6.call(t2, s3);
      };
    case 2:
      return function(s3, r2) {
        return e6.call(t2, s3, r2);
      };
    case 3:
      return function(s3, r2, i2) {
        return e6.call(t2, s3, r2, i2);
      };
  }
  return function() {
    return e6.apply(t2, arguments);
  };
};
var We = function(e6, t2, s2, r2, i2, a2, n2, o2) {
  for (var u2, h2 = i2, c2 = 0, p2 = !!n2 && ze(n2, o2, 3); c2 < r2; ) {
    if (c2 in s2) {
      if (u2 = p2 ? p2(s2[c2], c2, t2) : s2[c2], a2 > 0 && He(u2))
        h2 = We(e6, t2, u2, be(u2.length), h2, a2 - 1) - 1;
      else {
        if (h2 >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        e6[h2] = u2;
      }
      h2++;
    }
    c2++;
  }
  return h2;
};
var Ge = We;
var Ke = H("species");
var Xe = function(e6, t2) {
  return new (function(e7) {
    var t3;
    return He(e7) && (typeof (t3 = e7.constructor) != "function" || t3 !== Array && !He(t3.prototype) ? E(t3) && (t3 = t3[Ke]) === null && (t3 = void 0) : t3 = void 0), t3 === void 0 ? Array : t3;
  }(e6))(t2 === 0 ? 0 : t2);
};
$e({ target: "Array", proto: true }, { flatMap: function(e6) {
  var t2, s2 = L(this), r2 = be(s2.length);
  return Ve(e6), (t2 = Xe(s2, 0)).length = Ge(t2, s2, s2, r2, 0, 1, e6, arguments.length > 1 ? arguments[1] : void 0), t2;
} });
var Je = function(...e6) {
  let t2;
  for (const [s2, r2] of e6.entries())
    try {
      return { result: r2() };
    } catch (e7) {
      s2 === 0 && (t2 = e7);
    }
  return { error: t2 };
};
var Ye = (e6) => typeof e6 == "string" ? e6.replace((({ onlyFirst: e7 = false } = {}) => {
  const t2 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
  return new RegExp(t2, e7 ? void 0 : "g");
})(), "") : e6;
var Qe = (e6) => !Number.isNaN(e6) && (e6 >= 4352 && (e6 <= 4447 || e6 === 9001 || e6 === 9002 || 11904 <= e6 && e6 <= 12871 && e6 !== 12351 || 12880 <= e6 && e6 <= 19903 || 19968 <= e6 && e6 <= 42182 || 43360 <= e6 && e6 <= 43388 || 44032 <= e6 && e6 <= 55203 || 63744 <= e6 && e6 <= 64255 || 65040 <= e6 && e6 <= 65049 || 65072 <= e6 && e6 <= 65131 || 65281 <= e6 && e6 <= 65376 || 65504 <= e6 && e6 <= 65510 || 110592 <= e6 && e6 <= 110593 || 127488 <= e6 && e6 <= 127569 || 131072 <= e6 && e6 <= 262141));
var Ze = Qe;
var et = Qe;
Ze.default = et;
var tt = (e6) => {
  if (typeof e6 != "string" || e6.length === 0)
    return 0;
  if ((e6 = Ye(e6)).length === 0)
    return 0;
  e6 = e6.replace(/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g, "  ");
  let t2 = 0;
  for (let s2 = 0; s2 < e6.length; s2++) {
    const r2 = e6.codePointAt(s2);
    r2 <= 31 || r2 >= 127 && r2 <= 159 || (r2 >= 768 && r2 <= 879 || (r2 > 65535 && s2++, t2 += Ze(r2) ? 2 : 1));
  }
  return t2;
};
var st = tt;
var rt = tt;
st.default = rt;
var it = (e6) => {
  if (typeof e6 != "string")
    throw new TypeError("Expected a string");
  return e6.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
var at = (e6) => e6[e6.length - 1];
function nt(e6, t2) {
  if (e6 == null)
    return {};
  var s2, r2, i2 = function(e7, t3) {
    if (e7 == null)
      return {};
    var s3, r3, i3 = {}, a3 = Object.keys(e7);
    for (r3 = 0; r3 < a3.length; r3++)
      s3 = a3[r3], t3.indexOf(s3) >= 0 || (i3[s3] = e7[s3]);
    return i3;
  }(e6, t2);
  if (Object.getOwnPropertySymbols) {
    var a2 = Object.getOwnPropertySymbols(e6);
    for (r2 = 0; r2 < a2.length; r2++)
      s2 = a2[r2], t2.indexOf(s2) >= 0 || Object.prototype.propertyIsEnumerable.call(e6, s2) && (i2[s2] = e6[s2]);
  }
  return i2;
}
var ot;
var ut;
var ht = function(e6) {
  if (N(e6))
    throw TypeError("Cannot convert a Symbol value to a string");
  return String(e6);
};
var ct = Math.floor;
var pt = function(e6, t2) {
  var s2 = e6.length, r2 = ct(s2 / 2);
  return s2 < 8 ? lt(e6, t2) : dt(pt(e6.slice(0, r2), t2), pt(e6.slice(r2), t2), t2);
};
var lt = function(e6, t2) {
  for (var s2, r2, i2 = e6.length, a2 = 1; a2 < i2; ) {
    for (r2 = a2, s2 = e6[a2]; r2 && t2(e6[r2 - 1], s2) > 0; )
      e6[r2] = e6[--r2];
    r2 !== a2++ && (e6[r2] = s2);
  }
  return e6;
};
var dt = function(e6, t2, s2) {
  for (var r2 = e6.length, i2 = t2.length, a2 = 0, n2 = 0, o2 = []; a2 < r2 || n2 < i2; )
    a2 < r2 && n2 < i2 ? o2.push(s2(e6[a2], t2[n2]) <= 0 ? e6[a2++] : t2[n2++]) : o2.push(a2 < r2 ? e6[a2++] : t2[n2++]);
  return o2;
};
var Dt = pt;
var mt = F.match(/firefox\/(\d+)/i);
var ft = !!mt && +mt[1];
var yt = /MSIE|Trident/.test(F);
var At = F.match(/AppleWebKit\/(\d+)\./);
var Et = !!At && +At[1];
var Ct = [];
var xt = Ct.sort;
var Ft = o(function() {
  Ct.sort(void 0);
});
var gt = o(function() {
  Ct.sort(null);
});
var bt = !!(ut = []["sort"]) && o(function() {
  ut.call(null, ot || function() {
    throw 1;
  }, 1);
});
var Pt = !o(function() {
  if (w)
    return w < 70;
  if (!(ft && ft > 3)) {
    if (yt)
      return true;
    if (Et)
      return Et < 603;
    var e6, t2, s2, r2, i2 = "";
    for (e6 = 65; e6 < 76; e6++) {
      switch (t2 = String.fromCharCode(e6), e6) {
        case 66:
        case 69:
        case 70:
        case 72:
          s2 = 3;
          break;
        case 68:
        case 71:
          s2 = 4;
          break;
        default:
          s2 = 2;
      }
      for (r2 = 0; r2 < 47; r2++)
        Ct.push({ k: t2 + r2, v: s2 });
    }
    for (Ct.sort(function(e7, t3) {
      return t3.v - e7.v;
    }), r2 = 0; r2 < Ct.length; r2++)
      t2 = Ct[r2].k.charAt(0), i2.charAt(i2.length - 1) !== t2 && (i2 += t2);
    return i2 !== "DGBEFHACIJK";
  }
});
$e({ target: "Array", proto: true, forced: Ft || !gt || !bt || !Pt }, { sort: function(e6) {
  e6 !== void 0 && Ve(e6);
  var t2 = L(this);
  if (Pt)
    return e6 === void 0 ? xt.call(t2) : xt.call(t2, e6);
  var s2, r2, i2 = [], a2 = be(t2.length);
  for (r2 = 0; r2 < a2; r2++)
    r2 in t2 && i2.push(t2[r2]);
  for (s2 = (i2 = Dt(i2, function(e7) {
    return function(t3, s3) {
      return s3 === void 0 ? -1 : t3 === void 0 ? 1 : e7 !== void 0 ? +e7(t3, s3) || 0 : ht(t3) > ht(s3) ? 1 : -1;
    };
  }(e6))).length, r2 = 0; r2 < s2; )
    t2[r2] = i2[r2++];
  for (; r2 < a2; )
    delete t2[r2++];
  return t2;
} });
var Tt = {};
var wt = H("iterator");
var St = Array.prototype;
var Bt = {};
Bt[H("toStringTag")] = "z";
var Nt = String(Bt) === "[object z]";
var It = H("toStringTag");
var vt = D(function() {
  return arguments;
}()) == "Arguments";
var kt = Nt ? D : function(e6) {
  var t2, s2, r2;
  return e6 === void 0 ? "Undefined" : e6 === null ? "Null" : typeof (s2 = function(e7, t3) {
    try {
      return e7[t3];
    } catch (e8) {
    }
  }(t2 = Object(e6), It)) == "string" ? s2 : vt ? D(t2) : (r2 = D(t2)) == "Object" && typeof t2.callee == "function" ? "Arguments" : r2;
};
var Lt = H("iterator");
var Ot = function(e6) {
  if (e6 != null)
    return e6[Lt] || e6["@@iterator"] || Tt[kt(e6)];
};
var Mt = function(e6, t2, s2) {
  var r2, i2;
  Q(e6);
  try {
    if ((r2 = e6.return) === void 0) {
      if (t2 === "throw")
        throw s2;
      return s2;
    }
    r2 = r2.call(e6);
  } catch (e7) {
    i2 = true, r2 = e7;
  }
  if (t2 === "throw")
    throw s2;
  if (i2)
    throw r2;
  return Q(r2), s2;
};
var Rt = function(e6, t2) {
  this.stopped = e6, this.result = t2;
};
var jt = function(e6, t2, s2) {
  var r2, i2, a2, n2, o2, u2, h2, c2, p2 = s2 && s2.that, l2 = !(!s2 || !s2.AS_ENTRIES), d2 = !(!s2 || !s2.IS_ITERATOR), D2 = !(!s2 || !s2.INTERRUPTED), m2 = ze(t2, p2, 1 + l2 + D2), f2 = function(e7) {
    return r2 && Mt(r2, "normal", e7), new Rt(true, e7);
  }, y2 = function(e7) {
    return l2 ? (Q(e7), D2 ? m2(e7[0], e7[1], f2) : m2(e7[0], e7[1])) : D2 ? m2(e7, f2) : m2(e7);
  };
  if (d2)
    r2 = e6;
  else {
    if (typeof (i2 = Ot(e6)) != "function")
      throw TypeError("Target is not iterable");
    if ((c2 = i2) !== void 0 && (Tt.Array === c2 || St[wt] === c2)) {
      for (a2 = 0, n2 = be(e6.length); n2 > a2; a2++)
        if ((o2 = y2(e6[a2])) && o2 instanceof Rt)
          return o2;
      return new Rt(false);
    }
    r2 = function(e7, t3) {
      var s3 = arguments.length < 2 ? Ot(e7) : t3;
      if (typeof s3 != "function")
        throw TypeError(String(e7) + " is not iterable");
      return Q(s3.call(e7));
    }(e6, i2);
  }
  for (u2 = r2.next; !(h2 = u2.call(r2)).done; ) {
    try {
      o2 = y2(h2.value);
    } catch (e7) {
      Mt(r2, "throw", e7);
    }
    if (typeof o2 == "object" && o2 && o2 instanceof Rt)
      return o2;
  }
  return new Rt(false);
};
$e({ target: "Object", stat: true }, { fromEntries: function(e6) {
  var t2 = {};
  return jt(e6, function(e7, s2) {
    !function(e8, t3, s3) {
      var r2 = W(t3);
      r2 in e8 ? ee.f(e8, r2, l(0, s3)) : e8[r2] = s3;
    }(t2, e7, s2);
  }, { AS_ENTRIES: true }), t2;
} });
var _t = _t !== void 0 ? _t : typeof self != "undefined" ? self : typeof window != "undefined" ? window : {};
function Ut() {
  throw new Error("setTimeout has not been defined");
}
function qt() {
  throw new Error("clearTimeout has not been defined");
}
var $t = Ut;
var Ht = qt;
function Vt(e6) {
  if ($t === setTimeout)
    return setTimeout(e6, 0);
  if (($t === Ut || !$t) && setTimeout)
    return $t = setTimeout, setTimeout(e6, 0);
  try {
    return $t(e6, 0);
  } catch (t2) {
    try {
      return $t.call(null, e6, 0);
    } catch (t3) {
      return $t.call(this, e6, 0);
    }
  }
}
typeof _t.setTimeout == "function" && ($t = setTimeout), typeof _t.clearTimeout == "function" && (Ht = clearTimeout);
var zt;
var Wt = [];
var Gt = false;
var Kt = -1;
function Xt() {
  Gt && zt && (Gt = false, zt.length ? Wt = zt.concat(Wt) : Kt = -1, Wt.length && Jt());
}
function Jt() {
  if (!Gt) {
    var e6 = Vt(Xt);
    Gt = true;
    for (var t2 = Wt.length; t2; ) {
      for (zt = Wt, Wt = []; ++Kt < t2; )
        zt && zt[Kt].run();
      Kt = -1, t2 = Wt.length;
    }
    zt = null, Gt = false, function(e7) {
      if (Ht === clearTimeout)
        return clearTimeout(e7);
      if ((Ht === qt || !Ht) && clearTimeout)
        return Ht = clearTimeout, clearTimeout(e7);
      try {
        Ht(e7);
      } catch (t3) {
        try {
          return Ht.call(null, e7);
        } catch (t4) {
          return Ht.call(this, e7);
        }
      }
    }(e6);
  }
}
function Yt(e6, t2) {
  this.fun = e6, this.array = t2;
}
Yt.prototype.run = function() {
  this.fun.apply(null, this.array);
};
function Qt() {
}
var Zt = Qt;
var es = Qt;
var ts = Qt;
var ss = Qt;
var rs = Qt;
var is = Qt;
var as = Qt;
var ns = _t.performance || {};
var os = ns.now || ns.mozNow || ns.msNow || ns.oNow || ns.webkitNow || function() {
  return new Date().getTime();
};
var us = new Date();
var hs = { nextTick: function(e6) {
  var t2 = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var s2 = 1; s2 < arguments.length; s2++)
      t2[s2 - 1] = arguments[s2];
  Wt.push(new Yt(e6, t2)), Wt.length !== 1 || Gt || Vt(Jt);
}, title: "browser", browser: true, env: {}, argv: [], version: "", versions: {}, on: Zt, addListener: es, once: ts, off: ss, removeListener: rs, removeAllListeners: is, emit: as, binding: function(e6) {
  throw new Error("process.binding is not supported");
}, cwd: function() {
  return "/";
}, chdir: function(e6) {
  throw new Error("process.chdir is not supported");
}, umask: function() {
  return 0;
}, hrtime: function(e6) {
  var t2 = 1e-3 * os.call(ns), s2 = Math.floor(t2), r2 = Math.floor(t2 % 1 * 1e9);
  return e6 && (s2 -= e6[0], (r2 -= e6[1]) < 0 && (s2--, r2 += 1e9)), [s2, r2];
}, platform: "browser", release: {}, config: {}, uptime: function() {
  return (new Date() - us) / 1e3;
} };
var cs = typeof hs == "object" && hs.env && hs.env.NODE_DEBUG && /\bsemver\b/i.test(hs.env.NODE_DEBUG) ? (...e6) => console.error("SEMVER", ...e6) : () => {
};
var ps = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991, MAX_SAFE_COMPONENT_LENGTH: 16 };
var ls = s(function(e6, t2) {
  const { MAX_SAFE_COMPONENT_LENGTH: s2 } = ps, r2 = (t2 = e6.exports = {}).re = [], i2 = t2.src = [], a2 = t2.t = {};
  let n2 = 0;
  const o2 = (e7, t3, s3) => {
    const o3 = n2++;
    cs(o3, t3), a2[e7] = o3, i2[o3] = t3, r2[o3] = new RegExp(t3, s3 ? "g" : void 0);
  };
  o2("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o2("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o2("MAINVERSION", `(${i2[a2.NUMERICIDENTIFIER]})\\.(${i2[a2.NUMERICIDENTIFIER]})\\.(${i2[a2.NUMERICIDENTIFIER]})`), o2("MAINVERSIONLOOSE", `(${i2[a2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[a2.NUMERICIDENTIFIERLOOSE]})\\.(${i2[a2.NUMERICIDENTIFIERLOOSE]})`), o2("PRERELEASEIDENTIFIER", `(?:${i2[a2.NUMERICIDENTIFIER]}|${i2[a2.NONNUMERICIDENTIFIER]})`), o2("PRERELEASEIDENTIFIERLOOSE", `(?:${i2[a2.NUMERICIDENTIFIERLOOSE]}|${i2[a2.NONNUMERICIDENTIFIER]})`), o2("PRERELEASE", `(?:-(${i2[a2.PRERELEASEIDENTIFIER]}(?:\\.${i2[a2.PRERELEASEIDENTIFIER]})*))`), o2("PRERELEASELOOSE", `(?:-?(${i2[a2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${i2[a2.PRERELEASEIDENTIFIERLOOSE]})*))`), o2("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o2("BUILD", `(?:\\+(${i2[a2.BUILDIDENTIFIER]}(?:\\.${i2[a2.BUILDIDENTIFIER]})*))`), o2("FULLPLAIN", `v?${i2[a2.MAINVERSION]}${i2[a2.PRERELEASE]}?${i2[a2.BUILD]}?`), o2("FULL", `^${i2[a2.FULLPLAIN]}$`), o2("LOOSEPLAIN", `[v=\\s]*${i2[a2.MAINVERSIONLOOSE]}${i2[a2.PRERELEASELOOSE]}?${i2[a2.BUILD]}?`), o2("LOOSE", `^${i2[a2.LOOSEPLAIN]}$`), o2("GTLT", "((?:<|>)?=?)"), o2("XRANGEIDENTIFIERLOOSE", `${i2[a2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), o2("XRANGEIDENTIFIER", `${i2[a2.NUMERICIDENTIFIER]}|x|X|\\*`), o2("XRANGEPLAIN", `[v=\\s]*(${i2[a2.XRANGEIDENTIFIER]})(?:\\.(${i2[a2.XRANGEIDENTIFIER]})(?:\\.(${i2[a2.XRANGEIDENTIFIER]})(?:${i2[a2.PRERELEASE]})?${i2[a2.BUILD]}?)?)?`), o2("XRANGEPLAINLOOSE", `[v=\\s]*(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:\\.(${i2[a2.XRANGEIDENTIFIERLOOSE]})(?:${i2[a2.PRERELEASELOOSE]})?${i2[a2.BUILD]}?)?)?`), o2("XRANGE", `^${i2[a2.GTLT]}\\s*${i2[a2.XRANGEPLAIN]}$`), o2("XRANGELOOSE", `^${i2[a2.GTLT]}\\s*${i2[a2.XRANGEPLAINLOOSE]}$`), o2("COERCE", `(^|[^\\d])(\\d{1,${s2}})(?:\\.(\\d{1,${s2}}))?(?:\\.(\\d{1,${s2}}))?(?:$|[^\\d])`), o2("COERCERTL", i2[a2.COERCE], true), o2("LONETILDE", "(?:~>?)"), o2("TILDETRIM", `(\\s*)${i2[a2.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", o2("TILDE", `^${i2[a2.LONETILDE]}${i2[a2.XRANGEPLAIN]}$`), o2("TILDELOOSE", `^${i2[a2.LONETILDE]}${i2[a2.XRANGEPLAINLOOSE]}$`), o2("LONECARET", "(?:\\^)"), o2("CARETTRIM", `(\\s*)${i2[a2.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", o2("CARET", `^${i2[a2.LONECARET]}${i2[a2.XRANGEPLAIN]}$`), o2("CARETLOOSE", `^${i2[a2.LONECARET]}${i2[a2.XRANGEPLAINLOOSE]}$`), o2("COMPARATORLOOSE", `^${i2[a2.GTLT]}\\s*(${i2[a2.LOOSEPLAIN]})$|^$`), o2("COMPARATOR", `^${i2[a2.GTLT]}\\s*(${i2[a2.FULLPLAIN]})$|^$`), o2("COMPARATORTRIM", `(\\s*)${i2[a2.GTLT]}\\s*(${i2[a2.LOOSEPLAIN]}|${i2[a2.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", o2("HYPHENRANGE", `^\\s*(${i2[a2.XRANGEPLAIN]})\\s+-\\s+(${i2[a2.XRANGEPLAIN]})\\s*$`), o2("HYPHENRANGELOOSE", `^\\s*(${i2[a2.XRANGEPLAINLOOSE]})\\s+-\\s+(${i2[a2.XRANGEPLAINLOOSE]})\\s*$`), o2("STAR", "(<|>)?=?\\s*\\*"), o2("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), o2("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
});
var ds = ["includePrerelease", "loose", "rtl"];
var Ds = (e6) => e6 ? typeof e6 != "object" ? { loose: true } : ds.filter((t2) => e6[t2]).reduce((e7, t2) => (e7[t2] = true, e7), {}) : {};
var ms = /^[0-9]+$/;
var fs = (e6, t2) => {
  const s2 = ms.test(e6), r2 = ms.test(t2);
  return s2 && r2 && (e6 = +e6, t2 = +t2), e6 === t2 ? 0 : s2 && !r2 ? -1 : r2 && !s2 ? 1 : e6 < t2 ? -1 : 1;
};
var ys = { compareIdentifiers: fs, rcompareIdentifiers: (e6, t2) => fs(t2, e6) };
var { MAX_LENGTH: As, MAX_SAFE_INTEGER: Es } = ps;
var { re: Cs, t: xs } = ls;
var { compareIdentifiers: Fs } = ys;
var gs = class {
  constructor(e6, t2) {
    if (t2 = Ds(t2), e6 instanceof gs) {
      if (e6.loose === !!t2.loose && e6.includePrerelease === !!t2.includePrerelease)
        return e6;
      e6 = e6.version;
    } else if (typeof e6 != "string")
      throw new TypeError(`Invalid Version: ${e6}`);
    if (e6.length > As)
      throw new TypeError(`version is longer than ${As} characters`);
    cs("SemVer", e6, t2), this.options = t2, this.loose = !!t2.loose, this.includePrerelease = !!t2.includePrerelease;
    const s2 = e6.trim().match(t2.loose ? Cs[xs.LOOSE] : Cs[xs.FULL]);
    if (!s2)
      throw new TypeError(`Invalid Version: ${e6}`);
    if (this.raw = e6, this.major = +s2[1], this.minor = +s2[2], this.patch = +s2[3], this.major > Es || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > Es || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > Es || this.patch < 0)
      throw new TypeError("Invalid patch version");
    s2[4] ? this.prerelease = s2[4].split(".").map((e7) => {
      if (/^[0-9]+$/.test(e7)) {
        const t3 = +e7;
        if (t3 >= 0 && t3 < Es)
          return t3;
      }
      return e7;
    }) : this.prerelease = [], this.build = s2[5] ? s2[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e6) {
    if (cs("SemVer.compare", this.version, this.options, e6), !(e6 instanceof gs)) {
      if (typeof e6 == "string" && e6 === this.version)
        return 0;
      e6 = new gs(e6, this.options);
    }
    return e6.version === this.version ? 0 : this.compareMain(e6) || this.comparePre(e6);
  }
  compareMain(e6) {
    return e6 instanceof gs || (e6 = new gs(e6, this.options)), Fs(this.major, e6.major) || Fs(this.minor, e6.minor) || Fs(this.patch, e6.patch);
  }
  comparePre(e6) {
    if (e6 instanceof gs || (e6 = new gs(e6, this.options)), this.prerelease.length && !e6.prerelease.length)
      return -1;
    if (!this.prerelease.length && e6.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e6.prerelease.length)
      return 0;
    let t2 = 0;
    do {
      const s2 = this.prerelease[t2], r2 = e6.prerelease[t2];
      if (cs("prerelease compare", t2, s2, r2), s2 === void 0 && r2 === void 0)
        return 0;
      if (r2 === void 0)
        return 1;
      if (s2 === void 0)
        return -1;
      if (s2 !== r2)
        return Fs(s2, r2);
    } while (++t2);
  }
  compareBuild(e6) {
    e6 instanceof gs || (e6 = new gs(e6, this.options));
    let t2 = 0;
    do {
      const s2 = this.build[t2], r2 = e6.build[t2];
      if (cs("prerelease compare", t2, s2, r2), s2 === void 0 && r2 === void 0)
        return 0;
      if (r2 === void 0)
        return 1;
      if (s2 === void 0)
        return -1;
      if (s2 !== r2)
        return Fs(s2, r2);
    } while (++t2);
  }
  inc(e6, t2) {
    switch (e6) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t2);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t2);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", t2), this.inc("pre", t2);
        break;
      case "major":
        this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          let e7 = this.prerelease.length;
          for (; --e7 >= 0; )
            typeof this.prerelease[e7] == "number" && (this.prerelease[e7]++, e7 = -2);
          e7 === -1 && this.prerelease.push(0);
        }
        t2 && (this.prerelease[0] === t2 ? isNaN(this.prerelease[1]) && (this.prerelease = [t2, 0]) : this.prerelease = [t2, 0]);
        break;
      default:
        throw new Error(`invalid increment argument: ${e6}`);
    }
    return this.format(), this.raw = this.version, this;
  }
};
var bs = gs;
var Ps = (e6, t2, s2) => new bs(e6, s2).compare(new bs(t2, s2));
var Ts = (e6, t2, s2) => Ps(e6, t2, s2) < 0;
var ws = (e6, t2, s2) => Ps(e6, t2, s2) >= 0;
var Ss = s(function(e6, t2) {
  function s2() {
    for (var e7 = [], t3 = 0; t3 < arguments.length; t3++)
      e7[t3] = arguments[t3];
  }
  function r2() {
    return typeof WeakMap != "undefined" ? new WeakMap() : { add: s2, delete: s2, get: s2, set: s2, has: function(e7) {
      return false;
    } };
  }
  Object.defineProperty(t2, "__esModule", { value: true }), t2.outdent = void 0;
  var i2 = Object.prototype.hasOwnProperty, a2 = function(e7, t3) {
    return i2.call(e7, t3);
  };
  function n2(e7, t3) {
    for (var s3 in t3)
      a2(t3, s3) && (e7[s3] = t3[s3]);
    return e7;
  }
  var o2 = /^[ \t]*(?:\r\n|\r|\n)/, u2 = /(?:\r\n|\r|\n)[ \t]*$/, h2 = /^(?:[\r\n]|$)/, c2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, p2 = /^[ \t]*[\r\n][ \t\r\n]*$/;
  function l2(e7, t3, s3) {
    var r3 = 0, i3 = e7[0].match(c2);
    i3 && (r3 = i3[1].length);
    var a3 = new RegExp("(\\r\\n|\\r|\\n).{0," + r3 + "}", "g");
    t3 && (e7 = e7.slice(1));
    var n3 = s3.newline, h3 = s3.trimLeadingNewline, p3 = s3.trimTrailingNewline, l3 = typeof n3 == "string", d3 = e7.length;
    return e7.map(function(e8, t4) {
      return e8 = e8.replace(a3, "$1"), t4 === 0 && h3 && (e8 = e8.replace(o2, "")), t4 === d3 - 1 && p3 && (e8 = e8.replace(u2, "")), l3 && (e8 = e8.replace(/\r\n|\n|\r/g, function(e9) {
        return n3;
      })), e8;
    });
  }
  function d2(e7, t3) {
    for (var s3 = "", r3 = 0, i3 = e7.length; r3 < i3; r3++)
      s3 += e7[r3], r3 < i3 - 1 && (s3 += t3[r3]);
    return s3;
  }
  function D2(e7) {
    return a2(e7, "raw") && a2(e7, "length");
  }
  var m2 = function e7(t3) {
    var s3 = r2(), i3 = r2();
    return n2(function r3(a3) {
      for (var o3 = [], u3 = 1; u3 < arguments.length; u3++)
        o3[u3 - 1] = arguments[u3];
      if (D2(a3)) {
        var c3 = a3, f2 = (o3[0] === r3 || o3[0] === m2) && p2.test(c3[0]) && h2.test(c3[1]), y2 = f2 ? i3 : s3, A2 = y2.get(c3);
        if (A2 || (A2 = l2(c3, f2, t3), y2.set(c3, A2)), o3.length === 0)
          return A2[0];
        var E2 = d2(A2, f2 ? o3.slice(1) : o3);
        return E2;
      }
      return e7(n2(n2({}, t3), a3 || {}));
    }, { string: function(e8) {
      return l2([e8], false, t3)[0];
    } });
  }({ trimLeadingNewline: true, trimTrailingNewline: true });
  t2.outdent = m2, t2.default = m2;
  try {
    e6.exports = m2, Object.defineProperty(m2, "__esModule", { value: true }), m2.default = m2, m2.outdent = m2;
  } catch (e7) {
  }
});
var { outdent: Bs } = Ss;
var Ns = { cursorOffset: { since: "1.4.0", category: "Special", type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: Bs`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: "Editor" }, endOfLine: { since: "1.15.0", category: "Global", type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: Bs`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { since: "0.0.10", category: "Global", type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (e6) => typeof e6 == "string" || typeof e6 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e6) => typeof e6 == "string" || typeof e6 == "object", cliName: "plugin", cliCategory: "Config" }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: "Global", description: Bs`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (e6) => typeof e6 == "string" || typeof e6 == "object", cliName: "plugin-search-dir", cliCategory: "Config" }, printWidth: { since: "0.0.0", category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: "Special", type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Bs`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor" }, rangeStart: { since: "1.4.0", category: "Special", type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: Bs`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: "Editor" }, requirePragma: { since: "1.7.0", category: "Special", type: "boolean", default: false, description: Bs`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: "Global", type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
var Is = ["cliName", "cliCategory", "cliDescription"];
var vs = { compare: Ps, lt: Ts, gte: ws };
var ks = "2.4.1";
var Ls = { CATEGORY_CONFIG: "Config", CATEGORY_EDITOR: "Editor", CATEGORY_FORMAT: "Format", CATEGORY_OTHER: "Other", CATEGORY_OUTPUT: "Output", CATEGORY_GLOBAL: "Global", CATEGORY_SPECIAL: "Special", options: Ns }.options;
var Os = { getSupportInfo: function({ plugins: e6 = [], showUnreleased: t2 = false, showDeprecated: s2 = false, showInternal: r2 = false } = {}) {
  const i2 = ks.split("-", 1)[0], a2 = e6.flatMap((e7) => e7.languages || []).filter(h2), n2 = (o2 = Object.assign({}, ...e6.map(({ options: e7 }) => e7), Ls), u2 = "name", Object.entries(o2).map(([e7, t3]) => Object.assign({ [u2]: e7 }, t3))).filter((e7) => h2(e7) && c2(e7)).sort((e7, t3) => e7.name === t3.name ? 0 : e7.name < t3.name ? -1 : 1).map(function(e7) {
    if (r2)
      return e7;
    return nt(e7, Is);
  }).map((t3) => {
    t3 = Object.assign({}, t3), Array.isArray(t3.default) && (t3.default = t3.default.length === 1 ? t3.default[0].value : t3.default.filter(h2).sort((e7, t4) => vs.compare(t4.since, e7.since))[0].value), Array.isArray(t3.choices) && (t3.choices = t3.choices.filter((e7) => h2(e7) && c2(e7)), t3.name === "parser" && function(e7, t4, s4) {
      const r3 = new Set(e7.choices.map((e8) => e8.value));
      for (const i3 of t4)
        if (i3.parsers) {
          for (const t5 of i3.parsers)
            if (!r3.has(t5)) {
              r3.add(t5);
              const a3 = s4.find((e8) => e8.parsers && e8.parsers[t5]);
              let n3 = i3.name;
              a3 && a3.name && (n3 += ` (plugin: ${a3.name})`), e7.choices.push({ value: t5, description: n3 });
            }
        }
    }(t3, a2, e6));
    const s3 = Object.fromEntries(e6.filter((e7) => e7.defaultOptions && e7.defaultOptions[t3.name] !== void 0).map((e7) => [e7.name, e7.defaultOptions[t3.name]]));
    return Object.assign(Object.assign({}, t3), {}, { pluginDefaults: s3 });
  });
  var o2, u2;
  return { languages: a2, options: n2 };
  function h2(e7) {
    return t2 || !("since" in e7) || e7.since && vs.gte(i2, e7.since);
  }
  function c2(e7) {
    return s2 || !("deprecated" in e7) || e7.deprecated && vs.lt(i2, e7.deprecated);
  }
} };
var { getSupportInfo: Ms } = Os;
var Rs = /[^\x20-\x7F]/;
function js(e6) {
  return (t2, s2, r2) => {
    const i2 = r2 && r2.backwards;
    if (s2 === false)
      return false;
    const { length: a2 } = t2;
    let n2 = s2;
    for (; n2 >= 0 && n2 < a2; ) {
      const s3 = t2.charAt(n2);
      if (e6 instanceof RegExp) {
        if (!e6.test(s3))
          return n2;
      } else if (!e6.includes(s3))
        return n2;
      i2 ? n2-- : n2++;
    }
    return (n2 === -1 || n2 === a2) && n2;
  };
}
var _s = js(/\s/);
var Us = js(" 	");
var qs = js(",; 	");
var $s = js(/[^\n\r]/);
function Hs(e6, t2) {
  if (t2 === false)
    return false;
  if (e6.charAt(t2) === "/" && e6.charAt(t2 + 1) === "*") {
    for (let s2 = t2 + 2; s2 < e6.length; ++s2)
      if (e6.charAt(s2) === "*" && e6.charAt(s2 + 1) === "/")
        return s2 + 2;
  }
  return t2;
}
function Vs(e6, t2) {
  return t2 !== false && (e6.charAt(t2) === "/" && e6.charAt(t2 + 1) === "/" ? $s(e6, t2) : t2);
}
function zs(e6, t2, s2) {
  const r2 = s2 && s2.backwards;
  if (t2 === false)
    return false;
  const i2 = e6.charAt(t2);
  if (r2) {
    if (e6.charAt(t2 - 1) === "\r" && i2 === "\n")
      return t2 - 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 - 1;
  } else {
    if (i2 === "\r" && e6.charAt(t2 + 1) === "\n")
      return t2 + 2;
    if (i2 === "\n" || i2 === "\r" || i2 === "\u2028" || i2 === "\u2029")
      return t2 + 1;
  }
  return t2;
}
function Ws(e6, t2, s2 = {}) {
  const r2 = Us(e6, s2.backwards ? t2 - 1 : t2, s2);
  return r2 !== zs(e6, r2, s2);
}
function Gs(e6, t2) {
  let s2 = null, r2 = t2;
  for (; r2 !== s2; )
    s2 = r2, r2 = qs(e6, r2), r2 = Hs(e6, r2), r2 = Us(e6, r2);
  return r2 = Vs(e6, r2), r2 = zs(e6, r2), r2 !== false && Ws(e6, r2);
}
function Ks(e6, t2) {
  let s2 = null, r2 = t2;
  for (; r2 !== s2; )
    s2 = r2, r2 = Us(e6, r2), r2 = Hs(e6, r2), r2 = Vs(e6, r2), r2 = zs(e6, r2);
  return r2;
}
function Xs(e6, t2, s2) {
  return Ks(e6, s2(t2));
}
function Js(e6, t2, s2 = 0) {
  let r2 = 0;
  for (let i2 = s2; i2 < e6.length; ++i2)
    e6[i2] === "	" ? r2 = r2 + t2 - r2 % t2 : r2++;
  return r2;
}
function Ys(e6, t2) {
  const s2 = e6.slice(1, -1), r2 = { quote: '"', regex: /"/g }, i2 = { quote: "'", regex: /'/g }, a2 = t2 === "'" ? i2 : r2, n2 = a2 === i2 ? r2 : i2;
  let o2 = a2.quote;
  if (s2.includes(a2.quote) || s2.includes(n2.quote)) {
    o2 = (s2.match(a2.regex) || []).length > (s2.match(n2.regex) || []).length ? n2.quote : a2.quote;
  }
  return o2;
}
function Qs(e6, t2, s2) {
  const r2 = t2 === '"' ? "'" : '"', i2 = e6.replace(/\\(.)|(["'])/gs, (e7, i3, a2) => i3 === r2 ? i3 : a2 === t2 ? "\\" + a2 : a2 || (s2 && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(i3) ? i3 : "\\" + i3));
  return t2 + i2 + t2;
}
function Zs(e6, t2) {
  (e6.comments || (e6.comments = [])).push(t2), t2.printed = false, t2.nodeDescription = function(e7) {
    const t3 = e7.type || e7.kind || "(unknown type)";
    let s2 = String(e7.name || e7.id && (typeof e7.id == "object" ? e7.id.name : e7.id) || e7.key && (typeof e7.key == "object" ? e7.key.name : e7.key) || e7.value && (typeof e7.value == "object" ? "" : String(e7.value)) || e7.operator || "");
    s2.length > 20 && (s2 = s2.slice(0, 19) + "\u2026");
    return t3 + (s2 ? " " + s2 : "");
  }(e6);
}
var er;
var tr = { inferParserByLanguage: function(e6, t2) {
  const { languages: s2 } = Ms({ plugins: t2.plugins }), r2 = s2.find(({ name: t3 }) => t3.toLowerCase() === e6) || s2.find(({ aliases: t3 }) => Array.isArray(t3) && t3.includes(e6)) || s2.find(({ extensions: t3 }) => Array.isArray(t3) && t3.includes(`.${e6}`));
  return r2 && r2.parsers[0];
}, getStringWidth: function(e6) {
  return e6 ? Rs.test(e6) ? st(e6) : e6.length : 0;
}, getMaxContinuousCount: function(e6, t2) {
  const s2 = e6.match(new RegExp(`(${it(t2)})+`, "g"));
  return s2 === null ? 0 : s2.reduce((e7, s3) => Math.max(e7, s3.length / t2.length), 0);
}, getMinNotPresentContinuousCount: function(e6, t2) {
  const s2 = e6.match(new RegExp(`(${it(t2)})+`, "g"));
  if (s2 === null)
    return 0;
  const r2 = new Map();
  let i2 = 0;
  for (const e7 of s2) {
    const s3 = e7.length / t2.length;
    r2.set(s3, true), s3 > i2 && (i2 = s3);
  }
  for (let e7 = 1; e7 < i2; e7++)
    if (!r2.get(e7))
      return e7;
  return i2 + 1;
}, getPenultimate: (e6) => e6[e6.length - 2], getLast: at, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: Ks, getNextNonSpaceNonCommentCharacterIndex: Xs, getNextNonSpaceNonCommentCharacter: function(e6, t2, s2) {
  return e6.charAt(Xs(e6, t2, s2));
}, skip: js, skipWhitespace: _s, skipSpaces: Us, skipToLineEnd: qs, skipEverythingButNewLine: $s, skipInlineComment: Hs, skipTrailingComment: Vs, skipNewline: zs, isNextLineEmptyAfterIndex: Gs, isNextLineEmpty: function(e6, t2, s2) {
  return Gs(e6, s2(t2));
}, isPreviousLineEmpty: function(e6, t2, s2) {
  let r2 = s2(t2) - 1;
  return r2 = Us(e6, r2, { backwards: true }), r2 = zs(e6, r2, { backwards: true }), r2 = Us(e6, r2, { backwards: true }), r2 !== zs(e6, r2, { backwards: true });
}, hasNewline: Ws, hasNewlineInRange: function(e6, t2, s2) {
  for (let r2 = t2; r2 < s2; ++r2)
    if (e6.charAt(r2) === "\n")
      return true;
  return false;
}, hasSpaces: function(e6, t2, s2 = {}) {
  return Us(e6, s2.backwards ? t2 - 1 : t2, s2) !== t2;
}, getAlignmentSize: Js, getIndentSize: function(e6, t2) {
  const s2 = e6.lastIndexOf("\n");
  return s2 === -1 ? 0 : Js(e6.slice(s2 + 1).match(/^[\t ]*/)[0], t2);
}, getPreferredQuote: Ys, printString: function(e6, t2) {
  return Qs(e6.slice(1, -1), t2.parser === "json" || t2.parser === "json5" && t2.quoteProps === "preserve" && !t2.singleQuote ? '"' : t2.__isInHtmlAttribute ? "'" : Ys(e6, t2.singleQuote ? "'" : '"'), !(t2.parser === "css" || t2.parser === "less" || t2.parser === "scss" || t2.__embeddedInHtml));
}, printNumber: function(e6) {
  return e6.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
}, makeString: Qs, addLeadingComment: function(e6, t2) {
  t2.leading = true, t2.trailing = false, Zs(e6, t2);
}, addDanglingComment: function(e6, t2, s2) {
  t2.leading = false, t2.trailing = false, s2 && (t2.marker = s2), Zs(e6, t2);
}, addTrailingComment: function(e6, t2) {
  t2.leading = false, t2.trailing = true, Zs(e6, t2);
}, isFrontMatterNode: function(e6) {
  return e6 && e6.type === "front-matter";
}, getShebang: function(e6) {
  if (!e6.startsWith("#!"))
    return "";
  const t2 = e6.indexOf("\n");
  return t2 === -1 ? e6 : e6.slice(0, t2);
}, isNonEmptyArray: function(e6) {
  return Array.isArray(e6) && e6.length > 0;
}, createGroupIdMapper: function(e6) {
  const t2 = new WeakMap();
  return function(s2) {
    return t2.has(s2) || t2.set(s2, Symbol(e6)), t2.get(s2);
  };
} };
function sr() {
  if (er === void 0) {
    var e6 = new ArrayBuffer(2), t2 = new Uint8Array(e6), s2 = new Uint16Array(e6);
    if (t2[0] = 1, t2[1] = 2, s2[0] === 258)
      er = "BE";
    else {
      if (s2[0] !== 513)
        throw new Error("unable to figure out endianess");
      er = "LE";
    }
  }
  return er;
}
function rr() {
  return _t.location !== void 0 ? _t.location.hostname : "";
}
function ir() {
  return [];
}
function ar() {
  return 0;
}
function nr() {
  return Number.MAX_VALUE;
}
function or() {
  return Number.MAX_VALUE;
}
function ur() {
  return [];
}
function hr() {
  return "Browser";
}
function cr() {
  return _t.navigator !== void 0 ? _t.navigator.appVersion : "";
}
function pr() {
}
function lr() {
}
function dr() {
  return "javascript";
}
function Dr() {
  return "browser";
}
function mr() {
  return "/tmp";
}
var fr = mr;
var yr = { EOL: "\n", arch: dr, platform: Dr, tmpdir: fr, tmpDir: mr, networkInterfaces: pr, getNetworkInterfaces: lr, release: cr, type: hr, cpus: ur, totalmem: or, freemem: nr, uptime: ar, loadavg: ir, hostname: rr, endianness: sr };
var Ar = Object.freeze({ __proto__: null, endianness: sr, hostname: rr, loadavg: ir, uptime: ar, freemem: nr, totalmem: or, cpus: ur, type: hr, release: cr, networkInterfaces: pr, getNetworkInterfaces: lr, arch: dr, platform: Dr, tmpDir: mr, tmpdir: fr, EOL: "\n", default: yr });
var Er = (e6) => {
  if (typeof e6 != "string")
    throw new TypeError("Expected a string");
  const t2 = e6.match(/(?:\r?\n)/g) || [];
  if (t2.length === 0)
    return;
  const s2 = t2.filter((e7) => e7 === "\r\n").length;
  return s2 > t2.length - s2 ? "\r\n" : "\n";
};
var Cr = Er;
Cr.graceful = (e6) => typeof e6 == "string" && Er(e6) || "\n";
var xr = t(Ar);
var Fr = function(e6) {
  const t2 = e6.match(Ir);
  return t2 ? t2[0].trimLeft() : "";
};
var gr = function(e6) {
  const t2 = e6.match(Ir);
  return t2 && t2[0] ? e6.substring(t2[0].length) : e6;
};
var br = function(e6) {
  return jr(e6).pragmas;
};
var Pr = jr;
var Tr = function({ comments: e6 = "", pragmas: t2 = {} }) {
  const s2 = (0, Sr().default)(e6) || wr().EOL, r2 = " *", i2 = Object.keys(t2), a2 = i2.map((e7) => _r(e7, t2[e7])).reduce((e7, t3) => e7.concat(t3), []).map((e7) => " * " + e7 + s2).join("");
  if (!e6) {
    if (i2.length === 0)
      return "";
    if (i2.length === 1 && !Array.isArray(t2[i2[0]])) {
      const e7 = t2[i2[0]];
      return `/** ${_r(i2[0], e7)[0]} */`;
    }
  }
  const n2 = e6.split(s2).map((e7) => ` * ${e7}`).join(s2) + s2;
  return "/**" + s2 + (e6 ? n2 : "") + (e6 && i2.length ? r2 + s2 : "") + a2 + " */";
};
function wr() {
  const e6 = xr;
  return wr = function() {
    return e6;
  }, e6;
}
function Sr() {
  const e6 = (t2 = Cr) && t2.__esModule ? t2 : { default: t2 };
  var t2;
  return Sr = function() {
    return e6;
  }, e6;
}
var Br = /\*\/$/;
var Nr = /^\/\*\*/;
var Ir = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/;
var vr = /(^|\s+)\/\/([^\r\n]*)/g;
var kr = /^(\r?\n)+/;
var Lr = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g;
var Or = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g;
var Mr = /(\r?\n|^) *\* ?/g;
var Rr = [];
function jr(e6) {
  const t2 = (0, Sr().default)(e6) || wr().EOL;
  e6 = e6.replace(Nr, "").replace(Br, "").replace(Mr, "$1");
  let s2 = "";
  for (; s2 !== e6; )
    s2 = e6, e6 = e6.replace(Lr, `${t2}$1 $2${t2}`);
  e6 = e6.replace(kr, "").trimRight();
  const r2 = Object.create(null), i2 = e6.replace(Or, "").replace(kr, "").trimRight();
  let a2;
  for (; a2 = Or.exec(e6); ) {
    const e7 = a2[2].replace(vr, "");
    typeof r2[a2[1]] == "string" || Array.isArray(r2[a2[1]]) ? r2[a2[1]] = Rr.concat(r2[a2[1]], e7) : r2[a2[1]] = e7;
  }
  return { comments: i2, pragmas: r2 };
}
function _r(e6, t2) {
  return Rr.concat(t2).map((t3) => `@${e6} ${t3}`.trim());
}
var Ur = Object.defineProperty({ extract: Fr, strip: gr, parse: br, parseWithComments: Pr, print: Tr }, "__esModule", { value: true });
var qr = { guessEndOfLine: function(e6) {
  const t2 = e6.indexOf("\r");
  return t2 >= 0 ? e6.charAt(t2 + 1) === "\n" ? "crlf" : "cr" : "lf";
}, convertEndOfLineToChars: function(e6) {
  switch (e6) {
    case "cr":
      return "\r";
    case "crlf":
      return "\r\n";
    default:
      return "\n";
  }
}, countEndOfLineChars: function(e6, t2) {
  let s2;
  if (t2 === "\n")
    s2 = /\n/g;
  else if (t2 === "\r")
    s2 = /\r/g;
  else {
    if (t2 !== "\r\n")
      throw new Error(`Unexpected "eol" ${JSON.stringify(t2)}.`);
    s2 = /\r\n/g;
  }
  const r2 = e6.match(s2);
  return r2 ? r2.length : 0;
}, normalizeEndOfLine: function(e6) {
  return e6.replace(/\r\n?/g, "\n");
} };
var { parseWithComments: $r, strip: Hr, extract: Vr, print: zr } = Ur;
var { getShebang: Wr } = tr;
var { normalizeEndOfLine: Gr } = qr;
function Kr(e6) {
  const t2 = Wr(e6);
  t2 && (e6 = e6.slice(t2.length + 1));
  const s2 = Vr(e6), { pragmas: r2, comments: i2 } = $r(s2);
  return { shebang: t2, text: e6, pragmas: r2, comments: i2 };
}
var Xr = { hasPragma: function(e6) {
  const t2 = Object.keys(Kr(e6).pragmas);
  return t2.includes("prettier") || t2.includes("format");
}, insertPragma: function(e6) {
  const { shebang: t2, text: s2, pragmas: r2, comments: i2 } = Kr(e6), a2 = Hr(s2), n2 = zr({ pragmas: Object.assign({ format: "" }, r2), comments: i2.trimStart() });
  return (t2 ? `${t2}
` : "") + Gr(n2) + (a2.startsWith("\n") ? "\n" : "\n\n") + a2;
} };
var { isNonEmptyArray: Jr } = tr;
function Yr(e6, t2) {
  const { ignoreDecorators: s2 } = t2 || {};
  if (!s2) {
    const t3 = e6.declaration && e6.declaration.decorators || e6.decorators;
    if (Jr(t3))
      return Yr(t3[0]);
  }
  return e6.range ? e6.range[0] : e6.start;
}
function Qr(e6) {
  return e6.range ? e6.range[1] : e6.end;
}
function Zr(e6, t2) {
  return Yr(e6) === Yr(t2);
}
var ei = { locStart: Yr, locEnd: Qr, hasSameLocStart: Zr, hasSameLoc: function(e6, t2) {
  return Zr(e6, t2) && function(e7, t3) {
    return Qr(e7) === Qr(t3);
  }(e6, t2);
} };
var { hasPragma: ti } = Xr;
var { locStart: si, locEnd: ri } = ei;
var ii = function(e6) {
  return e6 = typeof e6 == "function" ? { parse: e6 } : e6, Object.assign({ astFormat: "estree", hasPragma: ti, locStart: si, locEnd: ri }, e6);
};
var ai = function(e6, t2) {
  const s2 = new SyntaxError(e6 + " (" + t2.start.line + ":" + t2.start.column + ")");
  return s2.loc = t2, s2;
};
var ni = function(e6) {
  const { message: t2, loc: s2 } = e6;
  return ai(t2.replace(/ \(.*\)/, ""), { start: { line: s2 ? s2.line : 0, column: s2 ? s2.column + 1 : 0 } });
};
var oi = s(function(e6) {
  !function() {
    function t2(e7) {
      if (e7 == null)
        return false;
      switch (e7.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return true;
      }
      return false;
    }
    function s2(e7) {
      switch (e7.type) {
        case "IfStatement":
          return e7.alternate != null ? e7.alternate : e7.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return e7.body;
      }
      return null;
    }
    e6.exports = { isExpression: function(e7) {
      if (e7 == null)
        return false;
      switch (e7.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return true;
      }
      return false;
    }, isStatement: t2, isIterationStatement: function(e7) {
      if (e7 == null)
        return false;
      switch (e7.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return true;
      }
      return false;
    }, isSourceElement: function(e7) {
      return t2(e7) || e7 != null && e7.type === "FunctionDeclaration";
    }, isProblematicIfStatement: function(e7) {
      var t3;
      if (e7.type !== "IfStatement")
        return false;
      if (e7.alternate == null)
        return false;
      t3 = e7.consequent;
      do {
        if (t3.type === "IfStatement" && t3.alternate == null)
          return true;
        t3 = s2(t3);
      } while (t3);
      return false;
    }, trailingStatement: s2 };
  }();
});
var ui = s(function(e6) {
  !function() {
    var t2, s2, r2, i2, a2, n2;
    function o2(e7) {
      return e7 <= 65535 ? String.fromCharCode(e7) : String.fromCharCode(Math.floor((e7 - 65536) / 1024) + 55296) + String.fromCharCode((e7 - 65536) % 1024 + 56320);
    }
    for (s2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t2 = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ }, r2 = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279], i2 = new Array(128), n2 = 0; n2 < 128; ++n2)
      i2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || n2 === 36 || n2 === 95;
    for (a2 = new Array(128), n2 = 0; n2 < 128; ++n2)
      a2[n2] = n2 >= 97 && n2 <= 122 || n2 >= 65 && n2 <= 90 || n2 >= 48 && n2 <= 57 || n2 === 36 || n2 === 95;
    e6.exports = { isDecimalDigit: function(e7) {
      return 48 <= e7 && e7 <= 57;
    }, isHexDigit: function(e7) {
      return 48 <= e7 && e7 <= 57 || 97 <= e7 && e7 <= 102 || 65 <= e7 && e7 <= 70;
    }, isOctalDigit: function(e7) {
      return e7 >= 48 && e7 <= 55;
    }, isWhiteSpace: function(e7) {
      return e7 === 32 || e7 === 9 || e7 === 11 || e7 === 12 || e7 === 160 || e7 >= 5760 && r2.indexOf(e7) >= 0;
    }, isLineTerminator: function(e7) {
      return e7 === 10 || e7 === 13 || e7 === 8232 || e7 === 8233;
    }, isIdentifierStartES5: function(e7) {
      return e7 < 128 ? i2[e7] : s2.NonAsciiIdentifierStart.test(o2(e7));
    }, isIdentifierPartES5: function(e7) {
      return e7 < 128 ? a2[e7] : s2.NonAsciiIdentifierPart.test(o2(e7));
    }, isIdentifierStartES6: function(e7) {
      return e7 < 128 ? i2[e7] : t2.NonAsciiIdentifierStart.test(o2(e7));
    }, isIdentifierPartES6: function(e7) {
      return e7 < 128 ? a2[e7] : t2.NonAsciiIdentifierPart.test(o2(e7));
    } };
  }();
});
var hi = s(function(e6) {
  !function() {
    var t2 = ui;
    function s2(e7, t3) {
      return !(!t3 && e7 === "yield") && r2(e7, t3);
    }
    function r2(e7, t3) {
      if (t3 && function(e8) {
        switch (e8) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }(e7))
        return true;
      switch (e7.length) {
        case 2:
          return e7 === "if" || e7 === "in" || e7 === "do";
        case 3:
          return e7 === "var" || e7 === "for" || e7 === "new" || e7 === "try";
        case 4:
          return e7 === "this" || e7 === "else" || e7 === "case" || e7 === "void" || e7 === "with" || e7 === "enum";
        case 5:
          return e7 === "while" || e7 === "break" || e7 === "catch" || e7 === "throw" || e7 === "const" || e7 === "yield" || e7 === "class" || e7 === "super";
        case 6:
          return e7 === "return" || e7 === "typeof" || e7 === "delete" || e7 === "switch" || e7 === "export" || e7 === "import";
        case 7:
          return e7 === "default" || e7 === "finally" || e7 === "extends";
        case 8:
          return e7 === "function" || e7 === "continue" || e7 === "debugger";
        case 10:
          return e7 === "instanceof";
        default:
          return false;
      }
    }
    function i2(e7, t3) {
      return e7 === "null" || e7 === "true" || e7 === "false" || s2(e7, t3);
    }
    function a2(e7, t3) {
      return e7 === "null" || e7 === "true" || e7 === "false" || r2(e7, t3);
    }
    function n2(e7) {
      var s3, r3, i3;
      if (e7.length === 0)
        return false;
      if (i3 = e7.charCodeAt(0), !t2.isIdentifierStartES5(i3))
        return false;
      for (s3 = 1, r3 = e7.length; s3 < r3; ++s3)
        if (i3 = e7.charCodeAt(s3), !t2.isIdentifierPartES5(i3))
          return false;
      return true;
    }
    function o2(e7) {
      var s3, r3, i3, a3, n3;
      if (e7.length === 0)
        return false;
      for (n3 = t2.isIdentifierStartES6, s3 = 0, r3 = e7.length; s3 < r3; ++s3) {
        if (55296 <= (i3 = e7.charCodeAt(s3)) && i3 <= 56319) {
          if (++s3 >= r3)
            return false;
          if (!(56320 <= (a3 = e7.charCodeAt(s3)) && a3 <= 57343))
            return false;
          i3 = 1024 * (i3 - 55296) + (a3 - 56320) + 65536;
        }
        if (!n3(i3))
          return false;
        n3 = t2.isIdentifierPartES6;
      }
      return true;
    }
    e6.exports = { isKeywordES5: s2, isKeywordES6: r2, isReservedWordES5: i2, isReservedWordES6: a2, isRestrictedWord: function(e7) {
      return e7 === "eval" || e7 === "arguments";
    }, isIdentifierNameES5: n2, isIdentifierNameES6: o2, isIdentifierES5: function(e7, t3) {
      return n2(e7) && !i2(e7, t3);
    }, isIdentifierES6: function(e7, t3) {
      return o2(e7) && !a2(e7, t3);
    } };
  }();
});
var ci = s(function(e6, t2) {
  t2.ast = oi, t2.code = ui, t2.keyword = hi;
}).keyword.isIdentifierNameES5;
var { getLast: pi, hasNewline: li, skipWhitespace: di, isNonEmptyArray: Di, isNextLineEmptyAfterIndex: mi, getStringWidth: fi } = tr;
var { locStart: yi, locEnd: Ai, hasSameLocStart: Ei } = ei;
var Ci = new RegExp("^(?:(?=.)\\s)*:");
var xi = new RegExp("^(?:(?=.)\\s)*::");
function Fi(e6) {
  return e6.type === "Block" || e6.type === "CommentBlock" || e6.type === "MultiLine";
}
function gi(e6) {
  return e6.type === "Line" || e6.type === "CommentLine" || e6.type === "SingleLine" || e6.type === "HashbangComment" || e6.type === "HTMLOpen" || e6.type === "HTMLClose";
}
var bi = new Set(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
function Pi(e6) {
  return e6 && bi.has(e6.type);
}
function Ti(e6) {
  return e6.type === "NumericLiteral" || e6.type === "Literal" && typeof e6.value == "number";
}
function wi(e6) {
  return e6.type === "StringLiteral" || e6.type === "Literal" && typeof e6.value == "string";
}
function Si(e6) {
  return e6.type === "FunctionExpression" || e6.type === "ArrowFunctionExpression";
}
function Bi(e6) {
  return Mi(e6) && e6.callee.type === "Identifier" && (e6.callee.name === "async" || e6.callee.name === "inject" || e6.callee.name === "fakeAsync");
}
function Ni(e6) {
  return e6.type === "JSXElement" || e6.type === "JSXFragment";
}
function Ii(e6) {
  return e6.kind === "get" || e6.kind === "set";
}
function vi(e6) {
  return Ii(e6) || Ei(e6, e6.value);
}
var ki = new Set(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
var Li = new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
var Oi = /^(?:skip|[fx]?(?:it|describe|test))$/;
function Mi(e6) {
  return e6 && (e6.type === "CallExpression" || e6.type === "OptionalCallExpression");
}
function Ri(e6) {
  return e6 && (e6.type === "MemberExpression" || e6.type === "OptionalMemberExpression");
}
function ji(e6) {
  return /^(?:\d+|\d+\.\d+)$/.test(e6);
}
function _i(e6) {
  return e6.quasis.some((e7) => e7.value.raw.includes("\n"));
}
function Ui(e6) {
  return e6.extra ? e6.extra.raw : e6.raw;
}
var qi = { "==": true, "!=": true, "===": true, "!==": true };
var $i = { "*": true, "/": true, "%": true };
var Hi = { ">>": true, ">>>": true, "<<": true };
var Vi = {};
for (const [e6, t2] of [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].entries())
  for (const s2 of t2)
    Vi[s2] = e6;
function zi(e6) {
  return Vi[e6];
}
var Wi = new WeakMap();
function Gi(e6) {
  if (Wi.has(e6))
    return Wi.get(e6);
  const t2 = [];
  return e6.this && t2.push(e6.this), Array.isArray(e6.parameters) ? t2.push(...e6.parameters) : Array.isArray(e6.params) && t2.push(...e6.params), e6.rest && t2.push(e6.rest), Wi.set(e6, t2), t2;
}
var Ki = new WeakMap();
function Xi(e6) {
  if (Ki.has(e6))
    return Ki.get(e6);
  let t2 = e6.arguments;
  return e6.type === "ImportExpression" && (t2 = [e6.source], e6.attributes && t2.push(e6.attributes)), Ki.set(e6, t2), t2;
}
function Ji(e6) {
  return e6.value.trim() === "prettier-ignore" && !e6.unignore;
}
function Yi(e6) {
  return e6 && (e6.prettierIgnore || ea(e6, Qi.PrettierIgnore));
}
var Qi = { Leading: 2, Trailing: 4, Dangling: 8, Block: 16, Line: 32, PrettierIgnore: 64, First: 128, Last: 256 };
var Zi = (e6, t2) => {
  if (typeof e6 == "function" && (t2 = e6, e6 = 0), e6 || t2)
    return (s2, r2, i2) => !(e6 & Qi.Leading && !s2.leading || e6 & Qi.Trailing && !s2.trailing || e6 & Qi.Dangling && (s2.leading || s2.trailing) || e6 & Qi.Block && !Fi(s2) || e6 & Qi.Line && !gi(s2) || e6 & Qi.First && r2 !== 0 || e6 & Qi.Last && r2 !== i2.length - 1 || e6 & Qi.PrettierIgnore && !Ji(s2) || t2 && !t2(s2));
};
function ea(e6, t2, s2) {
  if (!e6 || !Di(e6.comments))
    return false;
  const r2 = Zi(t2, s2);
  return !r2 || e6.comments.some(r2);
}
function ta(e6, t2, s2) {
  if (!e6 || !Array.isArray(e6.comments))
    return [];
  const r2 = Zi(t2, s2);
  return r2 ? e6.comments.filter(r2) : e6.comments;
}
function sa(e6) {
  return Mi(e6) || e6.type === "NewExpression" || e6.type === "ImportExpression";
}
var ra = { getFunctionParameters: Gi, iterateFunctionParametersPath: function(e6, t2) {
  const s2 = e6.getValue();
  let r2 = 0;
  const i2 = (e7) => t2(e7, r2++);
  s2.this && e6.call(i2, "this"), Array.isArray(s2.parameters) ? e6.each(i2, "parameters") : Array.isArray(s2.params) && e6.each(i2, "params"), s2.rest && e6.call(i2, "rest");
}, getCallArguments: Xi, iterateCallArgumentsPath: function(e6, t2) {
  const s2 = e6.getValue();
  s2.type === "ImportExpression" ? (e6.call((e7) => t2(e7, 0), "source"), s2.attributes && e6.call((e7) => t2(e7, 1), "attributes")) : e6.each(t2, "arguments");
}, hasRestParameter: function(e6) {
  if (e6.rest)
    return true;
  const t2 = Gi(e6);
  return t2.length > 0 && pi(t2).type === "RestElement";
}, getLeftSide: function(e6) {
  return e6.expressions ? e6.expressions[0] : e6.left || e6.test || e6.callee || e6.object || e6.tag || e6.argument || e6.expression;
}, getLeftSidePathName: function(e6, t2) {
  if (t2.expressions)
    return ["expressions", 0];
  if (t2.left)
    return ["left"];
  if (t2.test)
    return ["test"];
  if (t2.object)
    return ["object"];
  if (t2.callee)
    return ["callee"];
  if (t2.tag)
    return ["tag"];
  if (t2.argument)
    return ["argument"];
  if (t2.expression)
    return ["expression"];
  throw new Error("Unexpected node has no left side.");
}, getParentExportDeclaration: function(e6) {
  const t2 = e6.getParentNode();
  return e6.getName() === "declaration" && Pi(t2) ? t2 : null;
}, getTypeScriptMappedTypeModifier: function(e6, t2) {
  return e6 === "+" ? "+" + t2 : e6 === "-" ? "-" + t2 : t2;
}, hasFlowAnnotationComment: function(e6) {
  return Di(e6) && Fi(e6[0]) && xi.test(e6[0].value);
}, hasFlowShorthandAnnotationComment: function(e6) {
  return e6.extra && e6.extra.parenthesized && Di(e6.trailingComments) && Fi(e6.trailingComments[0]) && Ci.test(e6.trailingComments[0].value);
}, hasLeadingOwnLineComment: function(e6, t2) {
  return Ni(t2) ? Yi(t2) : ea(t2, Qi.Leading, (t3) => li(e6, Ai(t3)));
}, hasNakedLeftSide: function(e6) {
  return e6.type === "AssignmentExpression" || e6.type === "BinaryExpression" || e6.type === "LogicalExpression" || e6.type === "NGPipeExpression" || e6.type === "ConditionalExpression" || Mi(e6) || Ri(e6) || e6.type === "SequenceExpression" || e6.type === "TaggedTemplateExpression" || e6.type === "BindExpression" || e6.type === "UpdateExpression" && !e6.prefix || e6.type === "TSAsExpression" || e6.type === "TSNonNullExpression";
}, hasNode: function e2(t2, s2) {
  if (!t2 || typeof t2 != "object")
    return false;
  if (Array.isArray(t2))
    return t2.some((t3) => e2(t3, s2));
  const r2 = s2(t2);
  return typeof r2 == "boolean" ? r2 : Object.values(t2).some((t3) => e2(t3, s2));
}, hasIgnoreComment: function(e6) {
  return Yi(e6.getValue());
}, hasNodeIgnoreComment: Yi, identity: function(e6) {
  return e6;
}, isBinaryish: function(e6) {
  return ki.has(e6.type);
}, isBlockComment: Fi, isCallLikeExpression: sa, isLineComment: gi, isPrettierIgnoreComment: Ji, isCallExpression: Mi, isMemberExpression: Ri, isExportDeclaration: Pi, isFlowAnnotationComment: function(e6, t2) {
  const s2 = yi(t2), r2 = di(e6, Ai(t2));
  return r2 !== false && e6.slice(s2, s2 + 2) === "/*" && e6.slice(r2, r2 + 2) === "*/";
}, isFunctionCompositionArgs: function(e6) {
  if (e6.length <= 1)
    return false;
  let t2 = 0;
  for (const s2 of e6)
    if (Si(s2)) {
      if (t2 += 1, t2 > 1)
        return true;
    } else if (Mi(s2)) {
      for (const e7 of s2.arguments)
        if (Si(e7))
          return true;
    }
  return false;
}, isFunctionNotation: vi, isFunctionOrArrowExpression: Si, isGetterOrSetter: Ii, isJestEachTemplateLiteral: function(e6, t2) {
  const s2 = /^[fx]?(?:describe|it|test)$/;
  return t2.type === "TaggedTemplateExpression" && t2.quasi === e6 && t2.tag.type === "MemberExpression" && t2.tag.property.type === "Identifier" && t2.tag.property.name === "each" && (t2.tag.object.type === "Identifier" && s2.test(t2.tag.object.name) || t2.tag.object.type === "MemberExpression" && t2.tag.object.property.type === "Identifier" && (t2.tag.object.property.name === "only" || t2.tag.object.property.name === "skip") && t2.tag.object.object.type === "Identifier" && s2.test(t2.tag.object.object.name));
}, isJsxNode: Ni, isLiteral: function(e6) {
  return e6.type === "BooleanLiteral" || e6.type === "DirectiveLiteral" || e6.type === "Literal" || e6.type === "NullLiteral" || e6.type === "NumericLiteral" || e6.type === "BigIntLiteral" || e6.type === "DecimalLiteral" || e6.type === "RegExpLiteral" || e6.type === "StringLiteral" || e6.type === "TemplateLiteral" || e6.type === "TSTypeLiteral" || e6.type === "JSXText";
}, isLongCurriedCallExpression: function(e6) {
  const t2 = e6.getValue(), s2 = e6.getParentNode();
  return Mi(t2) && Mi(s2) && s2.callee === t2 && t2.arguments.length > s2.arguments.length && s2.arguments.length > 0;
}, isSimpleCallArgument: function e3(t2, s2) {
  if (s2 >= 2)
    return false;
  const r2 = (t3) => e3(t3, s2 + 1), i2 = t2.type === "Literal" && "regex" in t2 && t2.regex.pattern || t2.type === "RegExpLiteral" && t2.pattern;
  return !(i2 && fi(i2) > 5) && (t2.type === "Literal" || t2.type === "BigIntLiteral" || t2.type === "DecimalLiteral" || t2.type === "BooleanLiteral" || t2.type === "NullLiteral" || t2.type === "NumericLiteral" || t2.type === "RegExpLiteral" || t2.type === "StringLiteral" || t2.type === "Identifier" || t2.type === "ThisExpression" || t2.type === "Super" || t2.type === "PrivateName" || t2.type === "PrivateIdentifier" || t2.type === "ArgumentPlaceholder" || t2.type === "Import" || (t2.type === "TemplateLiteral" ? t2.quasis.every((e6) => !e6.value.raw.includes("\n")) && t2.expressions.every(r2) : t2.type === "ObjectExpression" ? t2.properties.every((e6) => !e6.computed && (e6.shorthand || e6.value && r2(e6.value))) : t2.type === "ArrayExpression" ? t2.elements.every((e6) => e6 === null || r2(e6)) : sa(t2) ? (t2.type === "ImportExpression" || e3(t2.callee, s2)) && Xi(t2).every(r2) : Ri(t2) ? e3(t2.object, s2) && e3(t2.property, s2) : t2.type !== "UnaryExpression" || t2.operator !== "!" && t2.operator !== "-" ? t2.type === "TSNonNullExpression" && e3(t2.expression, s2) : e3(t2.argument, s2)));
}, isMemberish: function(e6) {
  return Ri(e6) || e6.type === "BindExpression" && Boolean(e6.object);
}, isNumericLiteral: Ti, isSignedNumericLiteral: function(e6) {
  return e6.type === "UnaryExpression" && (e6.operator === "+" || e6.operator === "-") && Ti(e6.argument);
}, isObjectProperty: function(e6) {
  return e6 && (e6.type === "ObjectProperty" || e6.type === "Property" && !e6.method && e6.kind === "init");
}, isObjectType: function(e6) {
  return e6.type === "ObjectTypeAnnotation" || e6.type === "TSTypeLiteral" || e6.type === "TSMappedType";
}, isObjectTypePropertyAFunction: function(e6) {
  return !(e6.type !== "ObjectTypeProperty" && e6.type !== "ObjectTypeInternalSlot" || e6.value.type !== "FunctionTypeAnnotation" || e6.static || vi(e6));
}, isSimpleType: function(e6) {
  return !!e6 && (!(e6.type !== "GenericTypeAnnotation" && e6.type !== "TSTypeReference" || e6.typeParameters) || !!Li.has(e6.type));
}, isSimpleNumber: ji, isSimpleTemplateLiteral: function(e6) {
  let t2 = "expressions";
  e6.type === "TSTemplateLiteralType" && (t2 = "types");
  const s2 = e6[t2];
  return s2.length !== 0 && s2.every((e7) => {
    if (ea(e7))
      return false;
    if (e7.type === "Identifier" || e7.type === "ThisExpression")
      return true;
    if (Ri(e7)) {
      let t3 = e7;
      for (; Ri(t3); ) {
        if (t3.property.type !== "Identifier" && t3.property.type !== "Literal" && t3.property.type !== "StringLiteral" && t3.property.type !== "NumericLiteral")
          return false;
        if (t3 = t3.object, ea(t3))
          return false;
      }
      return t3.type === "Identifier" || t3.type === "ThisExpression";
    }
    return false;
  });
}, isStringLiteral: wi, isStringPropSafeToUnquote: function(e6, t2) {
  return t2.parser !== "json" && wi(e6.key) && Ui(e6.key).slice(1, -1) === e6.key.value && (ci(e6.key.value) && !((t2.parser === "typescript" || t2.parser === "babel-ts") && e6.type === "ClassProperty") || ji(e6.key.value) && String(Number(e6.key.value)) === e6.key.value && (t2.parser === "babel" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree"));
}, isTemplateOnItsOwnLine: function(e6, t2) {
  return (e6.type === "TemplateLiteral" && _i(e6) || e6.type === "TaggedTemplateExpression" && _i(e6.quasi)) && !li(t2, yi(e6), { backwards: true });
}, isTestCall: function e4(t2, s2) {
  if (t2.type !== "CallExpression")
    return false;
  if (t2.arguments.length === 1) {
    if (Bi(t2) && s2 && e4(s2))
      return Si(t2.arguments[0]);
    if (function(e6) {
      return e6.callee.type === "Identifier" && /^(?:before|after)(?:Each|All)$/.test(e6.callee.name) && e6.arguments.length === 1;
    }(t2))
      return Bi(t2.arguments[0]);
  } else if ((t2.arguments.length === 2 || t2.arguments.length === 3) && (t2.callee.type === "Identifier" && Oi.test(t2.callee.name) || function(e6) {
    return Ri(e6.callee) && e6.callee.object.type === "Identifier" && e6.callee.property.type === "Identifier" && Oi.test(e6.callee.object.name) && (e6.callee.property.name === "only" || e6.callee.property.name === "skip");
  }(t2)) && (function(e6) {
    return e6.type === "TemplateLiteral";
  }(t2.arguments[0]) || wi(t2.arguments[0])))
    return !(t2.arguments[2] && !Ti(t2.arguments[2])) && ((t2.arguments.length === 2 ? Si(t2.arguments[1]) : function(e6) {
      return e6.type === "FunctionExpression" || e6.type === "ArrowFunctionExpression" && e6.body.type === "BlockStatement";
    }(t2.arguments[1]) && Gi(t2.arguments[1]).length <= 1) || Bi(t2.arguments[1]));
  return false;
}, isTheOnlyJsxElementInMarkdown: function(e6, t2) {
  if (e6.parentParser !== "markdown" && e6.parentParser !== "mdx")
    return false;
  const s2 = t2.getNode();
  if (!s2.expression || !Ni(s2.expression))
    return false;
  const r2 = t2.getParentNode();
  return r2.type === "Program" && r2.body.length === 1;
}, isTSXFile: function(e6) {
  return e6.filepath && /\.tsx$/i.test(e6.filepath);
}, isTypeAnnotationAFunction: function(e6) {
  return !(e6.type !== "TypeAnnotation" && e6.type !== "TSTypeAnnotation" || e6.typeAnnotation.type !== "FunctionTypeAnnotation" || e6.static || Ei(e6, e6.typeAnnotation));
}, isNextLineEmpty: (e6, { originalText: t2 }) => mi(t2, Ai(e6)), needsHardlineAfterDanglingComment: function(e6) {
  if (!ea(e6))
    return false;
  const t2 = pi(ta(e6, Qi.Dangling));
  return t2 && !Fi(t2);
}, rawText: Ui, shouldPrintComma: function(e6, t2 = "es5") {
  return e6.trailingComma === "es5" && t2 === "es5" || e6.trailingComma === "all" && (t2 === "all" || t2 === "es5");
}, isBitwiseOperator: function(e6) {
  return Boolean(Hi[e6]) || e6 === "|" || e6 === "^" || e6 === "&";
}, shouldFlatten: function(e6, t2) {
  return zi(t2) === zi(e6) && (e6 !== "**" && ((!qi[e6] || !qi[t2]) && (!(t2 === "%" && $i[e6] || e6 === "%" && $i[t2]) && ((t2 === e6 || !$i[t2] || !$i[e6]) && (!Hi[e6] || !Hi[t2])))));
}, startsWithNoLookaheadToken: function e5(t2, s2) {
  switch ((t2 = function(e6) {
    for (; e6.left; )
      e6 = e6.left;
    return e6;
  }(t2)).type) {
    case "FunctionExpression":
    case "ClassExpression":
    case "DoExpression":
      return s2;
    case "ObjectExpression":
      return true;
    case "MemberExpression":
    case "OptionalMemberExpression":
      return e5(t2.object, s2);
    case "TaggedTemplateExpression":
      return t2.tag.type !== "FunctionExpression" && e5(t2.tag, s2);
    case "CallExpression":
    case "OptionalCallExpression":
      return t2.callee.type !== "FunctionExpression" && e5(t2.callee, s2);
    case "ConditionalExpression":
      return e5(t2.test, s2);
    case "UpdateExpression":
      return !t2.prefix && e5(t2.argument, s2);
    case "BindExpression":
      return t2.object && e5(t2.object, s2);
    case "SequenceExpression":
      return e5(t2.expressions[0], s2);
    case "TSAsExpression":
    case "TSNonNullExpression":
      return e5(t2.expression, s2);
    default:
      return false;
  }
}, getPrecedence: zi, hasComment: ea, getComments: ta, CommentCheckFlags: Qi };
var { getLast: ia, hasNewline: aa, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: na, getNextNonSpaceNonCommentCharacter: oa, hasNewlineInRange: ua, addLeadingComment: ha, addTrailingComment: ca, addDanglingComment: pa, getNextNonSpaceNonCommentCharacterIndex: la, isNonEmptyArray: da } = tr;
var { isBlockComment: Da, getFunctionParameters: ma, isPrettierIgnoreComment: fa, isJsxNode: ya, hasFlowShorthandAnnotationComment: Aa, hasFlowAnnotationComment: Ea, hasIgnoreComment: Ca, isCallLikeExpression: xa, getCallArguments: Fa, isCallExpression: ga, isMemberExpression: ba, isObjectProperty: Pa, getComments: Ta, CommentCheckFlags: wa } = ra;
var { locStart: Sa, locEnd: Ba } = ei;
function Na(e6, t2) {
  const s2 = (e6.body || e6.properties).find(({ type: e7 }) => e7 !== "EmptyStatement");
  s2 ? ha(s2, t2) : pa(e6, t2);
}
function Ia(e6, t2) {
  e6.type === "BlockStatement" ? Na(e6, t2) : ha(e6, t2);
}
function va({ comment: e6, followingNode: t2 }) {
  return !(!t2 || !un(e6)) && (ha(t2, e6), true);
}
function ka({ comment: e6, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2 }) {
  if (!s2 || s2.type !== "IfStatement" || !r2)
    return false;
  return oa(i2, e6, Ba) === ")" ? (ca(t2, e6), true) : t2 === s2.consequent && r2 === s2.alternate ? (t2.type === "BlockStatement" ? ca(t2, e6) : pa(s2, e6), true) : r2.type === "BlockStatement" ? (Na(r2, e6), true) : r2.type === "IfStatement" ? (Ia(r2.consequent, e6), true) : s2.consequent === r2 && (ha(r2, e6), true);
}
function La({ comment: e6, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2 }) {
  if (!s2 || s2.type !== "WhileStatement" || !r2)
    return false;
  return oa(i2, e6, Ba) === ")" ? (ca(t2, e6), true) : r2.type === "BlockStatement" ? (Na(r2, e6), true) : s2.body === r2 && (ha(r2, e6), true);
}
function Oa({ comment: e6, precedingNode: t2, enclosingNode: s2, followingNode: r2 }) {
  return !(!s2 || s2.type !== "TryStatement" && s2.type !== "CatchClause" || !r2) && (s2.type === "CatchClause" && t2 ? (ca(t2, e6), true) : r2.type === "BlockStatement" ? (Na(r2, e6), true) : r2.type === "TryStatement" ? (Ia(r2.finalizer, e6), true) : r2.type === "CatchClause" && (Ia(r2.body, e6), true));
}
function Ma({ comment: e6, enclosingNode: t2, followingNode: s2 }) {
  return !(!ba(t2) || !s2 || s2.type !== "Identifier") && (ha(t2, e6), true);
}
function Ra({ comment: e6, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2 }) {
  const a2 = t2 && !ua(i2, Ba(t2), Sa(e6));
  return !(t2 && a2 || !s2 || s2.type !== "ConditionalExpression" && s2.type !== "TSConditionalType" || !r2) && (ha(r2, e6), true);
}
function ja({ comment: e6, precedingNode: t2, enclosingNode: s2 }) {
  return !(!Pa(s2) || !s2.shorthand || s2.key !== t2 || s2.value.type !== "AssignmentPattern") && (ca(s2.value.left, e6), true);
}
function _a({ comment: e6, precedingNode: t2, enclosingNode: s2, followingNode: r2 }) {
  if (s2 && (s2.type === "ClassDeclaration" || s2.type === "ClassExpression" || s2.type === "DeclareClass" || s2.type === "DeclareInterface" || s2.type === "InterfaceDeclaration" || s2.type === "TSInterfaceDeclaration")) {
    if (da(s2.decorators) && (!r2 || r2.type !== "Decorator"))
      return ca(ia(s2.decorators), e6), true;
    if (s2.body && r2 === s2.body)
      return Na(s2.body, e6), true;
    if (r2) {
      for (const i2 of ["implements", "extends", "mixins"])
        if (s2[i2] && r2 === s2[i2][0])
          return !t2 || t2 !== s2.id && t2 !== s2.typeParameters && t2 !== s2.superClass ? pa(s2, e6, i2) : ca(t2, e6), true;
    }
  }
  return false;
}
function Ua({ comment: e6, precedingNode: t2, enclosingNode: s2, text: r2 }) {
  return (s2 && t2 && (s2.type === "Property" || s2.type === "TSDeclareMethod" || s2.type === "TSAbstractMethodDefinition") && t2.type === "Identifier" && s2.key === t2 && oa(r2, t2, Ba) !== ":" || !(!t2 || !s2 || t2.type !== "Decorator" || s2.type !== "ClassMethod" && s2.type !== "ClassProperty" && s2.type !== "PropertyDefinition" && s2.type !== "TSAbstractClassProperty" && s2.type !== "TSAbstractMethodDefinition" && s2.type !== "TSDeclareMethod" && s2.type !== "MethodDefinition")) && (ca(t2, e6), true);
}
function qa({ comment: e6, precedingNode: t2, enclosingNode: s2, text: r2 }) {
  return oa(r2, e6, Ba) === "(" && (!(!t2 || !s2 || s2.type !== "FunctionDeclaration" && s2.type !== "FunctionExpression" && s2.type !== "ClassMethod" && s2.type !== "MethodDefinition" && s2.type !== "ObjectMethod") && (ca(t2, e6), true));
}
function $a({ comment: e6, enclosingNode: t2, text: s2 }) {
  if (!t2 || t2.type !== "ArrowFunctionExpression")
    return false;
  const r2 = la(s2, e6, Ba);
  return r2 !== false && s2.slice(r2, r2 + 2) === "=>" && (pa(t2, e6), true);
}
function Ha({ comment: e6, enclosingNode: t2, text: s2 }) {
  return oa(s2, e6, Ba) === ")" && (t2 && (on(t2) && ma(t2).length === 0 || xa(t2) && Fa(t2).length === 0) ? (pa(t2, e6), true) : !(!t2 || t2.type !== "MethodDefinition" && t2.type !== "TSAbstractMethodDefinition" || ma(t2.value).length !== 0) && (pa(t2.value, e6), true));
}
function Va({ comment: e6, precedingNode: t2, enclosingNode: s2, followingNode: r2, text: i2 }) {
  if (t2 && t2.type === "FunctionTypeParam" && s2 && s2.type === "FunctionTypeAnnotation" && r2 && r2.type !== "FunctionTypeParam")
    return ca(t2, e6), true;
  if (t2 && (t2.type === "Identifier" || t2.type === "AssignmentPattern") && s2 && on(s2) && oa(i2, e6, Ba) === ")")
    return ca(t2, e6), true;
  if (s2 && s2.type === "FunctionDeclaration" && r2 && r2.type === "BlockStatement") {
    const t3 = (() => {
      const e7 = ma(s2);
      if (e7.length > 0)
        return na(i2, Ba(ia(e7)));
      const t4 = na(i2, Ba(s2.id));
      return t4 !== false && na(i2, t4 + 1);
    })();
    if (Sa(e6) > t3)
      return Na(r2, e6), true;
  }
  return false;
}
function za({ comment: e6, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "ImportSpecifier") && (ha(t2, e6), true);
}
function Wa({ comment: e6, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "LabeledStatement") && (ha(t2, e6), true);
}
function Ga({ comment: e6, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "ContinueStatement" && t2.type !== "BreakStatement" || t2.label) && (ca(t2, e6), true);
}
function Ka({ comment: e6, precedingNode: t2, enclosingNode: s2 }) {
  return !!(ga(s2) && t2 && s2.callee === t2 && s2.arguments.length > 0) && (ha(s2.arguments[0], e6), true);
}
function Xa({ comment: e6, precedingNode: t2, enclosingNode: s2, followingNode: r2 }) {
  return !s2 || s2.type !== "UnionTypeAnnotation" && s2.type !== "TSUnionType" ? (r2 && (r2.type === "UnionTypeAnnotation" || r2.type === "TSUnionType") && fa(e6) && (r2.types[0].prettierIgnore = true, e6.unignore = true), false) : (fa(e6) && (r2.prettierIgnore = true, e6.unignore = true), !!t2 && (ca(t2, e6), true));
}
function Ja({ comment: e6, enclosingNode: t2 }) {
  return !!Pa(t2) && (ha(t2, e6), true);
}
function Ya({ comment: e6, enclosingNode: t2, followingNode: s2, ast: r2, isLastComment: i2 }) {
  return r2 && r2.body && r2.body.length === 0 ? (i2 ? pa(r2, e6) : ha(r2, e6), true) : t2 && t2.type === "Program" && t2.body.length === 0 && !da(t2.directives) ? (i2 ? pa(t2, e6) : ha(t2, e6), true) : !(!s2 || s2.type !== "Program" || s2.body.length !== 0 || !t2 || t2.type !== "ModuleExpression") && (pa(s2, e6), true);
}
function Qa({ comment: e6, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "ForInStatement" && t2.type !== "ForOfStatement") && (ha(t2, e6), true);
}
function Za({ comment: e6, precedingNode: t2, enclosingNode: s2, text: r2 }) {
  return !!(t2 && t2.type === "ImportSpecifier" && s2 && s2.type === "ImportDeclaration" && aa(r2, Ba(e6))) && (ca(t2, e6), true);
}
function en({ comment: e6, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "AssignmentPattern") && (ha(t2, e6), true);
}
function tn({ comment: e6, enclosingNode: t2 }) {
  return !(!t2 || t2.type !== "TypeAlias") && (ha(t2, e6), true);
}
function sn({ comment: e6, enclosingNode: t2, followingNode: s2 }) {
  return !(!t2 || t2.type !== "VariableDeclarator" && t2.type !== "AssignmentExpression" || !s2 || s2.type !== "ObjectExpression" && s2.type !== "ArrayExpression" && s2.type !== "TemplateLiteral" && s2.type !== "TaggedTemplateExpression" && !Da(e6)) && (ha(s2, e6), true);
}
function rn({ comment: e6, enclosingNode: t2, followingNode: s2, text: r2 }) {
  return !(s2 || !t2 || t2.type !== "TSMethodSignature" && t2.type !== "TSDeclareFunction" && t2.type !== "TSAbstractMethodDefinition" || oa(r2, e6, Ba) !== ";") && (ca(t2, e6), true);
}
function an({ comment: e6, enclosingNode: t2, followingNode: s2 }) {
  if (fa(e6) && t2 && t2.type === "TSMappedType" && s2 && s2.type === "TSTypeParameter" && s2.constraint)
    return t2.prettierIgnore = true, e6.unignore = true, true;
}
function nn({ comment: e6, precedingNode: t2, enclosingNode: s2, followingNode: r2 }) {
  return !(!s2 || s2.type !== "TSMappedType") && (r2 && r2.type === "TSTypeParameter" && r2.name ? (ha(r2.name, e6), true) : !(!t2 || t2.type !== "TSTypeParameter" || !t2.constraint) && (ca(t2.constraint, e6), true));
}
function on(e6) {
  return e6.type === "ArrowFunctionExpression" || e6.type === "FunctionExpression" || e6.type === "FunctionDeclaration" || e6.type === "ObjectMethod" || e6.type === "ClassMethod" || e6.type === "TSDeclareFunction" || e6.type === "TSCallSignatureDeclaration" || e6.type === "TSConstructSignatureDeclaration" || e6.type === "TSMethodSignature" || e6.type === "TSConstructorType" || e6.type === "TSFunctionType" || e6.type === "TSDeclareMethod";
}
function un(e6) {
  return Da(e6) && e6.value[0] === "*" && /@type\b/.test(e6.value);
}
var hn = { handleOwnLineComment: function(e6) {
  return [an, Va, Ma, ka, La, Oa, _a, za, Qa, Xa, Ya, Za, en, Ua, Wa].some((t2) => t2(e6));
}, handleEndOfLineComment: function(e6) {
  return [va, Va, Ra, za, ka, La, Oa, _a, Wa, Ka, Ja, Ya, tn, sn].some((t2) => t2(e6));
}, handleRemainingComment: function(e6) {
  return [an, ka, La, ja, Ha, Ua, Ya, $a, qa, nn, Ga, rn].some((t2) => t2(e6));
}, isTypeCastComment: un, getCommentChildNodes: function(e6, t2) {
  if ((t2.parser === "typescript" || t2.parser === "flow" || t2.parser === "espree" || t2.parser === "meriyah" || t2.parser === "__babel_estree") && e6.type === "MethodDefinition" && e6.value && e6.value.type === "FunctionExpression" && ma(e6.value).length === 0 && !e6.value.returnType && !da(e6.value.typeParameters) && e6.value.body)
    return [...e6.decorators || [], e6.key, e6.value.body];
}, willPrintOwnComments: function(e6) {
  const t2 = e6.getValue(), s2 = e6.getParentNode();
  return (t2 && (ya(t2) || Aa(t2) || ga(s2) && ((e7) => Ea(Ta(e7, wa.Leading)) || Ea(Ta(e7, wa.Trailing)))(t2)) || s2 && (s2.type === "JSXSpreadAttribute" || s2.type === "JSXSpreadChild" || s2.type === "UnionTypeAnnotation" || s2.type === "TSUnionType" || (s2.type === "ClassDeclaration" || s2.type === "ClassExpression") && s2.superClass === t2)) && (!Ca(e6) || s2.type === "UnionTypeAnnotation" || s2.type === "TSUnionType");
} };
var { getLast: cn, getNextNonSpaceNonCommentCharacter: pn } = tr;
var { locStart: ln, locEnd: dn } = ei;
var { isTypeCastComment: Dn } = hn;
function mn(e6) {
  return e6.type === "CallExpression" ? (e6.type = "OptionalCallExpression", e6.callee = mn(e6.callee)) : e6.type === "MemberExpression" ? (e6.type = "OptionalMemberExpression", e6.object = mn(e6.object)) : e6.type === "TSNonNullExpression" && (e6.expression = mn(e6.expression)), e6;
}
function fn(e6, t2) {
  let s2;
  if (Array.isArray(e6))
    s2 = e6.entries();
  else {
    if (!e6 || typeof e6 != "object" || typeof e6.type != "string")
      return e6;
    s2 = Object.entries(e6);
  }
  for (const [r2, i2] of s2)
    e6[r2] = fn(i2, t2);
  return Array.isArray(e6) ? e6 : t2(e6) || e6;
}
function yn(e6) {
  return e6.type === "LogicalExpression" && e6.right.type === "LogicalExpression" && e6.operator === e6.right.operator;
}
function An(e6) {
  return yn(e6) ? An({ type: "LogicalExpression", operator: e6.operator, left: An({ type: "LogicalExpression", operator: e6.operator, left: e6.left, right: e6.right.left, range: [ln(e6.left), dn(e6.right.left)] }), right: e6.right.right, range: [ln(e6), dn(e6)] }) : e6;
}
var En = function(e6, t2) {
  if (t2.parser === "typescript" && t2.originalText.includes("@")) {
    const { esTreeNodeToTSNodeMap: s2, tsNodeToESTreeNodeMap: r2 } = t2.tsParseResult;
    e6 = fn(e6, (e7) => {
      const t3 = s2.get(e7);
      if (!t3)
        return;
      const i2 = t3.decorators;
      if (!Array.isArray(i2))
        return;
      const a2 = r2.get(t3);
      if (a2 !== e7)
        return;
      const n2 = a2.decorators;
      if (!Array.isArray(n2) || n2.length !== i2.length || i2.some((e8) => {
        const t4 = r2.get(e8);
        return !t4 || !n2.includes(t4);
      })) {
        const { start: e8, end: t4 } = a2.loc;
        throw ai("Leading decorators must be attached to a class declaration", { start: { line: e8.line, column: e8.column + 1 }, end: { line: t4.line, column: t4.column + 1 } });
      }
    });
  }
  if (t2.parser !== "typescript" && t2.parser !== "flow" && t2.parser !== "espree" && t2.parser !== "meriyah") {
    const t3 = new Set();
    e6 = fn(e6, (e7) => {
      e7.leadingComments && e7.leadingComments.some(Dn) && t3.add(ln(e7));
    }), e6 = fn(e6, (e7) => {
      if (e7.type === "ParenthesizedExpression") {
        const { expression: s2 } = e7;
        if (s2.type === "TypeCastExpression")
          return s2.range = e7.range, s2;
        const r2 = ln(e7);
        if (!t3.has(r2))
          return s2.extra = Object.assign(Object.assign({}, s2.extra), {}, { parenthesized: true }), s2;
      }
    });
  }
  return e6 = fn(e6, (e7) => {
    switch (e7.type) {
      case "ChainExpression":
        return mn(e7.expression);
      case "LogicalExpression":
        if (yn(e7))
          return An(e7);
        break;
      case "VariableDeclaration": {
        const s2 = cn(e7.declarations);
        s2 && s2.init && function(e8, s3) {
          if (t2.originalText[dn(s3)] === ";")
            return;
          e8.range = [ln(e8), dn(s3)];
        }(e7, s2);
        break;
      }
      case "TSParenthesizedType":
        return e7.typeAnnotation.range = [ln(e7), dn(e7)], e7.typeAnnotation;
      case "TSTypeParameter":
        if (typeof e7.name == "string") {
          const t3 = ln(e7);
          e7.name = { type: "Identifier", name: e7.name, range: [t3, t3 + e7.name.length] };
        }
        break;
      case "SequenceExpression": {
        const t3 = cn(e7.expressions);
        e7.range = [ln(e7), Math.min(dn(t3), dn(e7))];
        break;
      }
      case "ClassProperty":
        e7.key && e7.key.type === "TSPrivateIdentifier" && pn(t2.originalText, e7.key, dn) === "?" && (e7.optional = true);
    }
  });
};
var Cn = class {
  constructor(e6, t2 = {}) {
    this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.updateContext = void 0, this.label = e6, this.keyword = t2.keyword, this.beforeExpr = !!t2.beforeExpr, this.startsExpr = !!t2.startsExpr, this.rightAssociative = !!t2.rightAssociative, this.isLoop = !!t2.isLoop, this.isAssign = !!t2.isAssign, this.prefix = !!t2.prefix, this.postfix = !!t2.postfix, this.binop = t2.binop != null ? t2.binop : null, this.updateContext = null;
  }
};
var xn = new Map();
function Fn(e6, t2 = {}) {
  t2.keyword = e6;
  const s2 = new Cn(e6, t2);
  return xn.set(e6, s2), s2;
}
function gn(e6, t2) {
  return new Cn(e6, { beforeExpr: true, binop: t2 });
}
var bn = { num: new Cn("num", { startsExpr: true }), bigint: new Cn("bigint", { startsExpr: true }), decimal: new Cn("decimal", { startsExpr: true }), regexp: new Cn("regexp", { startsExpr: true }), string: new Cn("string", { startsExpr: true }), name: new Cn("name", { startsExpr: true }), privateName: new Cn("#name", { startsExpr: true }), eof: new Cn("eof"), bracketL: new Cn("[", { beforeExpr: true, startsExpr: true }), bracketHashL: new Cn("#[", { beforeExpr: true, startsExpr: true }), bracketBarL: new Cn("[|", { beforeExpr: true, startsExpr: true }), bracketR: new Cn("]"), bracketBarR: new Cn("|]"), braceL: new Cn("{", { beforeExpr: true, startsExpr: true }), braceBarL: new Cn("{|", { beforeExpr: true, startsExpr: true }), braceHashL: new Cn("#{", { beforeExpr: true, startsExpr: true }), braceR: new Cn("}", { beforeExpr: true }), braceBarR: new Cn("|}"), parenL: new Cn("(", { beforeExpr: true, startsExpr: true }), parenR: new Cn(")"), comma: new Cn(",", { beforeExpr: true }), semi: new Cn(";", { beforeExpr: true }), colon: new Cn(":", { beforeExpr: true }), doubleColon: new Cn("::", { beforeExpr: true }), dot: new Cn("."), question: new Cn("?", { beforeExpr: true }), questionDot: new Cn("?."), arrow: new Cn("=>", { beforeExpr: true }), template: new Cn("template"), ellipsis: new Cn("...", { beforeExpr: true }), backQuote: new Cn("`", { startsExpr: true }), dollarBraceL: new Cn("${", { beforeExpr: true, startsExpr: true }), at: new Cn("@"), hash: new Cn("#", { startsExpr: true }), interpreterDirective: new Cn("#!..."), eq: new Cn("=", { beforeExpr: true, isAssign: true }), assign: new Cn("_=", { beforeExpr: true, isAssign: true }), slashAssign: new Cn("_=", { beforeExpr: true, isAssign: true }), moduloAssign: new Cn("_=", { beforeExpr: true, isAssign: true }), incDec: new Cn("++/--", { prefix: true, postfix: true, startsExpr: true }), bang: new Cn("!", { beforeExpr: true, prefix: true, startsExpr: true }), tilde: new Cn("~", { beforeExpr: true, prefix: true, startsExpr: true }), pipeline: gn("|>", 0), nullishCoalescing: gn("??", 1), logicalOR: gn("||", 1), logicalAND: gn("&&", 2), bitwiseOR: gn("|", 3), bitwiseXOR: gn("^", 4), bitwiseAND: gn("&", 5), equality: gn("==/!=/===/!==", 6), relational: gn("</>/<=/>=", 7), bitShift: gn("<</>>/>>>", 8), plusMin: new Cn("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: new Cn("%", { binop: 10, startsExpr: true }), star: new Cn("*", { binop: 10 }), slash: gn("/", 10), exponent: new Cn("**", { beforeExpr: true, binop: 11, rightAssociative: true }), _break: Fn("break"), _case: Fn("case", { beforeExpr: true }), _catch: Fn("catch"), _continue: Fn("continue"), _debugger: Fn("debugger"), _default: Fn("default", { beforeExpr: true }), _do: Fn("do", { isLoop: true, beforeExpr: true }), _else: Fn("else", { beforeExpr: true }), _finally: Fn("finally"), _for: Fn("for", { isLoop: true }), _function: Fn("function", { startsExpr: true }), _if: Fn("if"), _return: Fn("return", { beforeExpr: true }), _switch: Fn("switch"), _throw: Fn("throw", { beforeExpr: true, prefix: true, startsExpr: true }), _try: Fn("try"), _var: Fn("var"), _const: Fn("const"), _while: Fn("while", { isLoop: true }), _with: Fn("with"), _new: Fn("new", { beforeExpr: true, startsExpr: true }), _this: Fn("this", { startsExpr: true }), _super: Fn("super", { startsExpr: true }), _class: Fn("class", { startsExpr: true }), _extends: Fn("extends", { beforeExpr: true }), _export: Fn("export"), _import: Fn("import", { startsExpr: true }), _null: Fn("null", { startsExpr: true }), _true: Fn("true", { startsExpr: true }), _false: Fn("false", { startsExpr: true }), _in: Fn("in", { beforeExpr: true, binop: 7 }), _instanceof: Fn("instanceof", { beforeExpr: true, binop: 7 }), _typeof: Fn("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: Fn("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: Fn("delete", { beforeExpr: true, prefix: true, startsExpr: true }) };
var Pn = /\r\n?|[\n\u2028\u2029]/;
var Tn = new RegExp(Pn.source, "g");
function wn(e6) {
  switch (e6) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return true;
    default:
      return false;
  }
}
var Sn = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var Bn = new RegExp("(?=(" + /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
function Nn(e6) {
  switch (e6) {
    case 9:
    case 11:
    case 12:
    case 32:
    case 160:
    case 5760:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8202:
    case 8239:
    case 8287:
    case 12288:
    case 65279:
      return true;
    default:
      return false;
  }
}
var In = class {
  constructor(e6, t2) {
    this.line = void 0, this.column = void 0, this.line = e6, this.column = t2;
  }
};
var vn = class {
  constructor(e6, t2) {
    this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e6, this.end = t2;
  }
};
function kn(e6, t2) {
  e6.trailingComments === void 0 ? e6.trailingComments = t2 : e6.trailingComments.unshift(...t2);
}
function Ln(e6, t2) {
  e6.innerComments === void 0 ? e6.innerComments = t2 : t2 !== void 0 && e6.innerComments.unshift(...t2);
}
function On(e6, t2, s2) {
  let r2 = null, i2 = t2.length;
  for (; r2 === null && i2 > 0; )
    r2 = t2[--i2];
  r2 === null || r2.start > s2.start ? Ln(e6, s2.comments) : kn(r2, s2.comments);
}
var Mn = Object.freeze({ SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" });
var Rn = Un({ AccessorIsGenerator: "A %0ter cannot be a generator.", ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accesor must not have any formal parameters.", BadSetterArity: "A 'set' accesor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: "'%0' require an initialization value.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.", DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?", ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: "Unsyntactic %0.", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?', ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: "`import()` requires exactly %0.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidDecimal: "Invalid decimal.", InvalidDigit: "Expected number in radix %0.", InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: "Escape sequence in keyword %0.", InvalidIdentifier: "Invalid identifier %0.", InvalidLhs: "Invalid left-hand side in %0.", InvalidLhsBinding: "Binding invalid left-hand side in %0.", InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: "Unexpected character '%0'.", InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: "Private name #%0 is not defined.", InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: "Label '%0' is already declared.", LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.', ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.", ModuleExportUndefined: "Export '%0' is not defined.", MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PipeBodyIsTighter: "Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: 'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "%0" }.', PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).", PrivateNameRedeclaration: "Duplicate private name #%0.", RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: "Assigning to '%0' in strict mode.", StrictEvalArgumentsBinding: "Binding '%0' in strict mode.", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: "Unexpected keyword '%0'.", UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).", UnexpectedReservedWord: "Unexpected reserved word '%0'.", UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: "Unexpected token '%0'.", UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.", UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", VarRedeclaration: "Identifier '%0' has already been declared.", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, Mn.SyntaxError);
var jn = Un({ ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`, ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'` }, Mn.SourceTypeModuleError);
function _n(e6, t2) {
  return t2 === "flow" && e6 === "PatternIsOptional" ? "OptionalBindingPattern" : e6;
}
function Un(e6, t2, s2) {
  const r2 = {};
  return Object.keys(e6).forEach((i2) => {
    r2[i2] = Object.freeze({ code: t2, reasonCode: _n(i2, s2), template: e6[i2] });
  }), Object.freeze(r2);
}
var qn = class {
  constructor(e6, t2) {
    this.token = void 0, this.preserveSpace = void 0, this.token = e6, this.preserveSpace = !!t2;
  }
};
var $n = { brace: new qn("{"), template: new qn("`", true) };
bn.braceR.updateContext = (e6) => {
  e6.pop();
}, bn.braceL.updateContext = bn.braceHashL.updateContext = bn.dollarBraceL.updateContext = (e6) => {
  e6.push($n.brace);
}, bn.backQuote.updateContext = (e6) => {
  e6[e6.length - 1] === $n.template ? e6.pop() : e6.push($n.template);
};
var Hn = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var Vn = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
var zn = new RegExp("[" + Hn + "]");
var Wn = new RegExp("[" + Hn + Vn + "]");
Hn = Vn = null;
var Gn = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
var Kn = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function Xn(e6, t2) {
  let s2 = 65536;
  for (let r2 = 0, i2 = t2.length; r2 < i2; r2 += 2) {
    if (s2 += t2[r2], s2 > e6)
      return false;
    if (s2 += t2[r2 + 1], s2 >= e6)
      return true;
  }
  return false;
}
function Jn(e6) {
  return e6 < 65 ? e6 === 36 : e6 <= 90 || (e6 < 97 ? e6 === 95 : e6 <= 122 || (e6 <= 65535 ? e6 >= 170 && zn.test(String.fromCharCode(e6)) : Xn(e6, Gn)));
}
function Yn(e6) {
  return e6 < 48 ? e6 === 36 : e6 < 58 || !(e6 < 65) && (e6 <= 90 || (e6 < 97 ? e6 === 95 : e6 <= 122 || (e6 <= 65535 ? e6 >= 170 && Wn.test(String.fromCharCode(e6)) : Xn(e6, Gn) || Xn(e6, Kn))));
}
var Qn = ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"];
var Zn = ["eval", "arguments"];
var eo = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]);
var to = new Set(Qn);
var so = new Set(Zn);
function ro(e6, t2) {
  return t2 && e6 === "await" || e6 === "enum";
}
function io(e6, t2) {
  return ro(e6, t2) || to.has(e6);
}
function ao(e6) {
  return so.has(e6);
}
function no(e6, t2) {
  return io(e6, t2) || ao(e6);
}
function oo(e6) {
  return eo.has(e6);
}
var uo = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
var ho = class {
  constructor(e6) {
    this.var = new Set(), this.lexical = new Set(), this.functions = new Set(), this.flags = e6;
  }
};
var co = class {
  constructor(e6, t2) {
    this.scopeStack = [], this.undefinedExports = new Map(), this.undefinedPrivateNames = new Map(), this.raise = e6, this.inModule = t2;
  }
  get inFunction() {
    return (2 & this.currentVarScopeFlags()) > 0;
  }
  get allowSuper() {
    return (16 & this.currentThisScopeFlags()) > 0;
  }
  get allowDirectSuper() {
    return (32 & this.currentThisScopeFlags()) > 0;
  }
  get inClass() {
    return (64 & this.currentThisScopeFlags()) > 0;
  }
  get inClassAndNotInNonArrowFunction() {
    const e6 = this.currentThisScopeFlags();
    return (64 & e6) > 0 && (2 & e6) == 0;
  }
  get inStaticBlock() {
    for (let e6 = this.scopeStack.length - 1; ; e6--) {
      const { flags: t2 } = this.scopeStack[e6];
      if (128 & t2)
        return true;
      if (323 & t2)
        return false;
    }
  }
  get inNonArrowFunction() {
    return (2 & this.currentThisScopeFlags()) > 0;
  }
  get treatFunctionsAsVar() {
    return this.treatFunctionsAsVarInScope(this.currentScope());
  }
  createScope(e6) {
    return new ho(e6);
  }
  enter(e6) {
    this.scopeStack.push(this.createScope(e6));
  }
  exit() {
    this.scopeStack.pop();
  }
  treatFunctionsAsVarInScope(e6) {
    return !!(2 & e6.flags || !this.inModule && 1 & e6.flags);
  }
  declareName(e6, t2, s2) {
    let r2 = this.currentScope();
    if (8 & t2 || 16 & t2)
      this.checkRedeclarationInScope(r2, e6, t2, s2), 16 & t2 ? r2.functions.add(e6) : r2.lexical.add(e6), 8 & t2 && this.maybeExportDefined(r2, e6);
    else if (4 & t2)
      for (let i2 = this.scopeStack.length - 1; i2 >= 0 && (r2 = this.scopeStack[i2], this.checkRedeclarationInScope(r2, e6, t2, s2), r2.var.add(e6), this.maybeExportDefined(r2, e6), !(259 & r2.flags)); --i2)
        ;
    this.inModule && 1 & r2.flags && this.undefinedExports.delete(e6);
  }
  maybeExportDefined(e6, t2) {
    this.inModule && 1 & e6.flags && this.undefinedExports.delete(t2);
  }
  checkRedeclarationInScope(e6, t2, s2, r2) {
    this.isRedeclaredInScope(e6, t2, s2) && this.raise(r2, Rn.VarRedeclaration, t2);
  }
  isRedeclaredInScope(e6, t2, s2) {
    return !!(1 & s2) && (8 & s2 ? e6.lexical.has(t2) || e6.functions.has(t2) || e6.var.has(t2) : 16 & s2 ? e6.lexical.has(t2) || !this.treatFunctionsAsVarInScope(e6) && e6.var.has(t2) : e6.lexical.has(t2) && !(8 & e6.flags && e6.lexical.values().next().value === t2) || !this.treatFunctionsAsVarInScope(e6) && e6.functions.has(t2));
  }
  checkLocalExport(e6) {
    const { name: t2 } = e6, s2 = this.scopeStack[0];
    s2.lexical.has(t2) || s2.var.has(t2) || s2.functions.has(t2) || this.undefinedExports.set(t2, e6.start);
  }
  currentScope() {
    return this.scopeStack[this.scopeStack.length - 1];
  }
  currentVarScopeFlags() {
    for (let e6 = this.scopeStack.length - 1; ; e6--) {
      const { flags: t2 } = this.scopeStack[e6];
      if (259 & t2)
        return t2;
    }
  }
  currentThisScopeFlags() {
    for (let e6 = this.scopeStack.length - 1; ; e6--) {
      const { flags: t2 } = this.scopeStack[e6];
      if (323 & t2 && !(4 & t2))
        return t2;
    }
  }
};
var po = class extends ho {
  constructor(...e6) {
    super(...e6), this.declareFunctions = new Set();
  }
};
var lo = class extends co {
  createScope(e6) {
    return new po(e6);
  }
  declareName(e6, t2, s2) {
    const r2 = this.currentScope();
    if (2048 & t2)
      return this.checkRedeclarationInScope(r2, e6, t2, s2), this.maybeExportDefined(r2, e6), void r2.declareFunctions.add(e6);
    super.declareName(...arguments);
  }
  isRedeclaredInScope(e6, t2, s2) {
    return !!super.isRedeclaredInScope(...arguments) || !!(2048 & s2) && (!e6.declareFunctions.has(t2) && (e6.lexical.has(t2) || e6.functions.has(t2)));
  }
  checkLocalExport(e6) {
    this.scopeStack[0].declareFunctions.has(e6.name) || super.checkLocalExport(e6);
  }
};
var Do = class {
  constructor() {
    this.strict = void 0, this.curLine = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.inPropertyName = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.commentStack = [], this.pos = 0, this.lineStart = 0, this.type = bn.eof, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.lastTokEnd = 0, this.context = [$n.brace], this.exprAllowed = true, this.containsEsc = false, this.strictErrors = new Map(), this.tokensLength = 0;
  }
  init(e6) {
    this.strict = e6.strictMode !== false && (e6.strictMode === true || e6.sourceType === "module"), this.curLine = e6.startLine, this.startLoc = this.endLoc = this.curPosition();
  }
  curPosition() {
    return new In(this.curLine, this.pos - this.lineStart);
  }
  clone(e6) {
    const t2 = new Do(), s2 = Object.keys(this);
    for (let r2 = 0, i2 = s2.length; r2 < i2; r2++) {
      const i3 = s2[r2];
      let a2 = this[i3];
      !e6 && Array.isArray(a2) && (a2 = a2.slice()), t2[i3] = a2;
    }
    return t2;
  }
};
var mo = function(e6) {
  return e6 >= 48 && e6 <= 57;
};
var fo = new Set([103, 109, 115, 105, 121, 117, 100]);
var yo = { decBinOct: [46, 66, 69, 79, 95, 98, 101, 111], hex: [46, 88, 95, 120] };
var Ao = { bin: [48, 49] };
Ao.oct = [...Ao.bin, 50, 51, 52, 53, 54, 55], Ao.dec = [...Ao.oct, 56, 57], Ao.hex = [...Ao.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
var Eo = class {
  constructor(e6) {
    this.type = e6.type, this.value = e6.value, this.start = e6.start, this.end = e6.end, this.loc = new vn(e6.startLoc, e6.endLoc);
  }
};
var Co = class {
  constructor() {
    this.privateNames = new Set(), this.loneAccessors = new Map(), this.undefinedPrivateNames = new Map();
  }
};
var xo = class {
  constructor(e6) {
    this.stack = [], this.undefinedPrivateNames = new Map(), this.raise = e6;
  }
  current() {
    return this.stack[this.stack.length - 1];
  }
  enter() {
    this.stack.push(new Co());
  }
  exit() {
    const e6 = this.stack.pop(), t2 = this.current();
    for (const [s2, r2] of Array.from(e6.undefinedPrivateNames))
      t2 ? t2.undefinedPrivateNames.has(s2) || t2.undefinedPrivateNames.set(s2, r2) : this.raise(r2, Rn.InvalidPrivateFieldResolution, s2);
  }
  declarePrivateName(e6, t2, s2) {
    const r2 = this.current();
    let i2 = r2.privateNames.has(e6);
    if (3 & t2) {
      const s3 = i2 && r2.loneAccessors.get(e6);
      if (s3) {
        const a2 = 4 & s3, n2 = 4 & t2;
        i2 = (3 & s3) === (3 & t2) || a2 !== n2, i2 || r2.loneAccessors.delete(e6);
      } else
        i2 || r2.loneAccessors.set(e6, t2);
    }
    i2 && this.raise(s2, Rn.PrivateNameRedeclaration, e6), r2.privateNames.add(e6), r2.undefinedPrivateNames.delete(e6);
  }
  usePrivateName(e6, t2) {
    let s2;
    for (s2 of this.stack)
      if (s2.privateNames.has(e6))
        return;
    s2 ? s2.undefinedPrivateNames.set(e6, t2) : this.raise(t2, Rn.InvalidPrivateFieldResolution, e6);
  }
};
var Fo = class {
  constructor(e6 = 0) {
    this.type = void 0, this.type = e6;
  }
  canBeArrowParameterDeclaration() {
    return this.type === 2 || this.type === 1;
  }
  isCertainlyParameterDeclaration() {
    return this.type === 3;
  }
};
var go = class extends Fo {
  constructor(e6) {
    super(e6), this.errors = new Map();
  }
  recordDeclarationError(e6, t2) {
    this.errors.set(e6, t2);
  }
  clearDeclarationError(e6) {
    this.errors.delete(e6);
  }
  iterateErrors(e6) {
    this.errors.forEach(e6);
  }
};
var bo = class {
  constructor(e6) {
    this.stack = [new Fo()], this.raise = e6;
  }
  enter(e6) {
    this.stack.push(e6);
  }
  exit() {
    this.stack.pop();
  }
  recordParameterInitializerError(e6, t2) {
    const { stack: s2 } = this;
    let r2 = s2.length - 1, i2 = s2[r2];
    for (; !i2.isCertainlyParameterDeclaration(); ) {
      if (!i2.canBeArrowParameterDeclaration())
        return;
      i2.recordDeclarationError(e6, t2), i2 = s2[--r2];
    }
    this.raise(e6, t2);
  }
  recordParenthesizedIdentifierError(e6, t2) {
    const { stack: s2 } = this, r2 = s2[s2.length - 1];
    if (r2.isCertainlyParameterDeclaration())
      this.raise(e6, t2);
    else {
      if (!r2.canBeArrowParameterDeclaration())
        return;
      r2.recordDeclarationError(e6, t2);
    }
  }
  recordAsyncArrowParametersError(e6, t2) {
    const { stack: s2 } = this;
    let r2 = s2.length - 1, i2 = s2[r2];
    for (; i2.canBeArrowParameterDeclaration(); )
      i2.type === 2 && i2.recordDeclarationError(e6, t2), i2 = s2[--r2];
  }
  validateAsPattern() {
    const { stack: e6 } = this, t2 = e6[e6.length - 1];
    t2.canBeArrowParameterDeclaration() && t2.iterateErrors((t3, s2) => {
      this.raise(s2, t3);
      let r2 = e6.length - 2, i2 = e6[r2];
      for (; i2.canBeArrowParameterDeclaration(); )
        i2.clearDeclarationError(s2), i2 = e6[--r2];
    });
  }
};
function Po() {
  return new Fo();
}
var To = class {
  constructor() {
    this.stacks = [];
  }
  enter(e6) {
    this.stacks.push(e6);
  }
  exit() {
    this.stacks.pop();
  }
  currentFlags() {
    return this.stacks[this.stacks.length - 1];
  }
  get hasAwait() {
    return (2 & this.currentFlags()) > 0;
  }
  get hasYield() {
    return (1 & this.currentFlags()) > 0;
  }
  get hasReturn() {
    return (4 & this.currentFlags()) > 0;
  }
  get hasIn() {
    return (8 & this.currentFlags()) > 0;
  }
};
function wo(e6, t2) {
  return (e6 ? 2 : 0) | (t2 ? 1 : 0);
}
var So = class {
  constructor() {
    this.shorthandAssign = -1, this.doubleProto = -1, this.optionalParameters = -1;
  }
};
var Bo = class {
  constructor(e6, t2, s2) {
    this.type = "", this.start = t2, this.end = 0, this.loc = new vn(s2), e6 != null && e6.options.ranges && (this.range = [t2, 0]), e6 != null && e6.filename && (this.loc.filename = e6.filename);
  }
};
var No = Bo.prototype;
function Io(e6) {
  const { type: t2, start: s2, end: r2, loc: i2, range: a2, extra: n2, name: o2 } = e6, u2 = Object.create(No);
  return u2.type = t2, u2.start = s2, u2.end = r2, u2.loc = i2, u2.range = a2, u2.extra = n2, u2.name = o2, t2 === "Placeholder" && (u2.expectedNode = e6.expectedNode), u2;
}
function vo(e6) {
  const { type: t2, start: s2, end: r2, loc: i2, range: a2, extra: n2 } = e6;
  if (t2 === "Placeholder")
    return function(e7) {
      return Io(e7);
    }(e6);
  const o2 = Object.create(No);
  return o2.type = "StringLiteral", o2.start = s2, o2.end = r2, o2.loc = i2, o2.range = a2, o2.extra = n2, o2.value = e6.value, o2;
}
No.__clone = function() {
  const e6 = new Bo(), t2 = Object.keys(this);
  for (let s2 = 0, r2 = t2.length; s2 < r2; s2++) {
    const r3 = t2[s2];
    r3 !== "leadingComments" && r3 !== "trailingComments" && r3 !== "innerComments" && (e6[r3] = this[r3]);
  }
  return e6;
};
var ko = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
var Lo = Un({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: "Cannot overwrite reserved type %0.", DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.", EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.", EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.", EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.", EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.", EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.", EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.", EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.", EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.", GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: "Unexpected reserved type %0.", UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.", UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." }, Mn.SyntaxError, "flow");
function Oo(e6) {
  return e6.importKind === "type" || e6.importKind === "typeof";
}
function Mo(e6) {
  return (e6.type === bn.name || !!e6.type.keyword) && e6.value !== "from";
}
var Ro = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
var jo = /\*?\s*@((?:no)?flow)\b/;
var _o = { quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" };
var Uo = /^[\da-fA-F]+$/;
var qo = /^\d+$/;
var $o = Un({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.", MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" }, Mn.SyntaxError, "jsx");
function Ho(e6) {
  return !!e6 && (e6.type === "JSXOpeningFragment" || e6.type === "JSXClosingFragment");
}
function Vo(e6) {
  if (e6.type === "JSXIdentifier")
    return e6.name;
  if (e6.type === "JSXNamespacedName")
    return e6.namespace.name + ":" + e6.name.name;
  if (e6.type === "JSXMemberExpression")
    return Vo(e6.object) + "." + Vo(e6.property);
  throw new Error("Node had unexpected type: " + e6.type);
}
$n.j_oTag = new qn("<tag"), $n.j_cTag = new qn("</tag"), $n.j_expr = new qn("<tag>...</tag>", true), bn.jsxName = new Cn("jsxName"), bn.jsxText = new Cn("jsxText", { beforeExpr: true }), bn.jsxTagStart = new Cn("jsxTagStart", { startsExpr: true }), bn.jsxTagEnd = new Cn("jsxTagEnd"), bn.jsxTagStart.updateContext = (e6) => {
  e6.push($n.j_expr, $n.j_oTag);
};
var zo = class extends ho {
  constructor(...e6) {
    super(...e6), this.types = new Set(), this.enums = new Set(), this.constEnums = new Set(), this.classes = new Set(), this.exportOnlyBindings = new Set();
  }
};
var Wo = class extends co {
  createScope(e6) {
    return new zo(e6);
  }
  declareName(e6, t2, s2) {
    const r2 = this.currentScope();
    if (1024 & t2)
      return this.maybeExportDefined(r2, e6), void r2.exportOnlyBindings.add(e6);
    super.declareName(...arguments), 2 & t2 && (1 & t2 || (this.checkRedeclarationInScope(r2, e6, t2, s2), this.maybeExportDefined(r2, e6)), r2.types.add(e6)), 256 & t2 && r2.enums.add(e6), 512 & t2 && r2.constEnums.add(e6), 128 & t2 && r2.classes.add(e6);
  }
  isRedeclaredInScope(e6, t2, s2) {
    if (e6.enums.has(t2)) {
      if (256 & s2) {
        return !!(512 & s2) !== e6.constEnums.has(t2);
      }
      return true;
    }
    return 128 & s2 && e6.classes.has(t2) ? !!e6.lexical.has(t2) && !!(1 & s2) : !!(2 & s2 && e6.types.has(t2)) || super.isRedeclaredInScope(...arguments);
  }
  checkLocalExport(e6) {
    const t2 = this.scopeStack[0], { name: s2 } = e6;
    t2.types.has(s2) || t2.exportOnlyBindings.has(s2) || super.checkLocalExport(e6);
  }
};
function Go(e6) {
  if (e6 == null)
    throw new Error(`Unexpected ${e6} value.`);
  return e6;
}
function Ko(e6) {
  if (!e6)
    throw new Error("Assert fail");
}
var Xo = Un({ AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.", AbstractPropertyHasInitializer: "Property '%0' cannot have an initializer because it is marked abstract.", AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: "'declare' is not allowed in %0ters.", DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: "Accessibility modifier already seen.", DuplicateModifier: "Duplicate modifier: '%0'.", EmptyHeritageClauseType: "'%0' list cannot be empty.", EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.", IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').", IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.", InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').", ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0." }, Mn.SyntaxError, "typescript");
function Jo(e6) {
  return e6 === "private" || e6 === "public" || e6 === "protected";
}
bn.placeholder = new Cn("%%", { startsExpr: true });
var Yo = Un({ ClassNameIsRequired: "A class name is required." }, Mn.SyntaxError);
function Qo(e6, t2) {
  return e6.some((e7) => Array.isArray(e7) ? e7[0] === t2 : e7 === t2);
}
function Zo(e6, t2, s2) {
  const r2 = e6.find((e7) => Array.isArray(e7) ? e7[0] === t2 : e7 === t2);
  return r2 && Array.isArray(r2) ? r2[1][s2] : null;
}
var eu = ["minimal", "fsharp", "hack", "smart"];
var tu = ["%", "#"];
var su = ["hash", "bar"];
var ru = { estree: (e6) => class extends e6 {
  parseRegExpLiteral({ pattern: e7, flags: t2 }) {
    let s2 = null;
    try {
      s2 = new RegExp(e7, t2);
    } catch (e8) {
    }
    const r2 = this.estreeParseLiteral(s2);
    return r2.regex = { pattern: e7, flags: t2 }, r2;
  }
  parseBigIntLiteral(e7) {
    let t2;
    try {
      t2 = BigInt(e7);
    } catch (e8) {
      t2 = null;
    }
    const s2 = this.estreeParseLiteral(t2);
    return s2.bigint = String(s2.value || e7), s2;
  }
  parseDecimalLiteral(e7) {
    const t2 = this.estreeParseLiteral(null);
    return t2.decimal = String(t2.value || e7), t2;
  }
  estreeParseLiteral(e7) {
    return this.parseLiteral(e7, "Literal");
  }
  parseStringLiteral(e7) {
    return this.estreeParseLiteral(e7);
  }
  parseNumericLiteral(e7) {
    return this.estreeParseLiteral(e7);
  }
  parseNullLiteral() {
    return this.estreeParseLiteral(null);
  }
  parseBooleanLiteral(e7) {
    return this.estreeParseLiteral(e7);
  }
  directiveToStmt(e7) {
    const t2 = e7.value, s2 = this.startNodeAt(e7.start, e7.loc.start), r2 = this.startNodeAt(t2.start, t2.loc.start);
    return r2.value = t2.extra.expressionValue, r2.raw = t2.extra.raw, s2.expression = this.finishNodeAt(r2, "Literal", t2.end, t2.loc.end), s2.directive = t2.extra.raw.slice(1, -1), this.finishNodeAt(s2, "ExpressionStatement", e7.end, e7.loc.end);
  }
  initFunction(e7, t2) {
    super.initFunction(e7, t2), e7.expression = false;
  }
  checkDeclaration(e7) {
    e7 != null && this.isObjectProperty(e7) ? this.checkDeclaration(e7.value) : super.checkDeclaration(e7);
  }
  getObjectOrClassMethodParams(e7) {
    return e7.value.params;
  }
  isValidDirective(e7) {
    var t2;
    return e7.type === "ExpressionStatement" && e7.expression.type === "Literal" && typeof e7.expression.value == "string" && !((t2 = e7.expression.extra) != null && t2.parenthesized);
  }
  stmtToDirective(e7) {
    const t2 = e7.expression.value, s2 = super.stmtToDirective(e7);
    return this.addExtra(s2.value, "expressionValue", t2), s2;
  }
  parseBlockBody(e7, ...t2) {
    super.parseBlockBody(e7, ...t2);
    const s2 = e7.directives.map((e8) => this.directiveToStmt(e8));
    e7.body = s2.concat(e7.body), delete e7.directives;
  }
  pushClassMethod(e7, t2, s2, r2, i2, a2) {
    this.parseMethod(t2, s2, r2, i2, a2, "ClassMethod", true), t2.typeParameters && (t2.value.typeParameters = t2.typeParameters, delete t2.typeParameters), e7.body.push(t2);
  }
  parseMaybePrivateName(...e7) {
    const t2 = super.parseMaybePrivateName(...e7);
    return t2.type === "PrivateName" && this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(t2) : t2;
  }
  convertPrivateNameToPrivateIdentifier(e7) {
    const t2 = super.getPrivateNameSV(e7);
    return delete (e7 = e7).id, e7.name = t2, e7.type = "PrivateIdentifier", e7;
  }
  isPrivateName(e7) {
    return this.getPluginOption("estree", "classFeatures") ? e7.type === "PrivateIdentifier" : super.isPrivateName(e7);
  }
  getPrivateNameSV(e7) {
    return this.getPluginOption("estree", "classFeatures") ? e7.name : super.getPrivateNameSV(e7);
  }
  parseLiteral(e7, t2) {
    const s2 = super.parseLiteral(e7, t2);
    return s2.raw = s2.extra.raw, delete s2.extra, s2;
  }
  parseFunctionBody(e7, t2, s2 = false) {
    super.parseFunctionBody(e7, t2, s2), e7.expression = e7.body.type !== "BlockStatement";
  }
  parseMethod(e7, t2, s2, r2, i2, a2, n2 = false) {
    let o2 = this.startNode();
    return o2.kind = e7.kind, o2 = super.parseMethod(o2, t2, s2, r2, i2, a2, n2), o2.type = "FunctionExpression", delete o2.kind, e7.value = o2, a2 === "ClassPrivateMethod" && (e7.computed = false), a2 = "MethodDefinition", this.finishNode(e7, a2);
  }
  parseClassProperty(...e7) {
    const t2 = super.parseClassProperty(...e7);
    return this.getPluginOption("estree", "classFeatures") && (t2.type = "PropertyDefinition"), t2;
  }
  parseClassPrivateProperty(...e7) {
    const t2 = super.parseClassPrivateProperty(...e7);
    return this.getPluginOption("estree", "classFeatures") && (t2.type = "PropertyDefinition", t2.computed = false), t2;
  }
  parseObjectMethod(e7, t2, s2, r2, i2) {
    const a2 = super.parseObjectMethod(e7, t2, s2, r2, i2);
    return a2 && (a2.type = "Property", a2.kind === "method" && (a2.kind = "init"), a2.shorthand = false), a2;
  }
  parseObjectProperty(e7, t2, s2, r2, i2) {
    const a2 = super.parseObjectProperty(e7, t2, s2, r2, i2);
    return a2 && (a2.kind = "init", a2.type = "Property"), a2;
  }
  isAssignable(e7, t2) {
    return e7 != null && this.isObjectProperty(e7) ? this.isAssignable(e7.value, t2) : super.isAssignable(e7, t2);
  }
  toAssignable(e7, t2 = false) {
    return e7 != null && this.isObjectProperty(e7) ? (this.toAssignable(e7.value, t2), e7) : super.toAssignable(e7, t2);
  }
  toAssignableObjectExpressionProp(e7, ...t2) {
    e7.kind === "get" || e7.kind === "set" ? this.raise(e7.key.start, Rn.PatternHasAccessor) : e7.method ? this.raise(e7.key.start, Rn.PatternHasMethod) : super.toAssignableObjectExpressionProp(e7, ...t2);
  }
  finishCallExpression(e7, t2) {
    if (super.finishCallExpression(e7, t2), e7.callee.type === "Import") {
      var s2;
      if (e7.type = "ImportExpression", e7.source = e7.arguments[0], this.hasPlugin("importAssertions"))
        e7.attributes = (s2 = e7.arguments[1]) != null ? s2 : null;
      delete e7.arguments, delete e7.callee;
    }
    return e7;
  }
  toReferencedArguments(e7) {
    e7.type !== "ImportExpression" && super.toReferencedArguments(e7);
  }
  parseExport(e7) {
    switch (super.parseExport(e7), e7.type) {
      case "ExportAllDeclaration":
        e7.exported = null;
        break;
      case "ExportNamedDeclaration":
        e7.specifiers.length === 1 && e7.specifiers[0].type === "ExportNamespaceSpecifier" && (e7.type = "ExportAllDeclaration", e7.exported = e7.specifiers[0].exported, delete e7.specifiers);
    }
    return e7;
  }
  parseSubscript(e7, t2, s2, r2, i2) {
    const a2 = super.parseSubscript(e7, t2, s2, r2, i2);
    if (i2.optionalChainMember) {
      if (a2.type !== "OptionalMemberExpression" && a2.type !== "OptionalCallExpression" || (a2.type = a2.type.substring(8)), i2.stop) {
        const e8 = this.startNodeAtNode(a2);
        return e8.expression = a2, this.finishNode(e8, "ChainExpression");
      }
    } else
      a2.type !== "MemberExpression" && a2.type !== "CallExpression" || (a2.optional = false);
    return a2;
  }
  hasPropertyAsPrivateName(e7) {
    return e7.type === "ChainExpression" && (e7 = e7.expression), super.hasPropertyAsPrivateName(e7);
  }
  isOptionalChain(e7) {
    return e7.type === "ChainExpression";
  }
  isObjectProperty(e7) {
    return e7.type === "Property" && e7.kind === "init" && !e7.method;
  }
  isObjectMethod(e7) {
    return e7.method || e7.kind === "get" || e7.kind === "set";
  }
}, jsx: (e6) => class extends e6 {
  jsxReadToken() {
    let e7 = "", t2 = this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(this.state.start, $o.UnterminatedJsxContent);
      const s2 = this.input.charCodeAt(this.state.pos);
      switch (s2) {
        case 60:
        case 123:
          return this.state.pos === this.state.start ? s2 === 60 && this.state.exprAllowed ? (++this.state.pos, this.finishToken(bn.jsxTagStart)) : super.getTokenFromCode(s2) : (e7 += this.input.slice(t2, this.state.pos), this.finishToken(bn.jsxText, e7));
        case 38:
          e7 += this.input.slice(t2, this.state.pos), e7 += this.jsxReadEntity(), t2 = this.state.pos;
          break;
        case 62:
        case 125:
        default:
          wn(s2) ? (e7 += this.input.slice(t2, this.state.pos), e7 += this.jsxReadNewLine(true), t2 = this.state.pos) : ++this.state.pos;
      }
    }
  }
  jsxReadNewLine(e7) {
    const t2 = this.input.charCodeAt(this.state.pos);
    let s2;
    return ++this.state.pos, t2 === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, s2 = e7 ? "\n" : "\r\n") : s2 = String.fromCharCode(t2), ++this.state.curLine, this.state.lineStart = this.state.pos, s2;
  }
  jsxReadString(e7) {
    let t2 = "", s2 = ++this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(this.state.start, Rn.UnterminatedString);
      const r2 = this.input.charCodeAt(this.state.pos);
      if (r2 === e7)
        break;
      r2 === 38 ? (t2 += this.input.slice(s2, this.state.pos), t2 += this.jsxReadEntity(), s2 = this.state.pos) : wn(r2) ? (t2 += this.input.slice(s2, this.state.pos), t2 += this.jsxReadNewLine(false), s2 = this.state.pos) : ++this.state.pos;
    }
    return t2 += this.input.slice(s2, this.state.pos++), this.finishToken(bn.string, t2);
  }
  jsxReadEntity() {
    let e7, t2 = "", s2 = 0, r2 = this.input[this.state.pos];
    const i2 = ++this.state.pos;
    for (; this.state.pos < this.length && s2++ < 10; ) {
      if (r2 = this.input[this.state.pos++], r2 === ";") {
        t2[0] === "#" ? t2[1] === "x" ? (t2 = t2.substr(2), Uo.test(t2) && (e7 = String.fromCodePoint(parseInt(t2, 16)))) : (t2 = t2.substr(1), qo.test(t2) && (e7 = String.fromCodePoint(parseInt(t2, 10)))) : e7 = _o[t2];
        break;
      }
      t2 += r2;
    }
    return e7 || (this.state.pos = i2, "&");
  }
  jsxReadWord() {
    let e7;
    const t2 = this.state.pos;
    do {
      e7 = this.input.charCodeAt(++this.state.pos);
    } while (Yn(e7) || e7 === 45);
    return this.finishToken(bn.jsxName, this.input.slice(t2, this.state.pos));
  }
  jsxParseIdentifier() {
    const e7 = this.startNode();
    return this.match(bn.jsxName) ? e7.name = this.state.value : this.state.type.keyword ? e7.name = this.state.type.keyword : this.unexpected(), this.next(), this.finishNode(e7, "JSXIdentifier");
  }
  jsxParseNamespacedName() {
    const e7 = this.state.start, t2 = this.state.startLoc, s2 = this.jsxParseIdentifier();
    if (!this.eat(bn.colon))
      return s2;
    const r2 = this.startNodeAt(e7, t2);
    return r2.namespace = s2, r2.name = this.jsxParseIdentifier(), this.finishNode(r2, "JSXNamespacedName");
  }
  jsxParseElementName() {
    const e7 = this.state.start, t2 = this.state.startLoc;
    let s2 = this.jsxParseNamespacedName();
    if (s2.type === "JSXNamespacedName")
      return s2;
    for (; this.eat(bn.dot); ) {
      const r2 = this.startNodeAt(e7, t2);
      r2.object = s2, r2.property = this.jsxParseIdentifier(), s2 = this.finishNode(r2, "JSXMemberExpression");
    }
    return s2;
  }
  jsxParseAttributeValue() {
    let e7;
    switch (this.state.type) {
      case bn.braceL:
        return e7 = this.startNode(), this.next(), e7 = this.jsxParseExpressionContainer(e7), e7.expression.type === "JSXEmptyExpression" && this.raise(e7.start, $o.AttributeIsEmpty), e7;
      case bn.jsxTagStart:
      case bn.string:
        return this.parseExprAtom();
      default:
        throw this.raise(this.state.start, $o.UnsupportedJsxValue);
    }
  }
  jsxParseEmptyExpression() {
    const e7 = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
    return this.finishNodeAt(e7, "JSXEmptyExpression", this.state.start, this.state.startLoc);
  }
  jsxParseSpreadChild(e7) {
    return this.next(), e7.expression = this.parseExpression(), this.expect(bn.braceR), this.finishNode(e7, "JSXSpreadChild");
  }
  jsxParseExpressionContainer(e7) {
    if (this.match(bn.braceR))
      e7.expression = this.jsxParseEmptyExpression();
    else {
      const t2 = this.parseExpression();
      e7.expression = t2;
    }
    return this.expect(bn.braceR), this.finishNode(e7, "JSXExpressionContainer");
  }
  jsxParseAttribute() {
    const e7 = this.startNode();
    return this.eat(bn.braceL) ? (this.expect(bn.ellipsis), e7.argument = this.parseMaybeAssignAllowIn(), this.expect(bn.braceR), this.finishNode(e7, "JSXSpreadAttribute")) : (e7.name = this.jsxParseNamespacedName(), e7.value = this.eat(bn.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(e7, "JSXAttribute"));
  }
  jsxParseOpeningElementAt(e7, t2) {
    const s2 = this.startNodeAt(e7, t2);
    return this.match(bn.jsxTagEnd) ? (this.expect(bn.jsxTagEnd), this.finishNode(s2, "JSXOpeningFragment")) : (s2.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s2));
  }
  jsxParseOpeningElementAfterName(e7) {
    const t2 = [];
    for (; !this.match(bn.slash) && !this.match(bn.jsxTagEnd); )
      t2.push(this.jsxParseAttribute());
    return e7.attributes = t2, e7.selfClosing = this.eat(bn.slash), this.expect(bn.jsxTagEnd), this.finishNode(e7, "JSXOpeningElement");
  }
  jsxParseClosingElementAt(e7, t2) {
    const s2 = this.startNodeAt(e7, t2);
    return this.match(bn.jsxTagEnd) ? (this.expect(bn.jsxTagEnd), this.finishNode(s2, "JSXClosingFragment")) : (s2.name = this.jsxParseElementName(), this.expect(bn.jsxTagEnd), this.finishNode(s2, "JSXClosingElement"));
  }
  jsxParseElementAt(e7, t2) {
    const s2 = this.startNodeAt(e7, t2), r2 = [], i2 = this.jsxParseOpeningElementAt(e7, t2);
    let a2 = null;
    if (!i2.selfClosing) {
      e:
        for (; ; )
          switch (this.state.type) {
            case bn.jsxTagStart:
              if (e7 = this.state.start, t2 = this.state.startLoc, this.next(), this.eat(bn.slash)) {
                a2 = this.jsxParseClosingElementAt(e7, t2);
                break e;
              }
              r2.push(this.jsxParseElementAt(e7, t2));
              break;
            case bn.jsxText:
              r2.push(this.parseExprAtom());
              break;
            case bn.braceL: {
              const e8 = this.startNode();
              this.next(), this.match(bn.ellipsis) ? r2.push(this.jsxParseSpreadChild(e8)) : r2.push(this.jsxParseExpressionContainer(e8));
              break;
            }
            default:
              throw this.unexpected();
          }
      Ho(i2) && !Ho(a2) ? this.raise(a2.start, $o.MissingClosingTagFragment) : !Ho(i2) && Ho(a2) ? this.raise(a2.start, $o.MissingClosingTagElement, Vo(i2.name)) : Ho(i2) || Ho(a2) || Vo(a2.name) !== Vo(i2.name) && this.raise(a2.start, $o.MissingClosingTagElement, Vo(i2.name));
    }
    if (Ho(i2) ? (s2.openingFragment = i2, s2.closingFragment = a2) : (s2.openingElement = i2, s2.closingElement = a2), s2.children = r2, this.isRelational("<"))
      throw this.raise(this.state.start, $o.UnwrappedAdjacentJSXElements);
    return Ho(i2) ? this.finishNode(s2, "JSXFragment") : this.finishNode(s2, "JSXElement");
  }
  jsxParseElement() {
    const e7 = this.state.start, t2 = this.state.startLoc;
    return this.next(), this.jsxParseElementAt(e7, t2);
  }
  parseExprAtom(e7) {
    return this.match(bn.jsxText) ? this.parseLiteral(this.state.value, "JSXText") : this.match(bn.jsxTagStart) ? this.jsxParseElement() : this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33 ? (this.finishToken(bn.jsxTagStart), this.jsxParseElement()) : super.parseExprAtom(e7);
  }
  createLookaheadState(e7) {
    const t2 = super.createLookaheadState(e7);
    return t2.inPropertyName = e7.inPropertyName, t2;
  }
  getTokenFromCode(e7) {
    if (this.state.inPropertyName)
      return super.getTokenFromCode(e7);
    const t2 = this.curContext();
    if (t2 === $n.j_expr)
      return this.jsxReadToken();
    if (t2 === $n.j_oTag || t2 === $n.j_cTag) {
      if (Jn(e7))
        return this.jsxReadWord();
      if (e7 === 62)
        return ++this.state.pos, this.finishToken(bn.jsxTagEnd);
      if ((e7 === 34 || e7 === 39) && t2 === $n.j_oTag)
        return this.jsxReadString(e7);
    }
    return e7 === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(bn.jsxTagStart)) : super.getTokenFromCode(e7);
  }
  updateContext(e7) {
    super.updateContext(e7);
    const { context: t2, type: s2 } = this.state;
    if (s2 === bn.slash && e7 === bn.jsxTagStart)
      t2.splice(-2, 2, $n.j_cTag), this.state.exprAllowed = false;
    else if (s2 === bn.jsxTagEnd) {
      const s3 = t2.pop();
      s3 === $n.j_oTag && e7 === bn.slash || s3 === $n.j_cTag ? (t2.pop(), this.state.exprAllowed = t2[t2.length - 1] === $n.j_expr) : this.state.exprAllowed = true;
    } else
      !s2.keyword || e7 !== bn.dot && e7 !== bn.questionDot ? this.state.exprAllowed = s2.beforeExpr : this.state.exprAllowed = false;
  }
}, flow: (e6) => class extends e6 {
  constructor(...e7) {
    super(...e7), this.flowPragma = void 0;
  }
  getScopeHandler() {
    return lo;
  }
  shouldParseTypes() {
    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
  }
  shouldParseEnums() {
    return !!this.getPluginOption("flow", "enums");
  }
  finishToken(e7, t2) {
    return e7 !== bn.string && e7 !== bn.semi && e7 !== bn.interpreterDirective && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e7, t2);
  }
  addComment(e7) {
    if (this.flowPragma === void 0) {
      const t2 = jo.exec(e7.value);
      if (t2)
        if (t2[1] === "flow")
          this.flowPragma = "flow";
        else {
          if (t2[1] !== "noflow")
            throw new Error("Unexpected flow pragma");
          this.flowPragma = "noflow";
        }
      else
        ;
    }
    return super.addComment(e7);
  }
  flowParseTypeInitialiser(e7) {
    const t2 = this.state.inType;
    this.state.inType = true, this.expect(e7 || bn.colon);
    const s2 = this.flowParseType();
    return this.state.inType = t2, s2;
  }
  flowParsePredicate() {
    const e7 = this.startNode(), t2 = this.state.start;
    return this.next(), this.expectContextual("checks"), this.state.lastTokStart > t2 + 1 && this.raise(t2, Lo.UnexpectedSpaceBetweenModuloChecks), this.eat(bn.parenL) ? (e7.value = this.parseExpression(), this.expect(bn.parenR), this.finishNode(e7, "DeclaredPredicate")) : this.finishNode(e7, "InferredPredicate");
  }
  flowParseTypeAndPredicateInitialiser() {
    const e7 = this.state.inType;
    this.state.inType = true, this.expect(bn.colon);
    let t2 = null, s2 = null;
    return this.match(bn.modulo) ? (this.state.inType = e7, s2 = this.flowParsePredicate()) : (t2 = this.flowParseType(), this.state.inType = e7, this.match(bn.modulo) && (s2 = this.flowParsePredicate())), [t2, s2];
  }
  flowParseDeclareClass(e7) {
    return this.next(), this.flowParseInterfaceish(e7, true), this.finishNode(e7, "DeclareClass");
  }
  flowParseDeclareFunction(e7) {
    this.next();
    const t2 = e7.id = this.parseIdentifier(), s2 = this.startNode(), r2 = this.startNode();
    this.isRelational("<") ? s2.typeParameters = this.flowParseTypeParameterDeclaration() : s2.typeParameters = null, this.expect(bn.parenL);
    const i2 = this.flowParseFunctionTypeParams();
    return s2.params = i2.params, s2.rest = i2.rest, s2.this = i2._this, this.expect(bn.parenR), [s2.returnType, e7.predicate] = this.flowParseTypeAndPredicateInitialiser(), r2.typeAnnotation = this.finishNode(s2, "FunctionTypeAnnotation"), t2.typeAnnotation = this.finishNode(r2, "TypeAnnotation"), this.resetEndLocation(t2), this.semicolon(), this.scope.declareName(e7.id.name, 2048, e7.id.start), this.finishNode(e7, "DeclareFunction");
  }
  flowParseDeclare(e7, t2) {
    if (this.match(bn._class))
      return this.flowParseDeclareClass(e7);
    if (this.match(bn._function))
      return this.flowParseDeclareFunction(e7);
    if (this.match(bn._var))
      return this.flowParseDeclareVariable(e7);
    if (this.eatContextual("module"))
      return this.match(bn.dot) ? this.flowParseDeclareModuleExports(e7) : (t2 && this.raise(this.state.lastTokStart, Lo.NestedDeclareModule), this.flowParseDeclareModule(e7));
    if (this.isContextual("type"))
      return this.flowParseDeclareTypeAlias(e7);
    if (this.isContextual("opaque"))
      return this.flowParseDeclareOpaqueType(e7);
    if (this.isContextual("interface"))
      return this.flowParseDeclareInterface(e7);
    if (this.match(bn._export))
      return this.flowParseDeclareExportDeclaration(e7, t2);
    throw this.unexpected();
  }
  flowParseDeclareVariable(e7) {
    return this.next(), e7.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e7.id.name, 5, e7.id.start), this.semicolon(), this.finishNode(e7, "DeclareVariable");
  }
  flowParseDeclareModule(e7) {
    this.scope.enter(0), this.match(bn.string) ? e7.id = this.parseExprAtom() : e7.id = this.parseIdentifier();
    const t2 = e7.body = this.startNode(), s2 = t2.body = [];
    for (this.expect(bn.braceL); !this.match(bn.braceR); ) {
      let e8 = this.startNode();
      this.match(bn._import) ? (this.next(), this.isContextual("type") || this.match(bn._typeof) || this.raise(this.state.lastTokStart, Lo.InvalidNonTypeImportInDeclareModule), this.parseImport(e8)) : (this.expectContextual("declare", Lo.UnsupportedStatementInDeclareModule), e8 = this.flowParseDeclare(e8, true)), s2.push(e8);
    }
    this.scope.exit(), this.expect(bn.braceR), this.finishNode(t2, "BlockStatement");
    let r2 = null, i2 = false;
    return s2.forEach((e8) => {
      !function(e9) {
        return e9.type === "DeclareExportAllDeclaration" || e9.type === "DeclareExportDeclaration" && (!e9.declaration || e9.declaration.type !== "TypeAlias" && e9.declaration.type !== "InterfaceDeclaration");
      }(e8) ? e8.type === "DeclareModuleExports" && (i2 && this.raise(e8.start, Lo.DuplicateDeclareModuleExports), r2 === "ES" && this.raise(e8.start, Lo.AmbiguousDeclareModuleKind), r2 = "CommonJS", i2 = true) : (r2 === "CommonJS" && this.raise(e8.start, Lo.AmbiguousDeclareModuleKind), r2 = "ES");
    }), e7.kind = r2 || "CommonJS", this.finishNode(e7, "DeclareModule");
  }
  flowParseDeclareExportDeclaration(e7, t2) {
    if (this.expect(bn._export), this.eat(bn._default))
      return this.match(bn._function) || this.match(bn._class) ? e7.declaration = this.flowParseDeclare(this.startNode()) : (e7.declaration = this.flowParseType(), this.semicolon()), e7.default = true, this.finishNode(e7, "DeclareExportDeclaration");
    if (this.match(bn._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !t2) {
      const e8 = this.state.value, t3 = Ro[e8];
      throw this.raise(this.state.start, Lo.UnsupportedDeclareExportKind, e8, t3);
    }
    if (this.match(bn._var) || this.match(bn._function) || this.match(bn._class) || this.isContextual("opaque"))
      return e7.declaration = this.flowParseDeclare(this.startNode()), e7.default = false, this.finishNode(e7, "DeclareExportDeclaration");
    if (this.match(bn.star) || this.match(bn.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque"))
      return (e7 = this.parseExport(e7)).type === "ExportNamedDeclaration" && (e7.type = "ExportDeclaration", e7.default = false, delete e7.exportKind), e7.type = "Declare" + e7.type, e7;
    throw this.unexpected();
  }
  flowParseDeclareModuleExports(e7) {
    return this.next(), this.expectContextual("exports"), e7.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e7, "DeclareModuleExports");
  }
  flowParseDeclareTypeAlias(e7) {
    return this.next(), this.flowParseTypeAlias(e7), e7.type = "DeclareTypeAlias", e7;
  }
  flowParseDeclareOpaqueType(e7) {
    return this.next(), this.flowParseOpaqueType(e7, true), e7.type = "DeclareOpaqueType", e7;
  }
  flowParseDeclareInterface(e7) {
    return this.next(), this.flowParseInterfaceish(e7), this.finishNode(e7, "DeclareInterface");
  }
  flowParseInterfaceish(e7, t2 = false) {
    if (e7.id = this.flowParseRestrictedIdentifier(!t2, true), this.scope.declareName(e7.id.name, t2 ? 17 : 9, e7.id.start), this.isRelational("<") ? e7.typeParameters = this.flowParseTypeParameterDeclaration() : e7.typeParameters = null, e7.extends = [], e7.implements = [], e7.mixins = [], this.eat(bn._extends))
      do {
        e7.extends.push(this.flowParseInterfaceExtends());
      } while (!t2 && this.eat(bn.comma));
    if (this.isContextual("mixins")) {
      this.next();
      do {
        e7.mixins.push(this.flowParseInterfaceExtends());
      } while (this.eat(bn.comma));
    }
    if (this.isContextual("implements")) {
      this.next();
      do {
        e7.implements.push(this.flowParseInterfaceExtends());
      } while (this.eat(bn.comma));
    }
    e7.body = this.flowParseObjectType({ allowStatic: t2, allowExact: false, allowSpread: false, allowProto: t2, allowInexact: false });
  }
  flowParseInterfaceExtends() {
    const e7 = this.startNode();
    return e7.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational("<") ? e7.typeParameters = this.flowParseTypeParameterInstantiation() : e7.typeParameters = null, this.finishNode(e7, "InterfaceExtends");
  }
  flowParseInterface(e7) {
    return this.flowParseInterfaceish(e7), this.finishNode(e7, "InterfaceDeclaration");
  }
  checkNotUnderscore(e7) {
    e7 === "_" && this.raise(this.state.start, Lo.UnexpectedReservedUnderscore);
  }
  checkReservedType(e7, t2, s2) {
    ko.has(e7) && this.raise(t2, s2 ? Lo.AssignReservedType : Lo.UnexpectedReservedType, e7);
  }
  flowParseRestrictedIdentifier(e7, t2) {
    return this.checkReservedType(this.state.value, this.state.start, t2), this.parseIdentifier(e7);
  }
  flowParseTypeAlias(e7) {
    return e7.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e7.id.name, 9, e7.id.start), this.isRelational("<") ? e7.typeParameters = this.flowParseTypeParameterDeclaration() : e7.typeParameters = null, e7.right = this.flowParseTypeInitialiser(bn.eq), this.semicolon(), this.finishNode(e7, "TypeAlias");
  }
  flowParseOpaqueType(e7, t2) {
    return this.expectContextual("type"), e7.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e7.id.name, 9, e7.id.start), this.isRelational("<") ? e7.typeParameters = this.flowParseTypeParameterDeclaration() : e7.typeParameters = null, e7.supertype = null, this.match(bn.colon) && (e7.supertype = this.flowParseTypeInitialiser(bn.colon)), e7.impltype = null, t2 || (e7.impltype = this.flowParseTypeInitialiser(bn.eq)), this.semicolon(), this.finishNode(e7, "OpaqueType");
  }
  flowParseTypeParameter(e7 = false) {
    const t2 = this.state.start, s2 = this.startNode(), r2 = this.flowParseVariance(), i2 = this.flowParseTypeAnnotatableIdentifier();
    return s2.name = i2.name, s2.variance = r2, s2.bound = i2.typeAnnotation, this.match(bn.eq) ? (this.eat(bn.eq), s2.default = this.flowParseType()) : e7 && this.raise(t2, Lo.MissingTypeParamDefault), this.finishNode(s2, "TypeParameter");
  }
  flowParseTypeParameterDeclaration() {
    const e7 = this.state.inType, t2 = this.startNode();
    t2.params = [], this.state.inType = true, this.isRelational("<") || this.match(bn.jsxTagStart) ? this.next() : this.unexpected();
    let s2 = false;
    do {
      const e8 = this.flowParseTypeParameter(s2);
      t2.params.push(e8), e8.default && (s2 = true), this.isRelational(">") || this.expect(bn.comma);
    } while (!this.isRelational(">"));
    return this.expectRelational(">"), this.state.inType = e7, this.finishNode(t2, "TypeParameterDeclaration");
  }
  flowParseTypeParameterInstantiation() {
    const e7 = this.startNode(), t2 = this.state.inType;
    e7.params = [], this.state.inType = true, this.expectRelational("<");
    const s2 = this.state.noAnonFunctionType;
    for (this.state.noAnonFunctionType = false; !this.isRelational(">"); )
      e7.params.push(this.flowParseType()), this.isRelational(">") || this.expect(bn.comma);
    return this.state.noAnonFunctionType = s2, this.expectRelational(">"), this.state.inType = t2, this.finishNode(e7, "TypeParameterInstantiation");
  }
  flowParseTypeParameterInstantiationCallOrNew() {
    const e7 = this.startNode(), t2 = this.state.inType;
    for (e7.params = [], this.state.inType = true, this.expectRelational("<"); !this.isRelational(">"); )
      e7.params.push(this.flowParseTypeOrImplicitInstantiation()), this.isRelational(">") || this.expect(bn.comma);
    return this.expectRelational(">"), this.state.inType = t2, this.finishNode(e7, "TypeParameterInstantiation");
  }
  flowParseInterfaceType() {
    const e7 = this.startNode();
    if (this.expectContextual("interface"), e7.extends = [], this.eat(bn._extends))
      do {
        e7.extends.push(this.flowParseInterfaceExtends());
      } while (this.eat(bn.comma));
    return e7.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e7, "InterfaceTypeAnnotation");
  }
  flowParseObjectPropertyKey() {
    return this.match(bn.num) || this.match(bn.string) ? this.parseExprAtom() : this.parseIdentifier(true);
  }
  flowParseObjectTypeIndexer(e7, t2, s2) {
    return e7.static = t2, this.lookahead().type === bn.colon ? (e7.id = this.flowParseObjectPropertyKey(), e7.key = this.flowParseTypeInitialiser()) : (e7.id = null, e7.key = this.flowParseType()), this.expect(bn.bracketR), e7.value = this.flowParseTypeInitialiser(), e7.variance = s2, this.finishNode(e7, "ObjectTypeIndexer");
  }
  flowParseObjectTypeInternalSlot(e7, t2) {
    return e7.static = t2, e7.id = this.flowParseObjectPropertyKey(), this.expect(bn.bracketR), this.expect(bn.bracketR), this.isRelational("<") || this.match(bn.parenL) ? (e7.method = true, e7.optional = false, e7.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e7.start, e7.loc.start))) : (e7.method = false, this.eat(bn.question) && (e7.optional = true), e7.value = this.flowParseTypeInitialiser()), this.finishNode(e7, "ObjectTypeInternalSlot");
  }
  flowParseObjectTypeMethodish(e7) {
    for (e7.params = [], e7.rest = null, e7.typeParameters = null, e7.this = null, this.isRelational("<") && (e7.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(bn.parenL), this.match(bn._this) && (e7.this = this.flowParseFunctionTypeParam(true), e7.this.name = null, this.match(bn.parenR) || this.expect(bn.comma)); !this.match(bn.parenR) && !this.match(bn.ellipsis); )
      e7.params.push(this.flowParseFunctionTypeParam(false)), this.match(bn.parenR) || this.expect(bn.comma);
    return this.eat(bn.ellipsis) && (e7.rest = this.flowParseFunctionTypeParam(false)), this.expect(bn.parenR), e7.returnType = this.flowParseTypeInitialiser(), this.finishNode(e7, "FunctionTypeAnnotation");
  }
  flowParseObjectTypeCallProperty(e7, t2) {
    const s2 = this.startNode();
    return e7.static = t2, e7.value = this.flowParseObjectTypeMethodish(s2), this.finishNode(e7, "ObjectTypeCallProperty");
  }
  flowParseObjectType({ allowStatic: e7, allowExact: t2, allowSpread: s2, allowProto: r2, allowInexact: i2 }) {
    const a2 = this.state.inType;
    this.state.inType = true;
    const n2 = this.startNode();
    let o2, u2;
    n2.callProperties = [], n2.properties = [], n2.indexers = [], n2.internalSlots = [];
    let h2 = false;
    for (t2 && this.match(bn.braceBarL) ? (this.expect(bn.braceBarL), o2 = bn.braceBarR, u2 = true) : (this.expect(bn.braceL), o2 = bn.braceR, u2 = false), n2.exact = u2; !this.match(o2); ) {
      let t3 = false, a3 = null, o3 = null;
      const c3 = this.startNode();
      if (r2 && this.isContextual("proto")) {
        const t4 = this.lookahead();
        t4.type !== bn.colon && t4.type !== bn.question && (this.next(), a3 = this.state.start, e7 = false);
      }
      if (e7 && this.isContextual("static")) {
        const e8 = this.lookahead();
        e8.type !== bn.colon && e8.type !== bn.question && (this.next(), t3 = true);
      }
      const p2 = this.flowParseVariance();
      if (this.eat(bn.bracketL))
        a3 != null && this.unexpected(a3), this.eat(bn.bracketL) ? (p2 && this.unexpected(p2.start), n2.internalSlots.push(this.flowParseObjectTypeInternalSlot(c3, t3))) : n2.indexers.push(this.flowParseObjectTypeIndexer(c3, t3, p2));
      else if (this.match(bn.parenL) || this.isRelational("<"))
        a3 != null && this.unexpected(a3), p2 && this.unexpected(p2.start), n2.callProperties.push(this.flowParseObjectTypeCallProperty(c3, t3));
      else {
        let e8 = "init";
        if (this.isContextual("get") || this.isContextual("set")) {
          const t4 = this.lookahead();
          t4.type !== bn.name && t4.type !== bn.string && t4.type !== bn.num || (e8 = this.state.value, this.next());
        }
        const r3 = this.flowParseObjectTypeProperty(c3, t3, a3, p2, e8, s2, i2 != null ? i2 : !u2);
        r3 === null ? (h2 = true, o3 = this.state.lastTokStart) : n2.properties.push(r3);
      }
      this.flowObjectTypeSemicolon(), !o3 || this.match(bn.braceR) || this.match(bn.braceBarR) || this.raise(o3, Lo.UnexpectedExplicitInexactInObject);
    }
    this.expect(o2), s2 && (n2.inexact = h2);
    const c2 = this.finishNode(n2, "ObjectTypeAnnotation");
    return this.state.inType = a2, c2;
  }
  flowParseObjectTypeProperty(e7, t2, s2, r2, i2, a2, n2) {
    if (this.eat(bn.ellipsis)) {
      return this.match(bn.comma) || this.match(bn.semi) || this.match(bn.braceR) || this.match(bn.braceBarR) ? (a2 ? n2 || this.raise(this.state.lastTokStart, Lo.InexactInsideExact) : this.raise(this.state.lastTokStart, Lo.InexactInsideNonObject), r2 && this.raise(r2.start, Lo.InexactVariance), null) : (a2 || this.raise(this.state.lastTokStart, Lo.UnexpectedSpreadType), s2 != null && this.unexpected(s2), r2 && this.raise(r2.start, Lo.SpreadVariance), e7.argument = this.flowParseType(), this.finishNode(e7, "ObjectTypeSpreadProperty"));
    }
    {
      e7.key = this.flowParseObjectPropertyKey(), e7.static = t2, e7.proto = s2 != null, e7.kind = i2;
      let n3 = false;
      return this.isRelational("<") || this.match(bn.parenL) ? (e7.method = true, s2 != null && this.unexpected(s2), r2 && this.unexpected(r2.start), e7.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e7.start, e7.loc.start)), i2 !== "get" && i2 !== "set" || this.flowCheckGetterSetterParams(e7), !a2 && e7.key.name === "constructor" && e7.value.this && this.raise(e7.value.this.start, Lo.ThisParamBannedInConstructor)) : (i2 !== "init" && this.unexpected(), e7.method = false, this.eat(bn.question) && (n3 = true), e7.value = this.flowParseTypeInitialiser(), e7.variance = r2), e7.optional = n3, this.finishNode(e7, "ObjectTypeProperty");
    }
  }
  flowCheckGetterSetterParams(e7) {
    const t2 = e7.kind === "get" ? 0 : 1, s2 = e7.start, r2 = e7.value.params.length + (e7.value.rest ? 1 : 0);
    e7.value.this && this.raise(e7.value.this.start, e7.kind === "get" ? Lo.GetterMayNotHaveThisParam : Lo.SetterMayNotHaveThisParam), r2 !== t2 && (e7.kind === "get" ? this.raise(s2, Rn.BadGetterArity) : this.raise(s2, Rn.BadSetterArity)), e7.kind === "set" && e7.value.rest && this.raise(s2, Rn.BadSetterRestParameter);
  }
  flowObjectTypeSemicolon() {
    this.eat(bn.semi) || this.eat(bn.comma) || this.match(bn.braceR) || this.match(bn.braceBarR) || this.unexpected();
  }
  flowParseQualifiedTypeIdentifier(e7, t2, s2) {
    e7 = e7 || this.state.start, t2 = t2 || this.state.startLoc;
    let r2 = s2 || this.flowParseRestrictedIdentifier(true);
    for (; this.eat(bn.dot); ) {
      const s3 = this.startNodeAt(e7, t2);
      s3.qualification = r2, s3.id = this.flowParseRestrictedIdentifier(true), r2 = this.finishNode(s3, "QualifiedTypeIdentifier");
    }
    return r2;
  }
  flowParseGenericType(e7, t2, s2) {
    const r2 = this.startNodeAt(e7, t2);
    return r2.typeParameters = null, r2.id = this.flowParseQualifiedTypeIdentifier(e7, t2, s2), this.isRelational("<") && (r2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(r2, "GenericTypeAnnotation");
  }
  flowParseTypeofType() {
    const e7 = this.startNode();
    return this.expect(bn._typeof), e7.argument = this.flowParsePrimaryType(), this.finishNode(e7, "TypeofTypeAnnotation");
  }
  flowParseTupleType() {
    const e7 = this.startNode();
    for (e7.types = [], this.expect(bn.bracketL); this.state.pos < this.length && !this.match(bn.bracketR) && (e7.types.push(this.flowParseType()), !this.match(bn.bracketR)); )
      this.expect(bn.comma);
    return this.expect(bn.bracketR), this.finishNode(e7, "TupleTypeAnnotation");
  }
  flowParseFunctionTypeParam(e7) {
    let t2 = null, s2 = false, r2 = null;
    const i2 = this.startNode(), a2 = this.lookahead(), n2 = this.state.type === bn._this;
    return a2.type === bn.colon || a2.type === bn.question ? (n2 && !e7 && this.raise(i2.start, Lo.ThisParamMustBeFirst), t2 = this.parseIdentifier(n2), this.eat(bn.question) && (s2 = true, n2 && this.raise(i2.start, Lo.ThisParamMayNotBeOptional)), r2 = this.flowParseTypeInitialiser()) : r2 = this.flowParseType(), i2.name = t2, i2.optional = s2, i2.typeAnnotation = r2, this.finishNode(i2, "FunctionTypeParam");
  }
  reinterpretTypeAsFunctionTypeParam(e7) {
    const t2 = this.startNodeAt(e7.start, e7.loc.start);
    return t2.name = null, t2.optional = false, t2.typeAnnotation = e7, this.finishNode(t2, "FunctionTypeParam");
  }
  flowParseFunctionTypeParams(e7 = []) {
    let t2 = null, s2 = null;
    for (this.match(bn._this) && (s2 = this.flowParseFunctionTypeParam(true), s2.name = null, this.match(bn.parenR) || this.expect(bn.comma)); !this.match(bn.parenR) && !this.match(bn.ellipsis); )
      e7.push(this.flowParseFunctionTypeParam(false)), this.match(bn.parenR) || this.expect(bn.comma);
    return this.eat(bn.ellipsis) && (t2 = this.flowParseFunctionTypeParam(false)), { params: e7, rest: t2, _this: s2 };
  }
  flowIdentToTypeAnnotation(e7, t2, s2, r2) {
    switch (r2.name) {
      case "any":
        return this.finishNode(s2, "AnyTypeAnnotation");
      case "bool":
      case "boolean":
        return this.finishNode(s2, "BooleanTypeAnnotation");
      case "mixed":
        return this.finishNode(s2, "MixedTypeAnnotation");
      case "empty":
        return this.finishNode(s2, "EmptyTypeAnnotation");
      case "number":
        return this.finishNode(s2, "NumberTypeAnnotation");
      case "string":
        return this.finishNode(s2, "StringTypeAnnotation");
      case "symbol":
        return this.finishNode(s2, "SymbolTypeAnnotation");
      default:
        return this.checkNotUnderscore(r2.name), this.flowParseGenericType(e7, t2, r2);
    }
  }
  flowParsePrimaryType() {
    const e7 = this.state.start, t2 = this.state.startLoc, s2 = this.startNode();
    let r2, i2, a2 = false;
    const n2 = this.state.noAnonFunctionType;
    switch (this.state.type) {
      case bn.name:
        return this.isContextual("interface") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e7, t2, s2, this.parseIdentifier());
      case bn.braceL:
        return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
      case bn.braceBarL:
        return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
      case bn.bracketL:
        return this.state.noAnonFunctionType = false, i2 = this.flowParseTupleType(), this.state.noAnonFunctionType = n2, i2;
      case bn.relational:
        if (this.state.value === "<")
          return s2.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(bn.parenL), r2 = this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(bn.parenR), this.expect(bn.arrow), s2.returnType = this.flowParseType(), this.finishNode(s2, "FunctionTypeAnnotation");
        break;
      case bn.parenL:
        if (this.next(), !this.match(bn.parenR) && !this.match(bn.ellipsis))
          if (this.match(bn.name) || this.match(bn._this)) {
            const e8 = this.lookahead().type;
            a2 = e8 !== bn.question && e8 !== bn.colon;
          } else
            a2 = true;
        if (a2) {
          if (this.state.noAnonFunctionType = false, i2 = this.flowParseType(), this.state.noAnonFunctionType = n2, this.state.noAnonFunctionType || !(this.match(bn.comma) || this.match(bn.parenR) && this.lookahead().type === bn.arrow))
            return this.expect(bn.parenR), i2;
          this.eat(bn.comma);
        }
        return r2 = i2 ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(i2)]) : this.flowParseFunctionTypeParams(), s2.params = r2.params, s2.rest = r2.rest, s2.this = r2._this, this.expect(bn.parenR), this.expect(bn.arrow), s2.returnType = this.flowParseType(), s2.typeParameters = null, this.finishNode(s2, "FunctionTypeAnnotation");
      case bn.string:
        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
      case bn._true:
      case bn._false:
        return s2.value = this.match(bn._true), this.next(), this.finishNode(s2, "BooleanLiteralTypeAnnotation");
      case bn.plusMin:
        if (this.state.value === "-") {
          if (this.next(), this.match(bn.num))
            return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s2);
          if (this.match(bn.bigint))
            return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s2);
          throw this.raise(this.state.start, Lo.UnexpectedSubtractionOperand);
        }
        throw this.unexpected();
      case bn.num:
        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
      case bn.bigint:
        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
      case bn._void:
        return this.next(), this.finishNode(s2, "VoidTypeAnnotation");
      case bn._null:
        return this.next(), this.finishNode(s2, "NullLiteralTypeAnnotation");
      case bn._this:
        return this.next(), this.finishNode(s2, "ThisTypeAnnotation");
      case bn.star:
        return this.next(), this.finishNode(s2, "ExistsTypeAnnotation");
      default:
        if (this.state.type.keyword === "typeof")
          return this.flowParseTypeofType();
        if (this.state.type.keyword) {
          const e8 = this.state.type.label;
          return this.next(), super.createIdentifier(s2, e8);
        }
    }
    throw this.unexpected();
  }
  flowParsePostfixType() {
    const e7 = this.state.start, t2 = this.state.startLoc;
    let s2 = this.flowParsePrimaryType(), r2 = false;
    for (; (this.match(bn.bracketL) || this.match(bn.questionDot)) && !this.canInsertSemicolon(); ) {
      const i2 = this.startNodeAt(e7, t2), a2 = this.eat(bn.questionDot);
      r2 = r2 || a2, this.expect(bn.bracketL), !a2 && this.match(bn.bracketR) ? (i2.elementType = s2, this.next(), s2 = this.finishNode(i2, "ArrayTypeAnnotation")) : (i2.objectType = s2, i2.indexType = this.flowParseType(), this.expect(bn.bracketR), r2 ? (i2.optional = a2, s2 = this.finishNode(i2, "OptionalIndexedAccessType")) : s2 = this.finishNode(i2, "IndexedAccessType"));
    }
    return s2;
  }
  flowParsePrefixType() {
    const e7 = this.startNode();
    return this.eat(bn.question) ? (e7.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e7, "NullableTypeAnnotation")) : this.flowParsePostfixType();
  }
  flowParseAnonFunctionWithoutParens() {
    const e7 = this.flowParsePrefixType();
    if (!this.state.noAnonFunctionType && this.eat(bn.arrow)) {
      const t2 = this.startNodeAt(e7.start, e7.loc.start);
      return t2.params = [this.reinterpretTypeAsFunctionTypeParam(e7)], t2.rest = null, t2.this = null, t2.returnType = this.flowParseType(), t2.typeParameters = null, this.finishNode(t2, "FunctionTypeAnnotation");
    }
    return e7;
  }
  flowParseIntersectionType() {
    const e7 = this.startNode();
    this.eat(bn.bitwiseAND);
    const t2 = this.flowParseAnonFunctionWithoutParens();
    for (e7.types = [t2]; this.eat(bn.bitwiseAND); )
      e7.types.push(this.flowParseAnonFunctionWithoutParens());
    return e7.types.length === 1 ? t2 : this.finishNode(e7, "IntersectionTypeAnnotation");
  }
  flowParseUnionType() {
    const e7 = this.startNode();
    this.eat(bn.bitwiseOR);
    const t2 = this.flowParseIntersectionType();
    for (e7.types = [t2]; this.eat(bn.bitwiseOR); )
      e7.types.push(this.flowParseIntersectionType());
    return e7.types.length === 1 ? t2 : this.finishNode(e7, "UnionTypeAnnotation");
  }
  flowParseType() {
    const e7 = this.state.inType;
    this.state.inType = true;
    const t2 = this.flowParseUnionType();
    return this.state.inType = e7, t2;
  }
  flowParseTypeOrImplicitInstantiation() {
    if (this.state.type === bn.name && this.state.value === "_") {
      const e7 = this.state.start, t2 = this.state.startLoc, s2 = this.parseIdentifier();
      return this.flowParseGenericType(e7, t2, s2);
    }
    return this.flowParseType();
  }
  flowParseTypeAnnotation() {
    const e7 = this.startNode();
    return e7.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e7, "TypeAnnotation");
  }
  flowParseTypeAnnotatableIdentifier(e7) {
    const t2 = e7 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
    return this.match(bn.colon) && (t2.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t2)), t2;
  }
  typeCastToParameter(e7) {
    return e7.expression.typeAnnotation = e7.typeAnnotation, this.resetEndLocation(e7.expression, e7.typeAnnotation.end, e7.typeAnnotation.loc.end), e7.expression;
  }
  flowParseVariance() {
    let e7 = null;
    return this.match(bn.plusMin) && (e7 = this.startNode(), this.state.value === "+" ? e7.kind = "plus" : e7.kind = "minus", this.next(), this.finishNode(e7, "Variance")), e7;
  }
  parseFunctionBody(e7, t2, s2 = false) {
    return t2 ? this.forwardNoArrowParamsConversionAt(e7, () => super.parseFunctionBody(e7, true, s2)) : super.parseFunctionBody(e7, false, s2);
  }
  parseFunctionBodyAndFinish(e7, t2, s2 = false) {
    if (this.match(bn.colon)) {
      const t3 = this.startNode();
      [t3.typeAnnotation, e7.predicate] = this.flowParseTypeAndPredicateInitialiser(), e7.returnType = t3.typeAnnotation ? this.finishNode(t3, "TypeAnnotation") : null;
    }
    super.parseFunctionBodyAndFinish(e7, t2, s2);
  }
  parseStatement(e7, t2) {
    if (this.state.strict && this.match(bn.name) && this.state.value === "interface") {
      const e8 = this.lookahead();
      if (e8.type === bn.name || oo(e8.value)) {
        const e9 = this.startNode();
        return this.next(), this.flowParseInterface(e9);
      }
    } else if (this.shouldParseEnums() && this.isContextual("enum")) {
      const e8 = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(e8);
    }
    const s2 = super.parseStatement(e7, t2);
    return this.flowPragma !== void 0 || this.isValidDirective(s2) || (this.flowPragma = null), s2;
  }
  parseExpressionStatement(e7, t2) {
    if (t2.type === "Identifier") {
      if (t2.name === "declare") {
        if (this.match(bn._class) || this.match(bn.name) || this.match(bn._function) || this.match(bn._var) || this.match(bn._export))
          return this.flowParseDeclare(e7);
      } else if (this.match(bn.name)) {
        if (t2.name === "interface")
          return this.flowParseInterface(e7);
        if (t2.name === "type")
          return this.flowParseTypeAlias(e7);
        if (t2.name === "opaque")
          return this.flowParseOpaqueType(e7, false);
      }
    }
    return super.parseExpressionStatement(e7, t2);
  }
  shouldParseExportDeclaration() {
    return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
  }
  isExportDefaultSpecifier() {
    return (!this.match(bn.name) || !(this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) && super.isExportDefaultSpecifier();
  }
  parseExportDefaultExpression() {
    if (this.shouldParseEnums() && this.isContextual("enum")) {
      const e7 = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(e7);
    }
    return super.parseExportDefaultExpression();
  }
  parseConditional(e7, t2, s2, r2) {
    if (!this.match(bn.question))
      return e7;
    if (this.state.maybeInArrowParameters) {
      const t3 = this.lookaheadCharCode();
      if (t3 === 44 || t3 === 61 || t3 === 58 || t3 === 41)
        return this.setOptionalParametersError(r2), e7;
    }
    this.expect(bn.question);
    const i2 = this.state.clone(), a2 = this.state.noArrowAt, n2 = this.startNodeAt(t2, s2);
    let { consequent: o2, failed: u2 } = this.tryParseConditionalConsequent(), [h2, c2] = this.getArrowLikeExpressions(o2);
    if (u2 || c2.length > 0) {
      const e8 = [...a2];
      if (c2.length > 0) {
        this.state = i2, this.state.noArrowAt = e8;
        for (let t3 = 0; t3 < c2.length; t3++)
          e8.push(c2[t3].start);
        ({ consequent: o2, failed: u2 } = this.tryParseConditionalConsequent()), [h2, c2] = this.getArrowLikeExpressions(o2);
      }
      u2 && h2.length > 1 && this.raise(i2.start, Lo.AmbiguousConditionalArrow), u2 && h2.length === 1 && (this.state = i2, e8.push(h2[0].start), this.state.noArrowAt = e8, { consequent: o2, failed: u2 } = this.tryParseConditionalConsequent());
    }
    return this.getArrowLikeExpressions(o2, true), this.state.noArrowAt = a2, this.expect(bn.colon), n2.test = e7, n2.consequent = o2, n2.alternate = this.forwardNoArrowParamsConversionAt(n2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(n2, "ConditionalExpression");
  }
  tryParseConditionalConsequent() {
    this.state.noArrowParamsConversionAt.push(this.state.start);
    const e7 = this.parseMaybeAssignAllowIn(), t2 = !this.match(bn.colon);
    return this.state.noArrowParamsConversionAt.pop(), { consequent: e7, failed: t2 };
  }
  getArrowLikeExpressions(e7, t2) {
    const s2 = [e7], r2 = [];
    for (; s2.length !== 0; ) {
      const e8 = s2.pop();
      e8.type === "ArrowFunctionExpression" ? (e8.typeParameters || !e8.returnType ? this.finishArrowValidation(e8) : r2.push(e8), s2.push(e8.body)) : e8.type === "ConditionalExpression" && (s2.push(e8.consequent), s2.push(e8.alternate));
    }
    return t2 ? (r2.forEach((e8) => this.finishArrowValidation(e8)), [r2, []]) : function(e8, t3) {
      const s3 = [], r3 = [];
      for (let i2 = 0; i2 < e8.length; i2++)
        (t3(e8[i2], i2, e8) ? s3 : r3).push(e8[i2]);
      return [s3, r3];
    }(r2, (e8) => e8.params.every((e9) => this.isAssignable(e9, true)));
  }
  finishArrowValidation(e7) {
    var t2;
    this.toAssignableList(e7.params, (t2 = e7.extra) == null ? void 0 : t2.trailingComma, false), this.scope.enter(6), super.checkParams(e7, false, true), this.scope.exit();
  }
  forwardNoArrowParamsConversionAt(e7, t2) {
    let s2;
    return this.state.noArrowParamsConversionAt.indexOf(e7.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), s2 = t2(), this.state.noArrowParamsConversionAt.pop()) : s2 = t2(), s2;
  }
  parseParenItem(e7, t2, s2) {
    if (e7 = super.parseParenItem(e7, t2, s2), this.eat(bn.question) && (e7.optional = true, this.resetEndLocation(e7)), this.match(bn.colon)) {
      const r2 = this.startNodeAt(t2, s2);
      return r2.expression = e7, r2.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r2, "TypeCastExpression");
    }
    return e7;
  }
  assertModuleNodeAllowed(e7) {
    e7.type === "ImportDeclaration" && (e7.importKind === "type" || e7.importKind === "typeof") || e7.type === "ExportNamedDeclaration" && e7.exportKind === "type" || e7.type === "ExportAllDeclaration" && e7.exportKind === "type" || super.assertModuleNodeAllowed(e7);
  }
  parseExport(e7) {
    const t2 = super.parseExport(e7);
    return t2.type !== "ExportNamedDeclaration" && t2.type !== "ExportAllDeclaration" || (t2.exportKind = t2.exportKind || "value"), t2;
  }
  parseExportDeclaration(e7) {
    if (this.isContextual("type")) {
      e7.exportKind = "type";
      const t2 = this.startNode();
      return this.next(), this.match(bn.braceL) ? (e7.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(e7), null) : this.flowParseTypeAlias(t2);
    }
    if (this.isContextual("opaque")) {
      e7.exportKind = "type";
      const t2 = this.startNode();
      return this.next(), this.flowParseOpaqueType(t2, false);
    }
    if (this.isContextual("interface")) {
      e7.exportKind = "type";
      const t2 = this.startNode();
      return this.next(), this.flowParseInterface(t2);
    }
    if (this.shouldParseEnums() && this.isContextual("enum")) {
      e7.exportKind = "value";
      const t2 = this.startNode();
      return this.next(), this.flowParseEnumDeclaration(t2);
    }
    return super.parseExportDeclaration(e7);
  }
  eatExportStar(e7) {
    return !!super.eatExportStar(...arguments) || !(!this.isContextual("type") || this.lookahead().type !== bn.star) && (e7.exportKind = "type", this.next(), this.next(), true);
  }
  maybeParseExportNamespaceSpecifier(e7) {
    const t2 = this.state.start, s2 = super.maybeParseExportNamespaceSpecifier(e7);
    return s2 && e7.exportKind === "type" && this.unexpected(t2), s2;
  }
  parseClassId(e7, t2, s2) {
    super.parseClassId(e7, t2, s2), this.isRelational("<") && (e7.typeParameters = this.flowParseTypeParameterDeclaration());
  }
  parseClassMember(e7, t2, s2) {
    const r2 = this.state.start;
    if (this.isContextual("declare")) {
      if (this.parseClassMemberFromModifier(e7, t2))
        return;
      t2.declare = true;
    }
    super.parseClassMember(e7, t2, s2), t2.declare && (t2.type !== "ClassProperty" && t2.type !== "ClassPrivateProperty" && t2.type !== "PropertyDefinition" ? this.raise(r2, Lo.DeclareClassElement) : t2.value && this.raise(t2.value.start, Lo.DeclareClassFieldInitializer));
  }
  isIterator(e7) {
    return e7 === "iterator" || e7 === "asyncIterator";
  }
  readIterator() {
    const e7 = super.readWord1(), t2 = "@@" + e7;
    this.isIterator(e7) && this.state.inType || this.raise(this.state.pos, Rn.InvalidIdentifier, t2), this.finishToken(bn.name, t2);
  }
  getTokenFromCode(e7) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    return e7 === 123 && t2 === 124 ? this.finishOp(bn.braceBarL, 2) : !this.state.inType || e7 !== 62 && e7 !== 60 ? this.state.inType && e7 === 63 ? t2 === 46 ? this.finishOp(bn.questionDot, 2) : this.finishOp(bn.question, 1) : function(e8, t3) {
      return e8 === 64 && t3 === 64;
    }(e7, t2) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e7) : this.finishOp(bn.relational, 1);
  }
  isAssignable(e7, t2) {
    return e7.type === "TypeCastExpression" ? this.isAssignable(e7.expression, t2) : super.isAssignable(e7, t2);
  }
  toAssignable(e7, t2 = false) {
    return e7.type === "TypeCastExpression" ? super.toAssignable(this.typeCastToParameter(e7), t2) : super.toAssignable(e7, t2);
  }
  toAssignableList(e7, t2, s2) {
    for (let t3 = 0; t3 < e7.length; t3++) {
      const s3 = e7[t3];
      (s3 == null ? void 0 : s3.type) === "TypeCastExpression" && (e7[t3] = this.typeCastToParameter(s3));
    }
    return super.toAssignableList(e7, t2, s2);
  }
  toReferencedList(e7, t2) {
    for (let r2 = 0; r2 < e7.length; r2++) {
      var s2;
      const i2 = e7[r2];
      !i2 || i2.type !== "TypeCastExpression" || (s2 = i2.extra) != null && s2.parenthesized || !(e7.length > 1) && t2 || this.raise(i2.typeAnnotation.start, Lo.TypeCastInPattern);
    }
    return e7;
  }
  parseArrayLike(e7, t2, s2, r2) {
    const i2 = super.parseArrayLike(e7, t2, s2, r2);
    return t2 && !this.state.maybeInArrowParameters && this.toReferencedList(i2.elements), i2;
  }
  checkLVal(e7, ...t2) {
    if (e7.type !== "TypeCastExpression")
      return super.checkLVal(e7, ...t2);
  }
  parseClassProperty(e7) {
    return this.match(bn.colon) && (e7.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e7);
  }
  parseClassPrivateProperty(e7) {
    return this.match(bn.colon) && (e7.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e7);
  }
  isClassMethod() {
    return this.isRelational("<") || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(bn.colon) || super.isClassProperty();
  }
  isNonstaticConstructor(e7) {
    return !this.match(bn.colon) && super.isNonstaticConstructor(e7);
  }
  pushClassMethod(e7, t2, s2, r2, i2, a2) {
    if (t2.variance && this.unexpected(t2.variance.start), delete t2.variance, this.isRelational("<") && (t2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e7, t2, s2, r2, i2, a2), t2.params && i2) {
      const e8 = t2.params;
      e8.length > 0 && this.isThisParam(e8[0]) && this.raise(t2.start, Lo.ThisParamBannedInConstructor);
    } else if (t2.type === "MethodDefinition" && i2 && t2.value.params) {
      const e8 = t2.value.params;
      e8.length > 0 && this.isThisParam(e8[0]) && this.raise(t2.start, Lo.ThisParamBannedInConstructor);
    }
  }
  pushClassPrivateMethod(e7, t2, s2, r2) {
    t2.variance && this.unexpected(t2.variance.start), delete t2.variance, this.isRelational("<") && (t2.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e7, t2, s2, r2);
  }
  parseClassSuper(e7) {
    if (super.parseClassSuper(e7), e7.superClass && this.isRelational("<") && (e7.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual("implements")) {
      this.next();
      const t2 = e7.implements = [];
      do {
        const e8 = this.startNode();
        e8.id = this.flowParseRestrictedIdentifier(true), this.isRelational("<") ? e8.typeParameters = this.flowParseTypeParameterInstantiation() : e8.typeParameters = null, t2.push(this.finishNode(e8, "ClassImplements"));
      } while (this.eat(bn.comma));
    }
  }
  checkGetterSetterParams(e7) {
    super.checkGetterSetterParams(e7);
    const t2 = this.getObjectOrClassMethodParams(e7);
    if (t2.length > 0) {
      const s2 = t2[0];
      this.isThisParam(s2) && e7.kind === "get" ? this.raise(s2.start, Lo.GetterMayNotHaveThisParam) : this.isThisParam(s2) && this.raise(s2.start, Lo.SetterMayNotHaveThisParam);
    }
  }
  parsePropertyName(e7, t2) {
    const s2 = this.flowParseVariance(), r2 = super.parsePropertyName(e7, t2);
    return e7.variance = s2, r2;
  }
  parseObjPropValue(e7, t2, s2, r2, i2, a2, n2, o2) {
    let u2;
    e7.variance && this.unexpected(e7.variance.start), delete e7.variance, this.isRelational("<") && !n2 && (u2 = this.flowParseTypeParameterDeclaration(), this.match(bn.parenL) || this.unexpected()), super.parseObjPropValue(e7, t2, s2, r2, i2, a2, n2, o2), u2 && ((e7.value || e7).typeParameters = u2);
  }
  parseAssignableListItemTypes(e7) {
    return this.eat(bn.question) && (e7.type !== "Identifier" && this.raise(e7.start, Lo.PatternIsOptional), this.isThisParam(e7) && this.raise(e7.start, Lo.ThisParamMayNotBeOptional), e7.optional = true), this.match(bn.colon) ? e7.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e7) && this.raise(e7.start, Lo.ThisParamAnnotationRequired), this.match(bn.eq) && this.isThisParam(e7) && this.raise(e7.start, Lo.ThisParamNoDefault), this.resetEndLocation(e7), e7;
  }
  parseMaybeDefault(e7, t2, s2) {
    const r2 = super.parseMaybeDefault(e7, t2, s2);
    return r2.type === "AssignmentPattern" && r2.typeAnnotation && r2.right.start < r2.typeAnnotation.start && this.raise(r2.typeAnnotation.start, Lo.TypeBeforeInitializer), r2;
  }
  shouldParseDefaultImport(e7) {
    return Oo(e7) ? Mo(this.state) : super.shouldParseDefaultImport(e7);
  }
  parseImportSpecifierLocal(e7, t2, s2, r2) {
    t2.local = Oo(e7) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), this.checkLVal(t2.local, r2, 9), e7.specifiers.push(this.finishNode(t2, s2));
  }
  maybeParseDefaultImportSpecifier(e7) {
    e7.importKind = "value";
    let t2 = null;
    if (this.match(bn._typeof) ? t2 = "typeof" : this.isContextual("type") && (t2 = "type"), t2) {
      const s2 = this.lookahead();
      t2 === "type" && s2.type === bn.star && this.unexpected(s2.start), (Mo(s2) || s2.type === bn.braceL || s2.type === bn.star) && (this.next(), e7.importKind = t2);
    }
    return super.maybeParseDefaultImportSpecifier(e7);
  }
  parseImportSpecifier(e7) {
    const t2 = this.startNode(), s2 = this.match(bn.string), r2 = this.parseModuleExportName();
    let i2 = null;
    r2.type === "Identifier" && (r2.name === "type" ? i2 = "type" : r2.name === "typeof" && (i2 = "typeof"));
    let a2 = false;
    if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
      const e8 = this.parseIdentifier(true);
      i2 === null || this.match(bn.name) || this.state.type.keyword ? (t2.imported = r2, t2.importKind = null, t2.local = this.parseIdentifier()) : (t2.imported = e8, t2.importKind = i2, t2.local = Io(e8));
    } else {
      if (i2 !== null && (this.match(bn.name) || this.state.type.keyword))
        t2.imported = this.parseIdentifier(true), t2.importKind = i2;
      else {
        if (s2)
          throw this.raise(t2.start, Rn.ImportBindingIsString, r2.value);
        t2.imported = r2, t2.importKind = null;
      }
      this.eatContextual("as") ? t2.local = this.parseIdentifier() : (a2 = true, t2.local = Io(t2.imported));
    }
    const n2 = Oo(e7), o2 = Oo(t2);
    n2 && o2 && this.raise(t2.start, Lo.ImportTypeShorthandOnlyInPureImport), (n2 || o2) && this.checkReservedType(t2.local.name, t2.local.start, true), !a2 || n2 || o2 || this.checkReservedWord(t2.local.name, t2.start, true, true), this.checkLVal(t2.local, "import specifier", 9), e7.specifiers.push(this.finishNode(t2, "ImportSpecifier"));
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case bn._this:
        return this.parseIdentifier(true);
      default:
        return super.parseBindingAtom();
    }
  }
  parseFunctionParams(e7, t2) {
    const s2 = e7.kind;
    s2 !== "get" && s2 !== "set" && this.isRelational("<") && (e7.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e7, t2);
  }
  parseVarId(e7, t2) {
    super.parseVarId(e7, t2), this.match(bn.colon) && (e7.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e7.id));
  }
  parseAsyncArrowFromCallExpression(e7, t2) {
    if (this.match(bn.colon)) {
      const t3 = this.state.noAnonFunctionType;
      this.state.noAnonFunctionType = true, e7.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = t3;
    }
    return super.parseAsyncArrowFromCallExpression(e7, t2);
  }
  shouldParseAsyncArrow() {
    return this.match(bn.colon) || super.shouldParseAsyncArrow();
  }
  parseMaybeAssign(e7, t2) {
    var s2;
    let r2, i2 = null;
    if (this.hasPlugin("jsx") && (this.match(bn.jsxTagStart) || this.isRelational("<"))) {
      if (i2 = this.state.clone(), r2 = this.tryParse(() => super.parseMaybeAssign(e7, t2), i2), !r2.error)
        return r2.node;
      const { context: s3 } = this.state, a3 = s3[s3.length - 1];
      a3 === $n.j_oTag ? s3.length -= 2 : a3 === $n.j_expr && (s3.length -= 1);
    }
    if ((s2 = r2) != null && s2.error || this.isRelational("<")) {
      var a2, n2;
      let s3;
      i2 = i2 || this.state.clone();
      const o2 = this.tryParse((r3) => {
        var i3;
        s3 = this.flowParseTypeParameterDeclaration();
        const a3 = this.forwardNoArrowParamsConversionAt(s3, () => {
          const r4 = super.parseMaybeAssign(e7, t2);
          return this.resetStartLocationFromNode(r4, s3), r4;
        });
        (i3 = a3.extra) != null && i3.parenthesized && r3();
        const n3 = this.maybeUnwrapTypeCastExpression(a3);
        return n3.type !== "ArrowFunctionExpression" && r3(), n3.typeParameters = s3, this.resetStartLocationFromNode(n3, s3), a3;
      }, i2);
      let u2 = null;
      if (o2.node && this.maybeUnwrapTypeCastExpression(o2.node).type === "ArrowFunctionExpression") {
        if (!o2.error && !o2.aborted)
          return o2.node.async && this.raise(s3.start, Lo.UnexpectedTypeParameterBeforeAsyncArrowFunction), o2.node;
        u2 = o2.node;
      }
      if ((a2 = r2) != null && a2.node)
        return this.state = r2.failState, r2.node;
      if (u2)
        return this.state = o2.failState, u2;
      if ((n2 = r2) != null && n2.thrown)
        throw r2.error;
      if (o2.thrown)
        throw o2.error;
      throw this.raise(s3.start, Lo.UnexpectedTokenAfterTypeParameter);
    }
    return super.parseMaybeAssign(e7, t2);
  }
  parseArrow(e7) {
    if (this.match(bn.colon)) {
      const t2 = this.tryParse(() => {
        const t3 = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        const s2 = this.startNode();
        return [s2.typeAnnotation, e7.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = t3, this.canInsertSemicolon() && this.unexpected(), this.match(bn.arrow) || this.unexpected(), s2;
      });
      if (t2.thrown)
        return null;
      t2.error && (this.state = t2.failState), e7.returnType = t2.node.typeAnnotation ? this.finishNode(t2.node, "TypeAnnotation") : null;
    }
    return super.parseArrow(e7);
  }
  shouldParseArrow(e7) {
    return this.match(bn.colon) || super.shouldParseArrow(e7);
  }
  setArrowFunctionParameters(e7, t2) {
    this.state.noArrowParamsConversionAt.indexOf(e7.start) !== -1 ? e7.params = t2 : super.setArrowFunctionParameters(e7, t2);
  }
  checkParams(e7, t2, s2) {
    if (!s2 || this.state.noArrowParamsConversionAt.indexOf(e7.start) === -1) {
      for (let t3 = 0; t3 < e7.params.length; t3++)
        this.isThisParam(e7.params[t3]) && t3 > 0 && this.raise(e7.params[t3].start, Lo.ThisParamMustBeFirst);
      return super.checkParams(...arguments);
    }
  }
  parseParenAndDistinguishExpression(e7) {
    return super.parseParenAndDistinguishExpression(e7 && this.state.noArrowAt.indexOf(this.state.start) === -1);
  }
  parseSubscripts(e7, t2, s2, r2) {
    if (e7.type === "Identifier" && e7.name === "async" && this.state.noArrowAt.indexOf(t2) !== -1) {
      this.next();
      const r3 = this.startNodeAt(t2, s2);
      r3.callee = e7, r3.arguments = this.parseCallExpressionArguments(bn.parenR, false), e7 = this.finishNode(r3, "CallExpression");
    } else if (e7.type === "Identifier" && e7.name === "async" && this.isRelational("<")) {
      const i2 = this.state.clone(), a2 = this.tryParse((e8) => this.parseAsyncArrowWithTypeParameters(t2, s2) || e8(), i2);
      if (!a2.error && !a2.aborted)
        return a2.node;
      const n2 = this.tryParse(() => super.parseSubscripts(e7, t2, s2, r2), i2);
      if (n2.node && !n2.error)
        return n2.node;
      if (a2.node)
        return this.state = a2.failState, a2.node;
      if (n2.node)
        return this.state = n2.failState, n2.node;
      throw a2.error || n2.error;
    }
    return super.parseSubscripts(e7, t2, s2, r2);
  }
  parseSubscript(e7, t2, s2, r2, i2) {
    if (this.match(bn.questionDot) && this.isLookaheadToken_lt()) {
      if (i2.optionalChainMember = true, r2)
        return i2.stop = true, e7;
      this.next();
      const a2 = this.startNodeAt(t2, s2);
      return a2.callee = e7, a2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(bn.parenL), a2.arguments = this.parseCallExpressionArguments(bn.parenR, false), a2.optional = true, this.finishCallExpression(a2, true);
    }
    if (!r2 && this.shouldParseTypes() && this.isRelational("<")) {
      const r3 = this.startNodeAt(t2, s2);
      r3.callee = e7;
      const a2 = this.tryParse(() => (r3.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(bn.parenL), r3.arguments = this.parseCallExpressionArguments(bn.parenR, false), i2.optionalChainMember && (r3.optional = false), this.finishCallExpression(r3, i2.optionalChainMember)));
      if (a2.node)
        return a2.error && (this.state = a2.failState), a2.node;
    }
    return super.parseSubscript(e7, t2, s2, r2, i2);
  }
  parseNewArguments(e7) {
    let t2 = null;
    this.shouldParseTypes() && this.isRelational("<") && (t2 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e7.typeArguments = t2, super.parseNewArguments(e7);
  }
  parseAsyncArrowWithTypeParameters(e7, t2) {
    const s2 = this.startNodeAt(e7, t2);
    if (this.parseFunctionParams(s2), this.parseArrow(s2))
      return this.parseArrowExpression(s2, void 0, true);
  }
  readToken_mult_modulo(e7) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    if (e7 === 42 && t2 === 47 && this.state.hasFlowComment)
      return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
    super.readToken_mult_modulo(e7);
  }
  readToken_pipe_amp(e7) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    e7 !== 124 || t2 !== 125 ? super.readToken_pipe_amp(e7) : this.finishOp(bn.braceBarR, 2);
  }
  parseTopLevel(e7, t2) {
    const s2 = super.parseTopLevel(e7, t2);
    return this.state.hasFlowComment && this.raise(this.state.pos, Lo.UnterminatedFlowComment), s2;
  }
  skipBlockComment() {
    if (this.hasPlugin("flowComments") && this.skipFlowComment())
      return this.state.hasFlowComment && this.unexpected(null, Lo.NestedFlowComment), this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = true);
    if (!this.state.hasFlowComment)
      return super.skipBlockComment();
    {
      const e7 = this.input.indexOf("*-/", this.state.pos += 2);
      if (e7 === -1)
        throw this.raise(this.state.pos - 2, Rn.UnterminatedComment);
      this.state.pos = e7 + 3;
    }
  }
  skipFlowComment() {
    const { pos: e7 } = this.state;
    let t2 = 2;
    for (; [32, 9].includes(this.input.charCodeAt(e7 + t2)); )
      t2++;
    const s2 = this.input.charCodeAt(t2 + e7), r2 = this.input.charCodeAt(t2 + e7 + 1);
    return s2 === 58 && r2 === 58 ? t2 + 2 : this.input.slice(t2 + e7, t2 + e7 + 12) === "flow-include" ? t2 + 12 : s2 === 58 && r2 !== 58 && t2;
  }
  hasFlowCommentCompletion() {
    if (this.input.indexOf("*/", this.state.pos) === -1)
      throw this.raise(this.state.pos, Rn.UnterminatedComment);
  }
  flowEnumErrorBooleanMemberNotInitialized(e7, { enumName: t2, memberName: s2 }) {
    this.raise(e7, Lo.EnumBooleanMemberNotInitialized, s2, t2);
  }
  flowEnumErrorInvalidMemberName(e7, { enumName: t2, memberName: s2 }) {
    const r2 = s2[0].toUpperCase() + s2.slice(1);
    this.raise(e7, Lo.EnumInvalidMemberName, s2, r2, t2);
  }
  flowEnumErrorDuplicateMemberName(e7, { enumName: t2, memberName: s2 }) {
    this.raise(e7, Lo.EnumDuplicateMemberName, s2, t2);
  }
  flowEnumErrorInconsistentMemberValues(e7, { enumName: t2 }) {
    this.raise(e7, Lo.EnumInconsistentMemberValues, t2);
  }
  flowEnumErrorInvalidExplicitType(e7, { enumName: t2, suppliedType: s2 }) {
    return this.raise(e7, s2 === null ? Lo.EnumInvalidExplicitTypeUnknownSupplied : Lo.EnumInvalidExplicitType, t2, s2);
  }
  flowEnumErrorInvalidMemberInitializer(e7, { enumName: t2, explicitType: s2, memberName: r2 }) {
    let i2 = null;
    switch (s2) {
      case "boolean":
      case "number":
      case "string":
        i2 = Lo.EnumInvalidMemberInitializerPrimaryType;
        break;
      case "symbol":
        i2 = Lo.EnumInvalidMemberInitializerSymbolType;
        break;
      default:
        i2 = Lo.EnumInvalidMemberInitializerUnknownType;
    }
    return this.raise(e7, i2, t2, r2, s2);
  }
  flowEnumErrorNumberMemberNotInitialized(e7, { enumName: t2, memberName: s2 }) {
    this.raise(e7, Lo.EnumNumberMemberNotInitialized, t2, s2);
  }
  flowEnumErrorStringMemberInconsistentlyInitailized(e7, { enumName: t2 }) {
    this.raise(e7, Lo.EnumStringMemberInconsistentlyInitailized, t2);
  }
  flowEnumMemberInit() {
    const e7 = this.state.start, t2 = () => this.match(bn.comma) || this.match(bn.braceR);
    switch (this.state.type) {
      case bn.num: {
        const s2 = this.parseNumericLiteral(this.state.value);
        return t2() ? { type: "number", pos: s2.start, value: s2 } : { type: "invalid", pos: e7 };
      }
      case bn.string: {
        const s2 = this.parseStringLiteral(this.state.value);
        return t2() ? { type: "string", pos: s2.start, value: s2 } : { type: "invalid", pos: e7 };
      }
      case bn._true:
      case bn._false: {
        const s2 = this.parseBooleanLiteral(this.match(bn._true));
        return t2() ? { type: "boolean", pos: s2.start, value: s2 } : { type: "invalid", pos: e7 };
      }
      default:
        return { type: "invalid", pos: e7 };
    }
  }
  flowEnumMemberRaw() {
    const e7 = this.state.start;
    return { id: this.parseIdentifier(true), init: this.eat(bn.eq) ? this.flowEnumMemberInit() : { type: "none", pos: e7 } };
  }
  flowEnumCheckExplicitTypeMismatch(e7, t2, s2) {
    const { explicitType: r2 } = t2;
    r2 !== null && r2 !== s2 && this.flowEnumErrorInvalidMemberInitializer(e7, t2);
  }
  flowEnumMembers({ enumName: e7, explicitType: t2 }) {
    const s2 = new Set(), r2 = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
    let i2 = false;
    for (; !this.match(bn.braceR); ) {
      if (this.eat(bn.ellipsis)) {
        i2 = true;
        break;
      }
      const a2 = this.startNode(), { id: n2, init: o2 } = this.flowEnumMemberRaw(), u2 = n2.name;
      if (u2 === "")
        continue;
      /^[a-z]/.test(u2) && this.flowEnumErrorInvalidMemberName(n2.start, { enumName: e7, memberName: u2 }), s2.has(u2) && this.flowEnumErrorDuplicateMemberName(n2.start, { enumName: e7, memberName: u2 }), s2.add(u2);
      const h2 = { enumName: e7, explicitType: t2, memberName: u2 };
      switch (a2.id = n2, o2.type) {
        case "boolean":
          this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "boolean"), a2.init = o2.value, r2.booleanMembers.push(this.finishNode(a2, "EnumBooleanMember"));
          break;
        case "number":
          this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "number"), a2.init = o2.value, r2.numberMembers.push(this.finishNode(a2, "EnumNumberMember"));
          break;
        case "string":
          this.flowEnumCheckExplicitTypeMismatch(o2.pos, h2, "string"), a2.init = o2.value, r2.stringMembers.push(this.finishNode(a2, "EnumStringMember"));
          break;
        case "invalid":
          throw this.flowEnumErrorInvalidMemberInitializer(o2.pos, h2);
        case "none":
          switch (t2) {
            case "boolean":
              this.flowEnumErrorBooleanMemberNotInitialized(o2.pos, h2);
              break;
            case "number":
              this.flowEnumErrorNumberMemberNotInitialized(o2.pos, h2);
              break;
            default:
              r2.defaultedMembers.push(this.finishNode(a2, "EnumDefaultedMember"));
          }
      }
      this.match(bn.braceR) || this.expect(bn.comma);
    }
    return { members: r2, hasUnknownMembers: i2 };
  }
  flowEnumStringMembers(e7, t2, { enumName: s2 }) {
    if (e7.length === 0)
      return t2;
    if (t2.length === 0)
      return e7;
    if (t2.length > e7.length) {
      for (const t3 of e7)
        this.flowEnumErrorStringMemberInconsistentlyInitailized(t3.start, { enumName: s2 });
      return t2;
    }
    for (const e8 of t2)
      this.flowEnumErrorStringMemberInconsistentlyInitailized(e8.start, { enumName: s2 });
    return e7;
  }
  flowEnumParseExplicitType({ enumName: e7 }) {
    if (this.eatContextual("of")) {
      if (!this.match(bn.name))
        throw this.flowEnumErrorInvalidExplicitType(this.state.start, { enumName: e7, suppliedType: null });
      const { value: t2 } = this.state;
      return this.next(), t2 !== "boolean" && t2 !== "number" && t2 !== "string" && t2 !== "symbol" && this.flowEnumErrorInvalidExplicitType(this.state.start, { enumName: e7, suppliedType: t2 }), t2;
    }
    return null;
  }
  flowEnumBody(e7, { enumName: t2, nameLoc: s2 }) {
    const r2 = this.flowEnumParseExplicitType({ enumName: t2 });
    this.expect(bn.braceL);
    const { members: i2, hasUnknownMembers: a2 } = this.flowEnumMembers({ enumName: t2, explicitType: r2 });
    switch (e7.hasUnknownMembers = a2, r2) {
      case "boolean":
        return e7.explicitType = true, e7.members = i2.booleanMembers, this.expect(bn.braceR), this.finishNode(e7, "EnumBooleanBody");
      case "number":
        return e7.explicitType = true, e7.members = i2.numberMembers, this.expect(bn.braceR), this.finishNode(e7, "EnumNumberBody");
      case "string":
        return e7.explicitType = true, e7.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, { enumName: t2 }), this.expect(bn.braceR), this.finishNode(e7, "EnumStringBody");
      case "symbol":
        return e7.members = i2.defaultedMembers, this.expect(bn.braceR), this.finishNode(e7, "EnumSymbolBody");
      default: {
        const r3 = () => (e7.members = [], this.expect(bn.braceR), this.finishNode(e7, "EnumStringBody"));
        e7.explicitType = false;
        const a3 = i2.booleanMembers.length, n2 = i2.numberMembers.length, o2 = i2.stringMembers.length, u2 = i2.defaultedMembers.length;
        if (a3 || n2 || o2 || u2) {
          if (a3 || n2) {
            if (!n2 && !o2 && a3 >= u2) {
              for (const e8 of i2.defaultedMembers)
                this.flowEnumErrorBooleanMemberNotInitialized(e8.start, { enumName: t2, memberName: e8.id.name });
              return e7.members = i2.booleanMembers, this.expect(bn.braceR), this.finishNode(e7, "EnumBooleanBody");
            }
            if (!a3 && !o2 && n2 >= u2) {
              for (const e8 of i2.defaultedMembers)
                this.flowEnumErrorNumberMemberNotInitialized(e8.start, { enumName: t2, memberName: e8.id.name });
              return e7.members = i2.numberMembers, this.expect(bn.braceR), this.finishNode(e7, "EnumNumberBody");
            }
            return this.flowEnumErrorInconsistentMemberValues(s2, { enumName: t2 }), r3();
          }
          return e7.members = this.flowEnumStringMembers(i2.stringMembers, i2.defaultedMembers, { enumName: t2 }), this.expect(bn.braceR), this.finishNode(e7, "EnumStringBody");
        }
        return r3();
      }
    }
  }
  flowParseEnumDeclaration(e7) {
    const t2 = this.parseIdentifier();
    return e7.id = t2, e7.body = this.flowEnumBody(this.startNode(), { enumName: t2.name, nameLoc: t2.start }), this.finishNode(e7, "EnumDeclaration");
  }
  isLookaheadToken_lt() {
    const e7 = this.nextTokenStart();
    if (this.input.charCodeAt(e7) === 60) {
      const t2 = this.input.charCodeAt(e7 + 1);
      return t2 !== 60 && t2 !== 61;
    }
    return false;
  }
  maybeUnwrapTypeCastExpression(e7) {
    return e7.type === "TypeCastExpression" ? e7.expression : e7;
  }
}, typescript: (e6) => class extends e6 {
  getScopeHandler() {
    return Wo;
  }
  tsIsIdentifier() {
    return this.match(bn.name);
  }
  tsTokenCanFollowModifier() {
    return (this.match(bn.bracketL) || this.match(bn.braceL) || this.match(bn.star) || this.match(bn.ellipsis) || this.match(bn.privateName) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
  }
  tsNextTokenCanFollowModifier() {
    return this.next(), this.tsTokenCanFollowModifier();
  }
  tsParseModifier(e7, t2) {
    if (!this.match(bn.name))
      return;
    const s2 = this.state.value;
    if (e7.indexOf(s2) !== -1) {
      if (t2 && this.tsIsStartOfStaticBlocks())
        return;
      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
        return s2;
    }
  }
  tsParseModifiers(e7, t2, s2, r2, i2) {
    const a2 = (t3, s3, r3, i3) => {
      s3 === r3 && e7[i3] && this.raise(t3, Xo.InvalidModifiersOrder, r3, i3);
    }, n2 = (t3, s3, r3, i3) => {
      (e7[r3] && s3 === i3 || e7[i3] && s3 === r3) && this.raise(t3, Xo.IncompatibleModifiers, r3, i3);
    };
    for (; ; ) {
      const o2 = this.state.start, u2 = this.tsParseModifier(t2.concat(s2 != null ? s2 : []), i2);
      if (!u2)
        break;
      Jo(u2) ? e7.accessibility ? this.raise(o2, Xo.DuplicateAccessibilityModifier) : (a2(o2, u2, u2, "override"), a2(o2, u2, u2, "static"), a2(o2, u2, u2, "readonly"), e7.accessibility = u2) : (Object.hasOwnProperty.call(e7, u2) ? this.raise(o2, Xo.DuplicateModifier, u2) : (a2(o2, u2, "static", "readonly"), a2(o2, u2, "static", "override"), a2(o2, u2, "override", "readonly"), a2(o2, u2, "abstract", "override"), n2(o2, u2, "declare", "override"), n2(o2, u2, "static", "abstract")), e7[u2] = true), s2 != null && s2.includes(u2) && this.raise(o2, r2, u2);
    }
  }
  tsIsListTerminator(e7) {
    switch (e7) {
      case "EnumMembers":
      case "TypeMembers":
        return this.match(bn.braceR);
      case "HeritageClauseElement":
        return this.match(bn.braceL);
      case "TupleElementTypes":
        return this.match(bn.bracketR);
      case "TypeParametersOrArguments":
        return this.isRelational(">");
    }
    throw new Error("Unreachable");
  }
  tsParseList(e7, t2) {
    const s2 = [];
    for (; !this.tsIsListTerminator(e7); )
      s2.push(t2());
    return s2;
  }
  tsParseDelimitedList(e7, t2) {
    return Go(this.tsParseDelimitedListWorker(e7, t2, true));
  }
  tsParseDelimitedListWorker(e7, t2, s2) {
    const r2 = [];
    for (; !this.tsIsListTerminator(e7); ) {
      const i2 = t2();
      if (i2 == null)
        return;
      if (r2.push(i2), !this.eat(bn.comma)) {
        if (this.tsIsListTerminator(e7))
          break;
        return void (s2 && this.expect(bn.comma));
      }
    }
    return r2;
  }
  tsParseBracketedList(e7, t2, s2, r2) {
    r2 || (s2 ? this.expect(bn.bracketL) : this.expectRelational("<"));
    const i2 = this.tsParseDelimitedList(e7, t2);
    return s2 ? this.expect(bn.bracketR) : this.expectRelational(">"), i2;
  }
  tsParseImportType() {
    const e7 = this.startNode();
    return this.expect(bn._import), this.expect(bn.parenL), this.match(bn.string) || this.raise(this.state.start, Xo.UnsupportedImportTypeArgument), e7.argument = this.parseExprAtom(), this.expect(bn.parenR), this.eat(bn.dot) && (e7.qualifier = this.tsParseEntityName(true)), this.isRelational("<") && (e7.typeParameters = this.tsParseTypeArguments()), this.finishNode(e7, "TSImportType");
  }
  tsParseEntityName(e7) {
    let t2 = this.parseIdentifier();
    for (; this.eat(bn.dot); ) {
      const s2 = this.startNodeAtNode(t2);
      s2.left = t2, s2.right = this.parseIdentifier(e7), t2 = this.finishNode(s2, "TSQualifiedName");
    }
    return t2;
  }
  tsParseTypeReference() {
    const e7 = this.startNode();
    return e7.typeName = this.tsParseEntityName(false), !this.hasPrecedingLineBreak() && this.isRelational("<") && (e7.typeParameters = this.tsParseTypeArguments()), this.finishNode(e7, "TSTypeReference");
  }
  tsParseThisTypePredicate(e7) {
    this.next();
    const t2 = this.startNodeAtNode(e7);
    return t2.parameterName = e7, t2.typeAnnotation = this.tsParseTypeAnnotation(false), t2.asserts = false, this.finishNode(t2, "TSTypePredicate");
  }
  tsParseThisTypeNode() {
    const e7 = this.startNode();
    return this.next(), this.finishNode(e7, "TSThisType");
  }
  tsParseTypeQuery() {
    const e7 = this.startNode();
    return this.expect(bn._typeof), this.match(bn._import) ? e7.exprName = this.tsParseImportType() : e7.exprName = this.tsParseEntityName(true), this.finishNode(e7, "TSTypeQuery");
  }
  tsParseTypeParameter() {
    const e7 = this.startNode();
    return e7.name = this.tsParseTypeParameterName(), e7.constraint = this.tsEatThenParseType(bn._extends), e7.default = this.tsEatThenParseType(bn.eq), this.finishNode(e7, "TSTypeParameter");
  }
  tsTryParseTypeParameters() {
    if (this.isRelational("<"))
      return this.tsParseTypeParameters();
  }
  tsParseTypeParameters() {
    const e7 = this.startNode();
    return this.isRelational("<") || this.match(bn.jsxTagStart) ? this.next() : this.unexpected(), e7.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true), e7.params.length === 0 && this.raise(e7.start, Xo.EmptyTypeParameters), this.finishNode(e7, "TSTypeParameterDeclaration");
  }
  tsTryNextParseConstantContext() {
    return this.lookahead().type === bn._const ? (this.next(), this.tsParseTypeReference()) : null;
  }
  tsFillSignature(e7, t2) {
    const s2 = e7 === bn.arrow;
    t2.typeParameters = this.tsTryParseTypeParameters(), this.expect(bn.parenL), t2.parameters = this.tsParseBindingListForSignature(), (s2 || this.match(e7)) && (t2.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(e7));
  }
  tsParseBindingListForSignature() {
    return this.parseBindingList(bn.parenR, 41).map((e7) => (e7.type !== "Identifier" && e7.type !== "RestElement" && e7.type !== "ObjectPattern" && e7.type !== "ArrayPattern" && this.raise(e7.start, Xo.UnsupportedSignatureParameterKind, e7.type), e7));
  }
  tsParseTypeMemberSemicolon() {
    this.eat(bn.comma) || this.isLineTerminator() || this.expect(bn.semi);
  }
  tsParseSignatureMember(e7, t2) {
    return this.tsFillSignature(bn.colon, t2), this.tsParseTypeMemberSemicolon(), this.finishNode(t2, e7);
  }
  tsIsUnambiguouslyIndexSignature() {
    return this.next(), this.eat(bn.name) && this.match(bn.colon);
  }
  tsTryParseIndexSignature(e7) {
    if (!this.match(bn.bracketL) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
      return;
    this.expect(bn.bracketL);
    const t2 = this.parseIdentifier();
    t2.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t2), this.expect(bn.bracketR), e7.parameters = [t2];
    const s2 = this.tsTryParseTypeAnnotation();
    return s2 && (e7.typeAnnotation = s2), this.tsParseTypeMemberSemicolon(), this.finishNode(e7, "TSIndexSignature");
  }
  tsParsePropertyOrMethodSignature(e7, t2) {
    this.eat(bn.question) && (e7.optional = true);
    const s2 = e7;
    if (this.match(bn.parenL) || this.isRelational("<")) {
      t2 && this.raise(e7.start, Xo.ReadonlyForMethodSignature);
      const r2 = s2;
      if (r2.kind && this.isRelational("<") && this.raise(this.state.pos, Xo.AccesorCannotHaveTypeParameters), this.tsFillSignature(bn.colon, r2), this.tsParseTypeMemberSemicolon(), r2.kind === "get")
        r2.parameters.length > 0 && (this.raise(this.state.pos, Rn.BadGetterArity), this.isThisParam(r2.parameters[0]) && this.raise(this.state.pos, Xo.AccesorCannotDeclareThisParameter));
      else if (r2.kind === "set") {
        if (r2.parameters.length !== 1)
          this.raise(this.state.pos, Rn.BadSetterArity);
        else {
          const e8 = r2.parameters[0];
          this.isThisParam(e8) && this.raise(this.state.pos, Xo.AccesorCannotDeclareThisParameter), e8.type === "Identifier" && e8.optional && this.raise(this.state.pos, Xo.SetAccesorCannotHaveOptionalParameter), e8.type === "RestElement" && this.raise(this.state.pos, Xo.SetAccesorCannotHaveRestParameter);
        }
        r2.typeAnnotation && this.raise(r2.typeAnnotation.start, Xo.SetAccesorCannotHaveReturnType);
      } else
        r2.kind = "method";
      return this.finishNode(r2, "TSMethodSignature");
    }
    {
      const e8 = s2;
      t2 && (e8.readonly = true);
      const r2 = this.tsTryParseTypeAnnotation();
      return r2 && (e8.typeAnnotation = r2), this.tsParseTypeMemberSemicolon(), this.finishNode(e8, "TSPropertySignature");
    }
  }
  tsParseTypeMember() {
    const e7 = this.startNode();
    if (this.match(bn.parenL) || this.isRelational("<"))
      return this.tsParseSignatureMember("TSCallSignatureDeclaration", e7);
    if (this.match(bn._new)) {
      const t3 = this.startNode();
      return this.next(), this.match(bn.parenL) || this.isRelational("<") ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e7) : (e7.key = this.createIdentifier(t3, "new"), this.tsParsePropertyOrMethodSignature(e7, false));
    }
    this.tsParseModifiers(e7, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], Xo.InvalidModifierOnTypeMember);
    const t2 = this.tsTryParseIndexSignature(e7);
    return t2 || (this.parsePropertyName(e7, false), e7.computed || e7.key.type !== "Identifier" || e7.key.name !== "get" && e7.key.name !== "set" || !this.tsTokenCanFollowModifier() || (e7.kind = e7.key.name, this.parsePropertyName(e7, false)), this.tsParsePropertyOrMethodSignature(e7, !!e7.readonly));
  }
  tsParseTypeLiteral() {
    const e7 = this.startNode();
    return e7.members = this.tsParseObjectTypeMembers(), this.finishNode(e7, "TSTypeLiteral");
  }
  tsParseObjectTypeMembers() {
    this.expect(bn.braceL);
    const e7 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
    return this.expect(bn.braceR), e7;
  }
  tsIsStartOfMappedType() {
    return this.next(), this.eat(bn.plusMin) ? this.isContextual("readonly") : (this.isContextual("readonly") && this.next(), !!this.match(bn.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(bn._in))));
  }
  tsParseMappedTypeParameter() {
    const e7 = this.startNode();
    return e7.name = this.tsParseTypeParameterName(), e7.constraint = this.tsExpectThenParseType(bn._in), this.finishNode(e7, "TSTypeParameter");
  }
  tsParseMappedType() {
    const e7 = this.startNode();
    return this.expect(bn.braceL), this.match(bn.plusMin) ? (e7.readonly = this.state.value, this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (e7.readonly = true), this.expect(bn.bracketL), e7.typeParameter = this.tsParseMappedTypeParameter(), e7.nameType = this.eatContextual("as") ? this.tsParseType() : null, this.expect(bn.bracketR), this.match(bn.plusMin) ? (e7.optional = this.state.value, this.next(), this.expect(bn.question)) : this.eat(bn.question) && (e7.optional = true), e7.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(bn.braceR), this.finishNode(e7, "TSMappedType");
  }
  tsParseTupleType() {
    const e7 = this.startNode();
    e7.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
    let t2 = false, s2 = null;
    return e7.elementTypes.forEach((e8) => {
      var r2;
      let { type: i2 } = e8;
      !t2 || i2 === "TSRestType" || i2 === "TSOptionalType" || i2 === "TSNamedTupleMember" && e8.optional || this.raise(e8.start, Xo.OptionalTypeBeforeRequired), t2 = t2 || i2 === "TSNamedTupleMember" && e8.optional || i2 === "TSOptionalType", i2 === "TSRestType" && (i2 = (e8 = e8.typeAnnotation).type);
      const a2 = i2 === "TSNamedTupleMember";
      s2 = (r2 = s2) != null ? r2 : a2, s2 !== a2 && this.raise(e8.start, Xo.MixedLabeledAndUnlabeledElements);
    }), this.finishNode(e7, "TSTupleType");
  }
  tsParseTupleElementType() {
    const { start: e7, startLoc: t2 } = this.state, s2 = this.eat(bn.ellipsis);
    let r2 = this.tsParseType();
    const i2 = this.eat(bn.question);
    if (this.eat(bn.colon)) {
      const e8 = this.startNodeAtNode(r2);
      e8.optional = i2, r2.type !== "TSTypeReference" || r2.typeParameters || r2.typeName.type !== "Identifier" ? (this.raise(r2.start, Xo.InvalidTupleMemberLabel), e8.label = r2) : e8.label = r2.typeName, e8.elementType = this.tsParseType(), r2 = this.finishNode(e8, "TSNamedTupleMember");
    } else if (i2) {
      const e8 = this.startNodeAtNode(r2);
      e8.typeAnnotation = r2, r2 = this.finishNode(e8, "TSOptionalType");
    }
    if (s2) {
      const s3 = this.startNodeAt(e7, t2);
      s3.typeAnnotation = r2, r2 = this.finishNode(s3, "TSRestType");
    }
    return r2;
  }
  tsParseParenthesizedType() {
    const e7 = this.startNode();
    return this.expect(bn.parenL), e7.typeAnnotation = this.tsParseType(), this.expect(bn.parenR), this.finishNode(e7, "TSParenthesizedType");
  }
  tsParseFunctionOrConstructorType(e7, t2) {
    const s2 = this.startNode();
    return e7 === "TSConstructorType" && (s2.abstract = !!t2, t2 && this.next(), this.next()), this.tsFillSignature(bn.arrow, s2), this.finishNode(s2, e7);
  }
  tsParseLiteralTypeNode() {
    const e7 = this.startNode();
    return e7.literal = (() => {
      switch (this.state.type) {
        case bn.num:
        case bn.bigint:
        case bn.string:
        case bn._true:
        case bn._false:
          return this.parseExprAtom();
        default:
          throw this.unexpected();
      }
    })(), this.finishNode(e7, "TSLiteralType");
  }
  tsParseTemplateLiteralType() {
    const e7 = this.startNode();
    return e7.literal = this.parseTemplate(false), this.finishNode(e7, "TSLiteralType");
  }
  parseTemplateSubstitution() {
    return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
  }
  tsParseThisTypeOrThisTypePredicate() {
    const e7 = this.tsParseThisTypeNode();
    return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e7) : e7;
  }
  tsParseNonArrayType() {
    switch (this.state.type) {
      case bn.name:
      case bn._void:
      case bn._null: {
        const e7 = this.match(bn._void) ? "TSVoidKeyword" : this.match(bn._null) ? "TSNullKeyword" : function(e8) {
          switch (e8) {
            case "any":
              return "TSAnyKeyword";
            case "boolean":
              return "TSBooleanKeyword";
            case "bigint":
              return "TSBigIntKeyword";
            case "never":
              return "TSNeverKeyword";
            case "number":
              return "TSNumberKeyword";
            case "object":
              return "TSObjectKeyword";
            case "string":
              return "TSStringKeyword";
            case "symbol":
              return "TSSymbolKeyword";
            case "undefined":
              return "TSUndefinedKeyword";
            case "unknown":
              return "TSUnknownKeyword";
            default:
              return;
          }
        }(this.state.value);
        if (e7 !== void 0 && this.lookaheadCharCode() !== 46) {
          const t2 = this.startNode();
          return this.next(), this.finishNode(t2, e7);
        }
        return this.tsParseTypeReference();
      }
      case bn.string:
      case bn.num:
      case bn.bigint:
      case bn._true:
      case bn._false:
        return this.tsParseLiteralTypeNode();
      case bn.plusMin:
        if (this.state.value === "-") {
          const e7 = this.startNode(), t2 = this.lookahead();
          if (t2.type !== bn.num && t2.type !== bn.bigint)
            throw this.unexpected();
          return e7.literal = this.parseMaybeUnary(), this.finishNode(e7, "TSLiteralType");
        }
        break;
      case bn._this:
        return this.tsParseThisTypeOrThisTypePredicate();
      case bn._typeof:
        return this.tsParseTypeQuery();
      case bn._import:
        return this.tsParseImportType();
      case bn.braceL:
        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
      case bn.bracketL:
        return this.tsParseTupleType();
      case bn.parenL:
        return this.tsParseParenthesizedType();
      case bn.backQuote:
        return this.tsParseTemplateLiteralType();
    }
    throw this.unexpected();
  }
  tsParseArrayTypeOrHigher() {
    let e7 = this.tsParseNonArrayType();
    for (; !this.hasPrecedingLineBreak() && this.eat(bn.bracketL); )
      if (this.match(bn.bracketR)) {
        const t2 = this.startNodeAtNode(e7);
        t2.elementType = e7, this.expect(bn.bracketR), e7 = this.finishNode(t2, "TSArrayType");
      } else {
        const t2 = this.startNodeAtNode(e7);
        t2.objectType = e7, t2.indexType = this.tsParseType(), this.expect(bn.bracketR), e7 = this.finishNode(t2, "TSIndexedAccessType");
      }
    return e7;
  }
  tsParseTypeOperator(e7) {
    const t2 = this.startNode();
    return this.expectContextual(e7), t2.operator = e7, t2.typeAnnotation = this.tsParseTypeOperatorOrHigher(), e7 === "readonly" && this.tsCheckTypeAnnotationForReadOnly(t2), this.finishNode(t2, "TSTypeOperator");
  }
  tsCheckTypeAnnotationForReadOnly(e7) {
    switch (e7.typeAnnotation.type) {
      case "TSTupleType":
      case "TSArrayType":
        return;
      default:
        this.raise(e7.start, Xo.UnexpectedReadonly);
    }
  }
  tsParseInferType() {
    const e7 = this.startNode();
    this.expectContextual("infer");
    const t2 = this.startNode();
    return t2.name = this.tsParseTypeParameterName(), e7.typeParameter = this.finishNode(t2, "TSTypeParameter"), this.finishNode(e7, "TSInferType");
  }
  tsParseTypeOperatorOrHigher() {
    const e7 = ["keyof", "unique", "readonly"].find((e8) => this.isContextual(e8));
    return e7 ? this.tsParseTypeOperator(e7) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
  }
  tsParseUnionOrIntersectionType(e7, t2, s2) {
    const r2 = this.startNode(), i2 = this.eat(s2), a2 = [];
    do {
      a2.push(t2());
    } while (this.eat(s2));
    return a2.length !== 1 || i2 ? (r2.types = a2, this.finishNode(r2, e7)) : a2[0];
  }
  tsParseIntersectionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), bn.bitwiseAND);
  }
  tsParseUnionTypeOrHigher() {
    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), bn.bitwiseOR);
  }
  tsIsStartOfFunctionType() {
    return !!this.isRelational("<") || this.match(bn.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
  }
  tsSkipParameterStart() {
    if (this.match(bn.name) || this.match(bn._this))
      return this.next(), true;
    if (this.match(bn.braceL)) {
      let e7 = 1;
      for (this.next(); e7 > 0; )
        this.match(bn.braceL) ? ++e7 : this.match(bn.braceR) && --e7, this.next();
      return true;
    }
    if (this.match(bn.bracketL)) {
      let e7 = 1;
      for (this.next(); e7 > 0; )
        this.match(bn.bracketL) ? ++e7 : this.match(bn.bracketR) && --e7, this.next();
      return true;
    }
    return false;
  }
  tsIsUnambiguouslyStartOfFunctionType() {
    if (this.next(), this.match(bn.parenR) || this.match(bn.ellipsis))
      return true;
    if (this.tsSkipParameterStart()) {
      if (this.match(bn.colon) || this.match(bn.comma) || this.match(bn.question) || this.match(bn.eq))
        return true;
      if (this.match(bn.parenR) && (this.next(), this.match(bn.arrow)))
        return true;
    }
    return false;
  }
  tsParseTypeOrTypePredicateAnnotation(e7) {
    return this.tsInType(() => {
      const t2 = this.startNode();
      this.expect(e7);
      const s2 = this.startNode(), r2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
      if (r2 && this.match(bn._this)) {
        let e8 = this.tsParseThisTypeOrThisTypePredicate();
        return e8.type === "TSThisType" ? (s2.parameterName = e8, s2.asserts = true, s2.typeAnnotation = null, e8 = this.finishNode(s2, "TSTypePredicate")) : (this.resetStartLocationFromNode(e8, s2), e8.asserts = true), t2.typeAnnotation = e8, this.finishNode(t2, "TSTypeAnnotation");
      }
      const i2 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
      if (!i2)
        return r2 ? (s2.parameterName = this.parseIdentifier(), s2.asserts = r2, s2.typeAnnotation = null, t2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(t2, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t2);
      const a2 = this.tsParseTypeAnnotation(false);
      return s2.parameterName = i2, s2.typeAnnotation = a2, s2.asserts = r2, t2.typeAnnotation = this.finishNode(s2, "TSTypePredicate"), this.finishNode(t2, "TSTypeAnnotation");
    });
  }
  tsTryParseTypeOrTypePredicateAnnotation() {
    return this.match(bn.colon) ? this.tsParseTypeOrTypePredicateAnnotation(bn.colon) : void 0;
  }
  tsTryParseTypeAnnotation() {
    return this.match(bn.colon) ? this.tsParseTypeAnnotation() : void 0;
  }
  tsTryParseType() {
    return this.tsEatThenParseType(bn.colon);
  }
  tsParseTypePredicatePrefix() {
    const e7 = this.parseIdentifier();
    if (this.isContextual("is") && !this.hasPrecedingLineBreak())
      return this.next(), e7;
  }
  tsParseTypePredicateAsserts() {
    if (!this.match(bn.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak())
      return false;
    const e7 = this.state.containsEsc;
    return this.next(), !(!this.match(bn.name) && !this.match(bn._this)) && (e7 && this.raise(this.state.lastTokStart, Rn.InvalidEscapedReservedWord, "asserts"), true);
  }
  tsParseTypeAnnotation(e7 = true, t2 = this.startNode()) {
    return this.tsInType(() => {
      e7 && this.expect(bn.colon), t2.typeAnnotation = this.tsParseType();
    }), this.finishNode(t2, "TSTypeAnnotation");
  }
  tsParseType() {
    Ko(this.state.inType);
    const e7 = this.tsParseNonConditionalType();
    if (this.hasPrecedingLineBreak() || !this.eat(bn._extends))
      return e7;
    const t2 = this.startNodeAtNode(e7);
    return t2.checkType = e7, t2.extendsType = this.tsParseNonConditionalType(), this.expect(bn.question), t2.trueType = this.tsParseType(), this.expect(bn.colon), t2.falseType = this.tsParseType(), this.finishNode(t2, "TSConditionalType");
  }
  isAbstractConstructorSignature() {
    return this.isContextual("abstract") && this.lookahead().type === bn._new;
  }
  tsParseNonConditionalType() {
    return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(bn._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
  }
  tsParseTypeAssertion() {
    const e7 = this.startNode(), t2 = this.tsTryNextParseConstantContext();
    return e7.typeAnnotation = t2 || this.tsNextThenParseType(), this.expectRelational(">"), e7.expression = this.parseMaybeUnary(), this.finishNode(e7, "TSTypeAssertion");
  }
  tsParseHeritageClause(e7) {
    const t2 = this.state.start, s2 = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
    return s2.length || this.raise(t2, Xo.EmptyHeritageClauseType, e7), s2;
  }
  tsParseExpressionWithTypeArguments() {
    const e7 = this.startNode();
    return e7.expression = this.tsParseEntityName(false), this.isRelational("<") && (e7.typeParameters = this.tsParseTypeArguments()), this.finishNode(e7, "TSExpressionWithTypeArguments");
  }
  tsParseInterfaceDeclaration(e7) {
    this.match(bn.name) ? (e7.id = this.parseIdentifier(), this.checkLVal(e7.id, "typescript interface declaration", 130)) : (e7.id = null, this.raise(this.state.start, Xo.MissingInterfaceName)), e7.typeParameters = this.tsTryParseTypeParameters(), this.eat(bn._extends) && (e7.extends = this.tsParseHeritageClause("extends"));
    const t2 = this.startNode();
    return t2.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e7.body = this.finishNode(t2, "TSInterfaceBody"), this.finishNode(e7, "TSInterfaceDeclaration");
  }
  tsParseTypeAliasDeclaration(e7) {
    return e7.id = this.parseIdentifier(), this.checkLVal(e7.id, "typescript type alias", 2), e7.typeParameters = this.tsTryParseTypeParameters(), e7.typeAnnotation = this.tsInType(() => {
      if (this.expect(bn.eq), this.isContextual("intrinsic") && this.lookahead().type !== bn.dot) {
        const e8 = this.startNode();
        return this.next(), this.finishNode(e8, "TSIntrinsicKeyword");
      }
      return this.tsParseType();
    }), this.semicolon(), this.finishNode(e7, "TSTypeAliasDeclaration");
  }
  tsInNoContext(e7) {
    const t2 = this.state.context;
    this.state.context = [t2[0]];
    try {
      return e7();
    } finally {
      this.state.context = t2;
    }
  }
  tsInType(e7) {
    const t2 = this.state.inType;
    this.state.inType = true;
    try {
      return e7();
    } finally {
      this.state.inType = t2;
    }
  }
  tsEatThenParseType(e7) {
    return this.match(e7) ? this.tsNextThenParseType() : void 0;
  }
  tsExpectThenParseType(e7) {
    return this.tsDoThenParseType(() => this.expect(e7));
  }
  tsNextThenParseType() {
    return this.tsDoThenParseType(() => this.next());
  }
  tsDoThenParseType(e7) {
    return this.tsInType(() => (e7(), this.tsParseType()));
  }
  tsParseEnumMember() {
    const e7 = this.startNode();
    return e7.id = this.match(bn.string) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(bn.eq) && (e7.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(e7, "TSEnumMember");
  }
  tsParseEnumDeclaration(e7, t2) {
    return t2 && (e7.const = true), e7.id = this.parseIdentifier(), this.checkLVal(e7.id, "typescript enum declaration", t2 ? 779 : 267), this.expect(bn.braceL), e7.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(bn.braceR), this.finishNode(e7, "TSEnumDeclaration");
  }
  tsParseModuleBlock() {
    const e7 = this.startNode();
    return this.scope.enter(0), this.expect(bn.braceL), this.parseBlockOrModuleBlockBody(e7.body = [], void 0, true, bn.braceR), this.scope.exit(), this.finishNode(e7, "TSModuleBlock");
  }
  tsParseModuleOrNamespaceDeclaration(e7, t2 = false) {
    if (e7.id = this.parseIdentifier(), t2 || this.checkLVal(e7.id, "module or namespace declaration", 1024), this.eat(bn.dot)) {
      const t3 = this.startNode();
      this.tsParseModuleOrNamespaceDeclaration(t3, true), e7.body = t3;
    } else
      this.scope.enter(256), this.prodParam.enter(0), e7.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
    return this.finishNode(e7, "TSModuleDeclaration");
  }
  tsParseAmbientExternalModuleDeclaration(e7) {
    return this.isContextual("global") ? (e7.global = true, e7.id = this.parseIdentifier()) : this.match(bn.string) ? e7.id = this.parseExprAtom() : this.unexpected(), this.match(bn.braceL) ? (this.scope.enter(256), this.prodParam.enter(0), e7.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e7, "TSModuleDeclaration");
  }
  tsParseImportEqualsDeclaration(e7, t2) {
    e7.isExport = t2 || false, e7.id = this.parseIdentifier(), this.checkLVal(e7.id, "import equals declaration", 9), this.expect(bn.eq);
    const s2 = this.tsParseModuleReference();
    return e7.importKind === "type" && s2.type !== "TSExternalModuleReference" && this.raise(s2.start, Xo.ImportAliasHasImportType), e7.moduleReference = s2, this.semicolon(), this.finishNode(e7, "TSImportEqualsDeclaration");
  }
  tsIsExternalModuleReference() {
    return this.isContextual("require") && this.lookaheadCharCode() === 40;
  }
  tsParseModuleReference() {
    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
  }
  tsParseExternalModuleReference() {
    const e7 = this.startNode();
    if (this.expectContextual("require"), this.expect(bn.parenL), !this.match(bn.string))
      throw this.unexpected();
    return e7.expression = this.parseExprAtom(), this.expect(bn.parenR), this.finishNode(e7, "TSExternalModuleReference");
  }
  tsLookAhead(e7) {
    const t2 = this.state.clone(), s2 = e7();
    return this.state = t2, s2;
  }
  tsTryParseAndCatch(e7) {
    const t2 = this.tryParse((t3) => e7() || t3());
    if (!t2.aborted && t2.node)
      return t2.error && (this.state = t2.failState), t2.node;
  }
  tsTryParse(e7) {
    const t2 = this.state.clone(), s2 = e7();
    return s2 !== void 0 && s2 !== false ? s2 : void (this.state = t2);
  }
  tsTryParseDeclare(e7) {
    if (this.isLineTerminator())
      return;
    let t2, s2 = this.state.type;
    return this.isContextual("let") && (s2 = bn._var, t2 = "let"), this.tsInAmbientContext(() => {
      switch (s2) {
        case bn._function:
          return e7.declare = true, this.parseFunctionStatement(e7, false, true);
        case bn._class:
          return e7.declare = true, this.parseClass(e7, true, false);
        case bn._const:
          if (this.match(bn._const) && this.isLookaheadContextual("enum"))
            return this.expect(bn._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(e7, true);
        case bn._var:
          return t2 = t2 || this.state.value, this.parseVarStatement(e7, t2);
        case bn.name: {
          const t3 = this.state.value;
          return t3 === "global" ? this.tsParseAmbientExternalModuleDeclaration(e7) : this.tsParseDeclaration(e7, t3, true);
        }
      }
    });
  }
  tsTryParseExportDeclaration() {
    return this.tsParseDeclaration(this.startNode(), this.state.value, true);
  }
  tsParseExpressionStatement(e7, t2) {
    switch (t2.name) {
      case "declare": {
        const t3 = this.tsTryParseDeclare(e7);
        if (t3)
          return t3.declare = true, t3;
        break;
      }
      case "global":
        if (this.match(bn.braceL)) {
          this.scope.enter(256), this.prodParam.enter(0);
          const s2 = e7;
          return s2.global = true, s2.id = t2, s2.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(s2, "TSModuleDeclaration");
        }
        break;
      default:
        return this.tsParseDeclaration(e7, t2.name, false);
    }
  }
  tsParseDeclaration(e7, t2, s2) {
    switch (t2) {
      case "abstract":
        if (this.tsCheckLineTerminator(s2) && (this.match(bn._class) || this.match(bn.name)))
          return this.tsParseAbstractDeclaration(e7);
        break;
      case "enum":
        if (s2 || this.match(bn.name))
          return s2 && this.next(), this.tsParseEnumDeclaration(e7, false);
        break;
      case "interface":
        if (this.tsCheckLineTerminator(s2) && this.match(bn.name))
          return this.tsParseInterfaceDeclaration(e7);
        break;
      case "module":
        if (this.tsCheckLineTerminator(s2)) {
          if (this.match(bn.string))
            return this.tsParseAmbientExternalModuleDeclaration(e7);
          if (this.match(bn.name))
            return this.tsParseModuleOrNamespaceDeclaration(e7);
        }
        break;
      case "namespace":
        if (this.tsCheckLineTerminator(s2) && this.match(bn.name))
          return this.tsParseModuleOrNamespaceDeclaration(e7);
        break;
      case "type":
        if (this.tsCheckLineTerminator(s2) && this.match(bn.name))
          return this.tsParseTypeAliasDeclaration(e7);
    }
  }
  tsCheckLineTerminator(e7) {
    return e7 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
  }
  tsTryParseGenericAsyncArrowFunction(e7, t2) {
    if (!this.isRelational("<"))
      return;
    const s2 = this.state.maybeInArrowParameters;
    this.state.maybeInArrowParameters = true;
    const r2 = this.tsTryParseAndCatch(() => {
      const s3 = this.startNodeAt(e7, t2);
      return s3.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(s3), s3.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(bn.arrow), s3;
    });
    return this.state.maybeInArrowParameters = s2, r2 ? this.parseArrowExpression(r2, null, true) : void 0;
  }
  tsParseTypeArguments() {
    const e7 = this.startNode();
    return e7.params = this.tsInType(() => this.tsInNoContext(() => (this.expectRelational("<"), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e7.params.length === 0 && this.raise(e7.start, Xo.EmptyTypeArguments), this.expectRelational(">"), this.finishNode(e7, "TSTypeParameterInstantiation");
  }
  tsIsDeclarationStart() {
    if (this.match(bn.name))
      switch (this.state.value) {
        case "abstract":
        case "declare":
        case "enum":
        case "interface":
        case "module":
        case "namespace":
        case "type":
          return true;
      }
    return false;
  }
  isExportDefaultSpecifier() {
    return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
  }
  parseAssignableListItem(e7, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc;
    let i2, a2 = false, n2 = false;
    if (e7 !== void 0) {
      const t3 = {};
      this.tsParseModifiers(t3, ["public", "private", "protected", "override", "readonly"]), i2 = t3.accessibility, n2 = t3.override, a2 = t3.readonly, e7 === false && (i2 || a2 || n2) && this.raise(s2, Xo.UnexpectedParameterModifier);
    }
    const o2 = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(o2);
    const u2 = this.parseMaybeDefault(o2.start, o2.loc.start, o2);
    if (i2 || a2 || n2) {
      const e8 = this.startNodeAt(s2, r2);
      return t2.length && (e8.decorators = t2), i2 && (e8.accessibility = i2), a2 && (e8.readonly = a2), n2 && (e8.override = n2), u2.type !== "Identifier" && u2.type !== "AssignmentPattern" && this.raise(e8.start, Xo.UnsupportedParameterPropertyKind), e8.parameter = u2, this.finishNode(e8, "TSParameterProperty");
    }
    return t2.length && (o2.decorators = t2), u2;
  }
  parseFunctionBodyAndFinish(e7, t2, s2 = false) {
    this.match(bn.colon) && (e7.returnType = this.tsParseTypeOrTypePredicateAnnotation(bn.colon));
    const r2 = t2 === "FunctionDeclaration" ? "TSDeclareFunction" : t2 === "ClassMethod" ? "TSDeclareMethod" : void 0;
    r2 && !this.match(bn.braceL) && this.isLineTerminator() ? this.finishNode(e7, r2) : r2 === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(e7.start, Xo.DeclareFunctionHasImplementation), e7.declare) ? super.parseFunctionBodyAndFinish(e7, r2, s2) : super.parseFunctionBodyAndFinish(e7, t2, s2);
  }
  registerFunctionStatementId(e7) {
    !e7.body && e7.id ? this.checkLVal(e7.id, "function name", 1024) : super.registerFunctionStatementId(...arguments);
  }
  tsCheckForInvalidTypeCasts(e7) {
    e7.forEach((e8) => {
      (e8 == null ? void 0 : e8.type) === "TSTypeCastExpression" && this.raise(e8.typeAnnotation.start, Xo.UnexpectedTypeAnnotation);
    });
  }
  toReferencedList(e7, t2) {
    return this.tsCheckForInvalidTypeCasts(e7), e7;
  }
  parseArrayLike(...e7) {
    const t2 = super.parseArrayLike(...e7);
    return t2.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(t2.elements), t2;
  }
  parseSubscript(e7, t2, s2, r2, i2) {
    if (!this.hasPrecedingLineBreak() && this.match(bn.bang)) {
      this.state.exprAllowed = false, this.next();
      const r3 = this.startNodeAt(t2, s2);
      return r3.expression = e7, this.finishNode(r3, "TSNonNullExpression");
    }
    let a2 = false;
    if (this.match(bn.questionDot) && this.lookaheadCharCode() === 60) {
      if (r2)
        return i2.stop = true, e7;
      i2.optionalChainMember = a2 = true, this.next();
    }
    if (this.isRelational("<")) {
      let n2;
      const o2 = this.tsTryParseAndCatch(() => {
        if (!r2 && this.atPossibleAsyncArrow(e7)) {
          const e8 = this.tsTryParseGenericAsyncArrowFunction(t2, s2);
          if (e8)
            return e8;
        }
        const o3 = this.startNodeAt(t2, s2);
        o3.callee = e7;
        const u2 = this.tsParseTypeArguments();
        if (u2) {
          if (a2 && !this.match(bn.parenL) && (n2 = this.state.pos, this.unexpected()), !r2 && this.eat(bn.parenL))
            return o3.arguments = this.parseCallExpressionArguments(bn.parenR, false), this.tsCheckForInvalidTypeCasts(o3.arguments), o3.typeParameters = u2, i2.optionalChainMember && (o3.optional = a2), this.finishCallExpression(o3, i2.optionalChainMember);
          if (this.match(bn.backQuote)) {
            const r3 = this.parseTaggedTemplateExpression(e7, t2, s2, i2);
            return r3.typeParameters = u2, r3;
          }
        }
        this.unexpected();
      });
      if (n2 && this.unexpected(n2, bn.parenL), o2)
        return o2;
    }
    return super.parseSubscript(e7, t2, s2, r2, i2);
  }
  parseNewArguments(e7) {
    if (this.isRelational("<")) {
      const t2 = this.tsTryParseAndCatch(() => {
        const e8 = this.tsParseTypeArguments();
        return this.match(bn.parenL) || this.unexpected(), e8;
      });
      t2 && (e7.typeParameters = t2);
    }
    super.parseNewArguments(e7);
  }
  parseExprOp(e7, t2, s2, r2) {
    if (Go(bn._in.binop) > r2 && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
      const i2 = this.startNodeAt(t2, s2);
      i2.expression = e7;
      const a2 = this.tsTryNextParseConstantContext();
      return i2.typeAnnotation = a2 || this.tsNextThenParseType(), this.finishNode(i2, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(i2, t2, s2, r2);
    }
    return super.parseExprOp(e7, t2, s2, r2);
  }
  checkReservedWord(e7, t2, s2, r2) {
  }
  checkDuplicateExports() {
  }
  parseImport(e7) {
    if (e7.importKind = "value", this.match(bn.name) || this.match(bn.star) || this.match(bn.braceL)) {
      let t3 = this.lookahead();
      if (!this.isContextual("type") || t3.type === bn.comma || t3.type === bn.name && t3.value === "from" || t3.type === bn.eq || (e7.importKind = "type", this.next(), t3 = this.lookahead()), this.match(bn.name) && t3.type === bn.eq)
        return this.tsParseImportEqualsDeclaration(e7);
    }
    const t2 = super.parseImport(e7);
    return t2.importKind === "type" && t2.specifiers.length > 1 && t2.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(t2.start, Xo.TypeImportCannotSpecifyDefaultAndNamed), t2;
  }
  parseExport(e7) {
    if (this.match(bn._import))
      return this.next(), this.isContextual("type") && this.lookaheadCharCode() !== 61 ? (e7.importKind = "type", this.next()) : e7.importKind = "value", this.tsParseImportEqualsDeclaration(e7, true);
    if (this.eat(bn.eq)) {
      const t2 = e7;
      return t2.expression = this.parseExpression(), this.semicolon(), this.finishNode(t2, "TSExportAssignment");
    }
    if (this.eatContextual("as")) {
      const t2 = e7;
      return this.expectContextual("namespace"), t2.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t2, "TSNamespaceExportDeclaration");
    }
    return this.isContextual("type") && this.lookahead().type === bn.braceL ? (this.next(), e7.exportKind = "type") : e7.exportKind = "value", super.parseExport(e7);
  }
  isAbstractClass() {
    return this.isContextual("abstract") && this.lookahead().type === bn._class;
  }
  parseExportDefaultExpression() {
    if (this.isAbstractClass()) {
      const e7 = this.startNode();
      return this.next(), e7.abstract = true, this.parseClass(e7, true, true), e7;
    }
    if (this.state.value === "interface") {
      const e7 = this.startNode();
      this.next();
      const t2 = this.tsParseInterfaceDeclaration(e7);
      if (t2)
        return t2;
    }
    return super.parseExportDefaultExpression();
  }
  parseStatementContent(e7, t2) {
    if (this.state.type === bn._const) {
      const e8 = this.lookahead();
      if (e8.type === bn.name && e8.value === "enum") {
        const e9 = this.startNode();
        return this.expect(bn._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(e9, true);
      }
    }
    return super.parseStatementContent(e7, t2);
  }
  parseAccessModifier() {
    return this.tsParseModifier(["public", "protected", "private"]);
  }
  tsHasSomeModifiers(e7, t2) {
    return t2.some((t3) => Jo(t3) ? e7.accessibility === t3 : !!e7[t3]);
  }
  tsIsStartOfStaticBlocks() {
    return this.isContextual("static") && this.lookaheadCharCode() === 123;
  }
  parseClassMember(e7, t2, s2) {
    const r2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
    this.tsParseModifiers(t2, r2, void 0, void 0, true);
    const i2 = () => {
      this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(t2, r2) && this.raise(this.state.pos, Xo.StaticBlockCannotHaveModifier), this.parseClassStaticBlock(e7, t2)) : this.parseClassMemberWithIsStatic(e7, t2, s2, !!t2.static);
    };
    t2.declare ? this.tsInAmbientContext(i2) : i2();
  }
  parseClassMemberWithIsStatic(e7, t2, s2, r2) {
    const i2 = this.tsTryParseIndexSignature(t2);
    if (i2)
      return e7.body.push(i2), t2.abstract && this.raise(t2.start, Xo.IndexSignatureHasAbstract), t2.accessibility && this.raise(t2.start, Xo.IndexSignatureHasAccessibility, t2.accessibility), t2.declare && this.raise(t2.start, Xo.IndexSignatureHasDeclare), void (t2.override && this.raise(t2.start, Xo.IndexSignatureHasOverride));
    !this.state.inAbstractClass && t2.abstract && this.raise(t2.start, Xo.NonAbstractClassHasAbstractMethod), t2.override && (s2.hadSuperClass || this.raise(t2.start, Xo.OverrideNotInSubClass)), super.parseClassMemberWithIsStatic(e7, t2, s2, r2);
  }
  parsePostMemberNameModifiers(e7) {
    this.eat(bn.question) && (e7.optional = true), e7.readonly && this.match(bn.parenL) && this.raise(e7.start, Xo.ClassMethodHasReadonly), e7.declare && this.match(bn.parenL) && this.raise(e7.start, Xo.ClassMethodHasDeclare);
  }
  parseExpressionStatement(e7, t2) {
    return (t2.type === "Identifier" ? this.tsParseExpressionStatement(e7, t2) : void 0) || super.parseExpressionStatement(e7, t2);
  }
  shouldParseExportDeclaration() {
    return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
  }
  parseConditional(e7, t2, s2, r2) {
    if (!this.state.maybeInArrowParameters || !this.match(bn.question))
      return super.parseConditional(e7, t2, s2, r2);
    const i2 = this.tryParse(() => super.parseConditional(e7, t2, s2));
    return i2.node ? (i2.error && (this.state = i2.failState), i2.node) : (i2.error && super.setOptionalParametersError(r2, i2.error), e7);
  }
  parseParenItem(e7, t2, s2) {
    if (e7 = super.parseParenItem(e7, t2, s2), this.eat(bn.question) && (e7.optional = true, this.resetEndLocation(e7)), this.match(bn.colon)) {
      const r2 = this.startNodeAt(t2, s2);
      return r2.expression = e7, r2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r2, "TSTypeCastExpression");
    }
    return e7;
  }
  parseExportDeclaration(e7) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.eatContextual("declare");
    if (r2 && (this.isContextual("declare") || !this.shouldParseExportDeclaration()))
      throw this.raise(this.state.start, Xo.ExpectedAmbientAfterExportDeclare);
    let i2;
    return this.match(bn.name) && (i2 = this.tsTryParseExportDeclaration()), i2 || (i2 = super.parseExportDeclaration(e7)), i2 && (i2.type === "TSInterfaceDeclaration" || i2.type === "TSTypeAliasDeclaration" || r2) && (e7.exportKind = "type"), i2 && r2 && (this.resetStartLocation(i2, t2, s2), i2.declare = true), i2;
  }
  parseClassId(e7, t2, s2) {
    if ((!t2 || s2) && this.isContextual("implements"))
      return;
    super.parseClassId(e7, t2, s2, e7.declare ? 1024 : 139);
    const r2 = this.tsTryParseTypeParameters();
    r2 && (e7.typeParameters = r2);
  }
  parseClassPropertyAnnotation(e7) {
    !e7.optional && this.eat(bn.bang) && (e7.definite = true);
    const t2 = this.tsTryParseTypeAnnotation();
    t2 && (e7.typeAnnotation = t2);
  }
  parseClassProperty(e7) {
    if (this.parseClassPropertyAnnotation(e7), this.state.isAmbientContext && this.match(bn.eq) && this.raise(this.state.start, Xo.DeclareClassFieldHasInitializer), e7.abstract && this.match(bn.eq)) {
      const { key: t2 } = e7;
      this.raise(this.state.start, Xo.AbstractPropertyHasInitializer, t2.type !== "Identifier" || e7.computed ? `[${this.input.slice(t2.start, t2.end)}]` : t2.name);
    }
    return super.parseClassProperty(e7);
  }
  parseClassPrivateProperty(e7) {
    return e7.abstract && this.raise(e7.start, Xo.PrivateElementHasAbstract), e7.accessibility && this.raise(e7.start, Xo.PrivateElementHasAccessibility, e7.accessibility), this.parseClassPropertyAnnotation(e7), super.parseClassPrivateProperty(e7);
  }
  pushClassMethod(e7, t2, s2, r2, i2, a2) {
    const n2 = this.tsTryParseTypeParameters();
    n2 && i2 && this.raise(n2.start, Xo.ConstructorHasTypeParameters), !t2.declare || t2.kind !== "get" && t2.kind !== "set" || this.raise(t2.start, Xo.DeclareAccessor, t2.kind), n2 && (t2.typeParameters = n2), super.pushClassMethod(e7, t2, s2, r2, i2, a2);
  }
  pushClassPrivateMethod(e7, t2, s2, r2) {
    const i2 = this.tsTryParseTypeParameters();
    i2 && (t2.typeParameters = i2), super.pushClassPrivateMethod(e7, t2, s2, r2);
  }
  parseClassSuper(e7) {
    super.parseClassSuper(e7), e7.superClass && this.isRelational("<") && (e7.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual("implements") && (e7.implements = this.tsParseHeritageClause("implements"));
  }
  parseObjPropValue(e7, ...t2) {
    const s2 = this.tsTryParseTypeParameters();
    s2 && (e7.typeParameters = s2), super.parseObjPropValue(e7, ...t2);
  }
  parseFunctionParams(e7, t2) {
    const s2 = this.tsTryParseTypeParameters();
    s2 && (e7.typeParameters = s2), super.parseFunctionParams(e7, t2);
  }
  parseVarId(e7, t2) {
    super.parseVarId(e7, t2), e7.id.type === "Identifier" && this.eat(bn.bang) && (e7.definite = true);
    const s2 = this.tsTryParseTypeAnnotation();
    s2 && (e7.id.typeAnnotation = s2, this.resetEndLocation(e7.id));
  }
  parseAsyncArrowFromCallExpression(e7, t2) {
    return this.match(bn.colon) && (e7.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e7, t2);
  }
  parseMaybeAssign(...e7) {
    var t2, s2, r2, i2, a2, n2, o2;
    let u2, h2, c2, p2;
    if (this.hasPlugin("jsx") && (this.match(bn.jsxTagStart) || this.isRelational("<"))) {
      if (u2 = this.state.clone(), h2 = this.tryParse(() => super.parseMaybeAssign(...e7), u2), !h2.error)
        return h2.node;
      const { context: t3 } = this.state;
      t3[t3.length - 1] === $n.j_oTag ? t3.length -= 2 : t3[t3.length - 1] === $n.j_expr && (t3.length -= 1);
    }
    if (!((t2 = h2) != null && t2.error || this.isRelational("<")))
      return super.parseMaybeAssign(...e7);
    u2 = u2 || this.state.clone();
    const l2 = this.tryParse((t3) => {
      var s3, r3;
      p2 = this.tsParseTypeParameters();
      const i3 = super.parseMaybeAssign(...e7);
      return (i3.type !== "ArrowFunctionExpression" || (s3 = i3.extra) != null && s3.parenthesized) && t3(), ((r3 = p2) == null ? void 0 : r3.params.length) !== 0 && this.resetStartLocationFromNode(i3, p2), i3.typeParameters = p2, i3;
    }, u2);
    if (!l2.error && !l2.aborted)
      return l2.node;
    if (!h2 && (Ko(!this.hasPlugin("jsx")), c2 = this.tryParse(() => super.parseMaybeAssign(...e7), u2), !c2.error))
      return c2.node;
    if ((s2 = h2) != null && s2.node)
      return this.state = h2.failState, h2.node;
    if (l2.node)
      return this.state = l2.failState, l2.node;
    if ((r2 = c2) != null && r2.node)
      return this.state = c2.failState, c2.node;
    if ((i2 = h2) != null && i2.thrown)
      throw h2.error;
    if (l2.thrown)
      throw l2.error;
    if ((a2 = c2) != null && a2.thrown)
      throw c2.error;
    throw ((n2 = h2) == null ? void 0 : n2.error) || l2.error || ((o2 = c2) == null ? void 0 : o2.error);
  }
  parseMaybeUnary(e7) {
    return !this.hasPlugin("jsx") && this.isRelational("<") ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e7);
  }
  parseArrow(e7) {
    if (this.match(bn.colon)) {
      const t2 = this.tryParse((e8) => {
        const t3 = this.tsParseTypeOrTypePredicateAnnotation(bn.colon);
        return !this.canInsertSemicolon() && this.match(bn.arrow) || e8(), t3;
      });
      if (t2.aborted)
        return;
      t2.thrown || (t2.error && (this.state = t2.failState), e7.returnType = t2.node);
    }
    return super.parseArrow(e7);
  }
  parseAssignableListItemTypes(e7) {
    this.eat(bn.question) && (e7.type === "Identifier" || this.state.isAmbientContext || this.state.inType || this.raise(e7.start, Xo.PatternIsOptional), e7.optional = true);
    const t2 = this.tsTryParseTypeAnnotation();
    return t2 && (e7.typeAnnotation = t2), this.resetEndLocation(e7), e7;
  }
  isAssignable(e7, t2) {
    switch (e7.type) {
      case "TSTypeCastExpression":
        return this.isAssignable(e7.expression, t2);
      case "TSParameterProperty":
        return true;
      default:
        return super.isAssignable(e7, t2);
    }
  }
  toAssignable(e7, t2 = false) {
    switch (e7.type) {
      case "TSTypeCastExpression":
        return super.toAssignable(this.typeCastToParameter(e7), t2);
      case "TSParameterProperty":
        return super.toAssignable(e7, t2);
      case "ParenthesizedExpression":
        return this.toAssignableParenthesizedExpression(e7, t2);
      case "TSAsExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
        return e7.expression = this.toAssignable(e7.expression, t2), e7;
      default:
        return super.toAssignable(e7, t2);
    }
  }
  toAssignableParenthesizedExpression(e7, t2) {
    switch (e7.expression.type) {
      case "TSAsExpression":
      case "TSNonNullExpression":
      case "TSTypeAssertion":
      case "ParenthesizedExpression":
        return e7.expression = this.toAssignable(e7.expression, t2), e7;
      default:
        return super.toAssignable(e7, t2);
    }
  }
  checkLVal(e7, t2, ...s2) {
    var r2;
    switch (e7.type) {
      case "TSTypeCastExpression":
        return;
      case "TSParameterProperty":
        return void this.checkLVal(e7.parameter, "parameter property", ...s2);
      case "TSAsExpression":
      case "TSTypeAssertion":
        if (!(s2[0] || t2 === "parenthesized expression" || (r2 = e7.extra) != null && r2.parenthesized)) {
          this.raise(e7.start, Rn.InvalidLhs, t2);
          break;
        }
        return void this.checkLVal(e7.expression, "parenthesized expression", ...s2);
      case "TSNonNullExpression":
        return void this.checkLVal(e7.expression, t2, ...s2);
      default:
        return void super.checkLVal(e7, t2, ...s2);
    }
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case bn._this:
        return this.parseIdentifier(true);
      default:
        return super.parseBindingAtom();
    }
  }
  parseMaybeDecoratorArguments(e7) {
    if (this.isRelational("<")) {
      const t2 = this.tsParseTypeArguments();
      if (this.match(bn.parenL)) {
        const s2 = super.parseMaybeDecoratorArguments(e7);
        return s2.typeParameters = t2, s2;
      }
      this.unexpected(this.state.start, bn.parenL);
    }
    return super.parseMaybeDecoratorArguments(e7);
  }
  checkCommaAfterRest(e7) {
    this.state.isAmbientContext && this.match(bn.comma) && this.lookaheadCharCode() === e7 ? this.next() : super.checkCommaAfterRest(e7);
  }
  isClassMethod() {
    return this.isRelational("<") || super.isClassMethod();
  }
  isClassProperty() {
    return this.match(bn.bang) || this.match(bn.colon) || super.isClassProperty();
  }
  parseMaybeDefault(...e7) {
    const t2 = super.parseMaybeDefault(...e7);
    return t2.type === "AssignmentPattern" && t2.typeAnnotation && t2.right.start < t2.typeAnnotation.start && this.raise(t2.typeAnnotation.start, Xo.TypeAnnotationAfterAssign), t2;
  }
  getTokenFromCode(e7) {
    return !this.state.inType || e7 !== 62 && e7 !== 60 ? super.getTokenFromCode(e7) : this.finishOp(bn.relational, 1);
  }
  reScan_lt_gt() {
    if (this.match(bn.relational)) {
      const e7 = this.input.charCodeAt(this.state.start);
      e7 !== 60 && e7 !== 62 || (this.state.pos -= 1, this.readToken_lt_gt(e7));
    }
  }
  toAssignableList(e7) {
    for (let t2 = 0; t2 < e7.length; t2++) {
      const s2 = e7[t2];
      if (s2)
        switch (s2.type) {
          case "TSTypeCastExpression":
            e7[t2] = this.typeCastToParameter(s2);
            break;
          case "TSAsExpression":
          case "TSTypeAssertion":
            this.state.maybeInArrowParameters ? this.raise(s2.start, Xo.UnexpectedTypeCastInParameter) : e7[t2] = this.typeCastToParameter(s2);
        }
    }
    return super.toAssignableList(...arguments);
  }
  typeCastToParameter(e7) {
    return e7.expression.typeAnnotation = e7.typeAnnotation, this.resetEndLocation(e7.expression, e7.typeAnnotation.end, e7.typeAnnotation.loc.end), e7.expression;
  }
  shouldParseArrow(e7) {
    return this.match(bn.colon) ? e7.every((e8) => this.isAssignable(e8, true)) : super.shouldParseArrow(e7);
  }
  shouldParseAsyncArrow() {
    return this.match(bn.colon) || super.shouldParseAsyncArrow();
  }
  canHaveLeadingDecorator() {
    return super.canHaveLeadingDecorator() || this.isAbstractClass();
  }
  jsxParseOpeningElementAfterName(e7) {
    if (this.isRelational("<")) {
      const t2 = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
      t2 && (e7.typeParameters = t2);
    }
    return super.jsxParseOpeningElementAfterName(e7);
  }
  getGetterSetterExpectedParamCount(e7) {
    const t2 = super.getGetterSetterExpectedParamCount(e7), s2 = this.getObjectOrClassMethodParams(e7)[0];
    return s2 && this.isThisParam(s2) ? t2 + 1 : t2;
  }
  parseCatchClauseParam() {
    const e7 = super.parseCatchClauseParam(), t2 = this.tsTryParseTypeAnnotation();
    return t2 && (e7.typeAnnotation = t2, this.resetEndLocation(e7)), e7;
  }
  tsInAmbientContext(e7) {
    const t2 = this.state.isAmbientContext;
    this.state.isAmbientContext = true;
    try {
      return e7();
    } finally {
      this.state.isAmbientContext = t2;
    }
  }
  parseClass(e7, ...t2) {
    const s2 = this.state.inAbstractClass;
    this.state.inAbstractClass = !!e7.abstract;
    try {
      return super.parseClass(e7, ...t2);
    } finally {
      this.state.inAbstractClass = s2;
    }
  }
  tsParseAbstractDeclaration(e7) {
    if (this.match(bn._class))
      return e7.abstract = true, this.parseClass(e7, true, false);
    if (this.isContextual("interface")) {
      if (!this.hasFollowingLineBreak())
        return e7.abstract = true, this.raise(e7.start, Xo.NonClassMethodPropertyHasAbstractModifer), this.next(), this.tsParseInterfaceDeclaration(e7);
    } else
      this.unexpected(null, bn._class);
  }
  parseMethod(...e7) {
    const t2 = super.parseMethod(...e7);
    if (t2.abstract) {
      if (this.hasPlugin("estree") ? !!t2.value.body : !!t2.body) {
        const { key: e8 } = t2;
        this.raise(t2.start, Xo.AbstractMethodHasImplementation, e8.type !== "Identifier" || t2.computed ? `[${this.input.slice(e8.start, e8.end)}]` : e8.name);
      }
    }
    return t2;
  }
  tsParseTypeParameterName() {
    return this.parseIdentifier().name;
  }
  shouldParseAsAmbientContext() {
    return !!this.getPluginOption("typescript", "dts");
  }
  parse() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
  }
  getExpression() {
    return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
  }
}, v8intrinsic: (e6) => class extends e6 {
  parseV8Intrinsic() {
    if (this.match(bn.modulo)) {
      const e7 = this.state.start, t2 = this.startNode();
      if (this.eat(bn.modulo), this.match(bn.name)) {
        const e8 = this.parseIdentifierName(this.state.start), s2 = this.createIdentifier(t2, e8);
        if (s2.type = "V8IntrinsicIdentifier", this.match(bn.parenL))
          return s2;
      }
      this.unexpected(e7);
    }
  }
  parseExprAtom() {
    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
  }
}, placeholders: (e6) => class extends e6 {
  parsePlaceholder(e7) {
    if (this.match(bn.placeholder)) {
      const t2 = this.startNode();
      return this.next(), this.assertNoSpace("Unexpected space in placeholder."), t2.name = super.parseIdentifier(true), this.assertNoSpace("Unexpected space in placeholder."), this.expect(bn.placeholder), this.finishPlaceholder(t2, e7);
    }
  }
  finishPlaceholder(e7, t2) {
    const s2 = !(!e7.expectedNode || e7.type !== "Placeholder");
    return e7.expectedNode = t2, s2 ? e7 : this.finishNode(e7, "Placeholder");
  }
  getTokenFromCode(e7) {
    return e7 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(bn.placeholder, 2) : super.getTokenFromCode(...arguments);
  }
  parseExprAtom() {
    return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
  }
  parseIdentifier() {
    return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
  }
  checkReservedWord(e7) {
    e7 !== void 0 && super.checkReservedWord(...arguments);
  }
  parseBindingAtom() {
    return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
  }
  checkLVal(e7) {
    e7.type !== "Placeholder" && super.checkLVal(...arguments);
  }
  toAssignable(e7) {
    return e7 && e7.type === "Placeholder" && e7.expectedNode === "Expression" ? (e7.expectedNode = "Pattern", e7) : super.toAssignable(...arguments);
  }
  isLet(e7) {
    if (super.isLet(e7))
      return true;
    if (!this.isContextual("let"))
      return false;
    if (e7)
      return false;
    return this.lookahead().type === bn.placeholder;
  }
  verifyBreakContinue(e7) {
    e7.label && e7.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
  }
  parseExpressionStatement(e7, t2) {
    if (t2.type !== "Placeholder" || t2.extra && t2.extra.parenthesized)
      return super.parseExpressionStatement(...arguments);
    if (this.match(bn.colon)) {
      const s2 = e7;
      return s2.label = this.finishPlaceholder(t2, "Identifier"), this.next(), s2.body = this.parseStatement("label"), this.finishNode(s2, "LabeledStatement");
    }
    return this.semicolon(), e7.name = t2.name, this.finishPlaceholder(e7, "Statement");
  }
  parseBlock() {
    return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
  }
  parseFunctionId() {
    return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
  }
  parseClass(e7, t2, s2) {
    const r2 = t2 ? "ClassDeclaration" : "ClassExpression";
    this.next(), this.takeDecorators(e7);
    const i2 = this.state.strict, a2 = this.parsePlaceholder("Identifier");
    if (a2)
      if (this.match(bn._extends) || this.match(bn.placeholder) || this.match(bn.braceL))
        e7.id = a2;
      else {
        if (s2 || !t2)
          return e7.id = null, e7.body = this.finishPlaceholder(a2, "ClassBody"), this.finishNode(e7, r2);
        this.unexpected(null, Yo.ClassNameIsRequired);
      }
    else
      this.parseClassId(e7, t2, s2);
    return this.parseClassSuper(e7), e7.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!e7.superClass, i2), this.finishNode(e7, r2);
  }
  parseExport(e7) {
    const t2 = this.parsePlaceholder("Identifier");
    if (!t2)
      return super.parseExport(...arguments);
    if (!this.isContextual("from") && !this.match(bn.comma))
      return e7.specifiers = [], e7.source = null, e7.declaration = this.finishPlaceholder(t2, "Declaration"), this.finishNode(e7, "ExportNamedDeclaration");
    this.expectPlugin("exportDefaultFrom");
    const s2 = this.startNode();
    return s2.exported = t2, e7.specifiers = [this.finishNode(s2, "ExportDefaultSpecifier")], super.parseExport(e7);
  }
  isExportDefaultSpecifier() {
    if (this.match(bn._default)) {
      const e7 = this.nextTokenStart();
      if (this.isUnparsedContextual(e7, "from") && this.input.startsWith(bn.placeholder.label, this.nextTokenStartSince(e7 + 4)))
        return true;
    }
    return super.isExportDefaultSpecifier();
  }
  maybeParseExportDefaultSpecifier(e7) {
    return !!(e7.specifiers && e7.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
  }
  checkExport(e7) {
    const { specifiers: t2 } = e7;
    t2 != null && t2.length && (e7.specifiers = t2.filter((e8) => e8.exported.type === "Placeholder")), super.checkExport(e7), e7.specifiers = t2;
  }
  parseImport(e7) {
    const t2 = this.parsePlaceholder("Identifier");
    if (!t2)
      return super.parseImport(...arguments);
    if (e7.specifiers = [], !this.isContextual("from") && !this.match(bn.comma))
      return e7.source = this.finishPlaceholder(t2, "StringLiteral"), this.semicolon(), this.finishNode(e7, "ImportDeclaration");
    const s2 = this.startNodeAtNode(t2);
    if (s2.local = t2, this.finishNode(s2, "ImportDefaultSpecifier"), e7.specifiers.push(s2), this.eat(bn.comma)) {
      this.maybeParseStarImportSpecifier(e7) || this.parseNamedImportSpecifiers(e7);
    }
    return this.expectContextual("from"), e7.source = this.parseImportSource(), this.semicolon(), this.finishNode(e7, "ImportDeclaration");
  }
  parseImportSource() {
    return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
  }
} };
var iu = Object.keys(ru);
var au = { sourceType: "script", sourceFilename: void 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true };
var nu = (e6) => e6.type === "ParenthesizedExpression" ? nu(e6.expression) : e6;
var ou = { kind: "loop" };
var uu = { kind: "switch" };
var hu = /[\uD800-\uDFFF]/u;
var cu = /in(?:stanceof)?/y;
var pu = class extends class extends class extends class extends class extends class extends class extends class extends class extends class {
  constructor() {
    this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
  }
  hasPlugin(e6) {
    return this.plugins.has(e6);
  }
  getPluginOption(e6, t2) {
    if (this.hasPlugin(e6))
      return this.plugins.get(e6)[t2];
  }
} {
  addComment(e6) {
    this.filename && (e6.loc.filename = this.filename), this.state.comments.push(e6);
  }
  processComment(e6) {
    const { commentStack: t2 } = this.state, s2 = t2.length;
    if (s2 === 0)
      return;
    let r2 = s2 - 1;
    const i2 = t2[r2];
    i2.start === e6.end && (i2.leadingNode = e6, r2--);
    const { start: a2 } = e6;
    for (; r2 >= 0; r2--) {
      const s3 = t2[r2], i3 = s3.end;
      if (!(i3 > a2)) {
        i3 === a2 && (s3.trailingNode = e6);
        break;
      }
      s3.containingNode = e6, this.finalizeComment(s3), t2.splice(r2, 1);
    }
  }
  finalizeComment(e6) {
    const { comments: t2 } = e6;
    if (e6.leadingNode !== null || e6.trailingNode !== null)
      e6.leadingNode !== null && kn(e6.leadingNode, t2), e6.trailingNode !== null && (e6.trailingNode.leadingComments = t2);
    else {
      const { containingNode: s2, start: r2 } = e6;
      if (this.input.charCodeAt(r2 - 1) === 44)
        switch (s2.type) {
          case "ObjectExpression":
          case "ObjectPattern":
          case "RecordExpression":
            On(s2, s2.properties, e6);
            break;
          case "CallExpression":
          case "OptionalCallExpression":
            On(s2, s2.arguments, e6);
            break;
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
          case "ObjectMethod":
          case "ClassMethod":
          case "ClassPrivateMethod":
            On(s2, s2.params, e6);
            break;
          case "ArrayExpression":
          case "ArrayPattern":
          case "TupleExpression":
            On(s2, s2.elements, e6);
            break;
          case "ExportNamedDeclaration":
          case "ImportDeclaration":
            On(s2, s2.specifiers, e6);
            break;
          default:
            Ln(s2, t2);
        }
      else
        Ln(s2, t2);
    }
  }
  finalizeRemainingComments() {
    const { commentStack: e6 } = this.state;
    for (let t2 = e6.length - 1; t2 >= 0; t2--)
      this.finalizeComment(e6[t2]);
    this.state.commentStack = [];
  }
  resetPreviousNodeTrailingComments(e6) {
    const { commentStack: t2 } = this.state, { length: s2 } = t2;
    if (s2 === 0)
      return;
    const r2 = t2[s2 - 1];
    r2.leadingNode === e6 && (r2.leadingNode = null);
  }
} {
  getLocationForPosition(e6) {
    let t2;
    return t2 = e6 === this.state.start ? this.state.startLoc : e6 === this.state.lastTokStart ? this.state.lastTokStartLoc : e6 === this.state.end ? this.state.endLoc : e6 === this.state.lastTokEnd ? this.state.lastTokEndLoc : function(e7, t3) {
      let s2, r2 = 1, i2 = 0;
      for (Tn.lastIndex = 0; (s2 = Tn.exec(e7)) && s2.index < t3; )
        r2++, i2 = Tn.lastIndex;
      return new In(r2, t3 - i2);
    }(this.input, e6), t2;
  }
  raise(e6, { code: t2, reasonCode: s2, template: r2 }, ...i2) {
    return this.raiseWithData(e6, { code: t2, reasonCode: s2 }, r2, ...i2);
  }
  raiseOverwrite(e6, { code: t2, template: s2 }, ...r2) {
    const i2 = this.getLocationForPosition(e6), a2 = s2.replace(/%(\d+)/g, (e7, t3) => r2[t3]) + ` (${i2.line}:${i2.column})`;
    if (this.options.errorRecovery) {
      const t3 = this.state.errors;
      for (let s3 = t3.length - 1; s3 >= 0; s3--) {
        const r3 = t3[s3];
        if (r3.pos === e6)
          return Object.assign(r3, { message: a2 });
        if (r3.pos < e6)
          break;
      }
    }
    return this._raise({ code: t2, loc: i2, pos: e6 }, a2);
  }
  raiseWithData(e6, t2, s2, ...r2) {
    const i2 = this.getLocationForPosition(e6), a2 = s2.replace(/%(\d+)/g, (e7, t3) => r2[t3]) + ` (${i2.line}:${i2.column})`;
    return this._raise(Object.assign({ loc: i2, pos: e6 }, t2), a2);
  }
  _raise(e6, t2) {
    const s2 = new SyntaxError(t2);
    if (Object.assign(s2, e6), this.options.errorRecovery)
      return this.isLookahead || this.state.errors.push(s2), s2;
    throw s2;
  }
} {
  constructor(e6, t2) {
    super(), this.isLookahead = void 0, this.tokens = [], this.state = new Do(), this.state.init(e6), this.input = t2, this.length = t2.length, this.isLookahead = false;
  }
  pushToken(e6) {
    this.tokens.length = this.state.tokensLength, this.tokens.push(e6), ++this.state.tokensLength;
  }
  next() {
    this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Eo(this.state)), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
  }
  eat(e6) {
    return !!this.match(e6) && (this.next(), true);
  }
  match(e6) {
    return this.state.type === e6;
  }
  createLookaheadState(e6) {
    return { pos: e6.pos, value: null, type: e6.type, start: e6.start, end: e6.end, lastTokEnd: e6.end, context: [this.curContext()], inType: e6.inType };
  }
  lookahead() {
    const e6 = this.state;
    this.state = this.createLookaheadState(e6), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
    const t2 = this.state;
    return this.state = e6, t2;
  }
  nextTokenStart() {
    return this.nextTokenStartSince(this.state.pos);
  }
  nextTokenStartSince(e6) {
    return Sn.lastIndex = e6, Sn.test(this.input) ? Sn.lastIndex : e6;
  }
  lookaheadCharCode() {
    return this.input.charCodeAt(this.nextTokenStart());
  }
  codePointAtPos(e6) {
    let t2 = this.input.charCodeAt(e6);
    if ((64512 & t2) == 55296 && ++e6 < this.input.length) {
      const s2 = this.input.charCodeAt(e6);
      (64512 & s2) == 56320 && (t2 = 65536 + ((1023 & t2) << 10) + (1023 & s2));
    }
    return t2;
  }
  setStrict(e6) {
    this.state.strict = e6, e6 && (this.state.strictErrors.forEach((e7, t2) => this.raise(t2, e7)), this.state.strictErrors.clear());
  }
  curContext() {
    return this.state.context[this.state.context.length - 1];
  }
  nextToken() {
    const e6 = this.curContext();
    e6.preserveSpace || this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(bn.eof) : e6 === $n.template ? this.readTmplToken() : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
  }
  skipBlockComment() {
    let e6;
    this.isLookahead || (e6 = this.state.curPosition());
    const t2 = this.state.pos, s2 = this.input.indexOf("*/", t2 + 2);
    if (s2 === -1)
      throw this.raise(t2, Rn.UnterminatedComment);
    for (this.state.pos = s2 + 2, Tn.lastIndex = t2 + 2; Tn.test(this.input) && Tn.lastIndex <= s2; )
      ++this.state.curLine, this.state.lineStart = Tn.lastIndex;
    if (this.isLookahead)
      return;
    const r2 = { type: "CommentBlock", value: this.input.slice(t2 + 2, s2), start: t2, end: s2 + 2, loc: new vn(e6, this.state.curPosition()) };
    return this.options.tokens && this.pushToken(r2), r2;
  }
  skipLineComment(e6) {
    const t2 = this.state.pos;
    let s2;
    this.isLookahead || (s2 = this.state.curPosition());
    let r2 = this.input.charCodeAt(this.state.pos += e6);
    if (this.state.pos < this.length)
      for (; !wn(r2) && ++this.state.pos < this.length; )
        r2 = this.input.charCodeAt(this.state.pos);
    if (this.isLookahead)
      return;
    const i2 = this.state.pos, a2 = { type: "CommentLine", value: this.input.slice(t2 + e6, i2), start: t2, end: i2, loc: new vn(s2, this.state.curPosition()) };
    return this.options.tokens && this.pushToken(a2), a2;
  }
  skipSpace() {
    const e6 = this.state.pos, t2 = [];
    e:
      for (; this.state.pos < this.length; ) {
        const s2 = this.input.charCodeAt(this.state.pos);
        switch (s2) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                const e7 = this.skipBlockComment();
                e7 !== void 0 && (this.addComment(e7), this.options.attachComment && t2.push(e7));
                break;
              }
              case 47: {
                const e7 = this.skipLineComment(2);
                e7 !== void 0 && (this.addComment(e7), this.options.attachComment && t2.push(e7));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (Nn(s2))
              ++this.state.pos;
            else if (s2 !== 45 || this.inModule) {
              if (s2 !== 60 || this.inModule)
                break e;
              {
                const e7 = this.state.pos;
                if (this.input.charCodeAt(e7 + 1) !== 33 || this.input.charCodeAt(e7 + 2) !== 45 || this.input.charCodeAt(e7 + 3) !== 45)
                  break e;
                {
                  const e8 = this.skipLineComment(4);
                  e8 !== void 0 && (this.addComment(e8), this.options.attachComment && t2.push(e8));
                }
              }
            } else {
              const s3 = this.state.pos;
              if (this.input.charCodeAt(s3 + 1) !== 45 || this.input.charCodeAt(s3 + 2) !== 62 || !(e6 === 0 || this.state.lineStart > e6))
                break e;
              {
                const e7 = this.skipLineComment(3);
                e7 !== void 0 && (this.addComment(e7), this.options.attachComment && t2.push(e7));
              }
            }
        }
      }
    if (t2.length > 0) {
      const s2 = { start: e6, end: this.state.pos, comments: t2, leadingNode: null, trailingNode: null, containingNode: null };
      this.state.commentStack.push(s2);
    }
  }
  finishToken(e6, t2) {
    this.state.end = this.state.pos;
    const s2 = this.state.type;
    this.state.type = e6, this.state.value = t2, this.isLookahead || (this.state.endLoc = this.state.curPosition(), this.updateContext(s2));
  }
  readToken_numberSign() {
    if (this.state.pos === 0 && this.readToken_interpreter())
      return;
    const e6 = this.state.pos + 1, t2 = this.codePointAtPos(e6);
    if (t2 >= 48 && t2 <= 57)
      throw this.raise(this.state.pos, Rn.UnexpectedDigitAfterHash);
    if (t2 === 123 || t2 === 91 && this.hasPlugin("recordAndTuple")) {
      if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
        throw this.raise(this.state.pos, t2 === 123 ? Rn.RecordExpressionHashIncorrectStartSyntaxType : Rn.TupleExpressionHashIncorrectStartSyntaxType);
      this.state.pos += 2, t2 === 123 ? this.finishToken(bn.braceHashL) : this.finishToken(bn.bracketHashL);
    } else
      Jn(t2) ? (++this.state.pos, this.finishToken(bn.privateName, this.readWord1(t2))) : t2 === 92 ? (++this.state.pos, this.finishToken(bn.privateName, this.readWord1())) : this.finishOp(bn.hash, 1);
  }
  readToken_dot() {
    const e6 = this.input.charCodeAt(this.state.pos + 1);
    e6 >= 48 && e6 <= 57 ? this.readNumber(true) : e6 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(bn.ellipsis)) : (++this.state.pos, this.finishToken(bn.dot));
  }
  readToken_slash() {
    this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(bn.slashAssign, 2) : this.finishOp(bn.slash, 1);
  }
  readToken_interpreter() {
    if (this.state.pos !== 0 || this.length < 2)
      return false;
    let e6 = this.input.charCodeAt(this.state.pos + 1);
    if (e6 !== 33)
      return false;
    const t2 = this.state.pos;
    for (this.state.pos += 1; !wn(e6) && ++this.state.pos < this.length; )
      e6 = this.input.charCodeAt(this.state.pos);
    const s2 = this.input.slice(t2 + 2, this.state.pos);
    return this.finishToken(bn.interpreterDirective, s2), true;
  }
  readToken_mult_modulo(e6) {
    let t2 = e6 === 42 ? bn.star : bn.modulo, s2 = 1, r2 = this.input.charCodeAt(this.state.pos + 1);
    e6 === 42 && r2 === 42 && (s2++, r2 = this.input.charCodeAt(this.state.pos + 2), t2 = bn.exponent), r2 !== 61 || this.state.inType || (s2++, t2 = e6 === 37 ? bn.moduloAssign : bn.assign), this.finishOp(t2, s2);
  }
  readToken_pipe_amp(e6) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    if (t2 !== e6) {
      if (e6 === 124) {
        if (t2 === 62)
          return void this.finishOp(bn.pipeline, 2);
        if (this.hasPlugin("recordAndTuple") && t2 === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(this.state.pos, Rn.RecordExpressionBarIncorrectEndSyntaxType);
          return this.state.pos += 2, void this.finishToken(bn.braceBarR);
        }
        if (this.hasPlugin("recordAndTuple") && t2 === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(this.state.pos, Rn.TupleExpressionBarIncorrectEndSyntaxType);
          return this.state.pos += 2, void this.finishToken(bn.bracketBarR);
        }
      }
      t2 !== 61 ? this.finishOp(e6 === 124 ? bn.bitwiseOR : bn.bitwiseAND, 1) : this.finishOp(bn.assign, 2);
    } else
      this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(bn.assign, 3) : this.finishOp(e6 === 124 ? bn.logicalOR : bn.logicalAND, 2);
  }
  readToken_caret() {
    this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(bn.assign, 2) : this.finishOp(bn.bitwiseXOR, 1);
  }
  readToken_plus_min(e6) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    t2 !== e6 ? t2 === 61 ? this.finishOp(bn.assign, 2) : this.finishOp(bn.plusMin, 1) : this.finishOp(bn.incDec, 2);
  }
  readToken_lt_gt(e6) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    let s2 = 1;
    if (t2 === e6)
      return s2 = e6 === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.state.pos + s2) === 61 ? void this.finishOp(bn.assign, s2 + 1) : void this.finishOp(bn.bitShift, s2);
    t2 === 61 && (s2 = 2), this.finishOp(bn.relational, s2);
  }
  readToken_eq_excl(e6) {
    const t2 = this.input.charCodeAt(this.state.pos + 1);
    if (t2 !== 61)
      return e6 === 61 && t2 === 62 ? (this.state.pos += 2, void this.finishToken(bn.arrow)) : void this.finishOp(e6 === 61 ? bn.eq : bn.bang, 1);
    this.finishOp(bn.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
  }
  readToken_question() {
    const e6 = this.input.charCodeAt(this.state.pos + 1), t2 = this.input.charCodeAt(this.state.pos + 2);
    e6 === 63 ? t2 === 61 ? this.finishOp(bn.assign, 3) : this.finishOp(bn.nullishCoalescing, 2) : e6 !== 46 || t2 >= 48 && t2 <= 57 ? (++this.state.pos, this.finishToken(bn.question)) : (this.state.pos += 2, this.finishToken(bn.questionDot));
  }
  getTokenFromCode(e6) {
    switch (e6) {
      case 46:
        return void this.readToken_dot();
      case 40:
        return ++this.state.pos, void this.finishToken(bn.parenL);
      case 41:
        return ++this.state.pos, void this.finishToken(bn.parenR);
      case 59:
        return ++this.state.pos, void this.finishToken(bn.semi);
      case 44:
        return ++this.state.pos, void this.finishToken(bn.comma);
      case 91:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(this.state.pos, Rn.TupleExpressionBarIncorrectStartSyntaxType);
          this.state.pos += 2, this.finishToken(bn.bracketBarL);
        } else
          ++this.state.pos, this.finishToken(bn.bracketL);
        return;
      case 93:
        return ++this.state.pos, void this.finishToken(bn.bracketR);
      case 123:
        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(this.state.pos, Rn.RecordExpressionBarIncorrectStartSyntaxType);
          this.state.pos += 2, this.finishToken(bn.braceBarL);
        } else
          ++this.state.pos, this.finishToken(bn.braceL);
        return;
      case 125:
        return ++this.state.pos, void this.finishToken(bn.braceR);
      case 58:
        return void (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(bn.doubleColon, 2) : (++this.state.pos, this.finishToken(bn.colon)));
      case 63:
        return void this.readToken_question();
      case 96:
        return ++this.state.pos, void this.finishToken(bn.backQuote);
      case 48: {
        const e7 = this.input.charCodeAt(this.state.pos + 1);
        if (e7 === 120 || e7 === 88)
          return void this.readRadixNumber(16);
        if (e7 === 111 || e7 === 79)
          return void this.readRadixNumber(8);
        if (e7 === 98 || e7 === 66)
          return void this.readRadixNumber(2);
      }
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return void this.readNumber(false);
      case 34:
      case 39:
        return void this.readString(e6);
      case 47:
        return void this.readToken_slash();
      case 37:
      case 42:
        return void this.readToken_mult_modulo(e6);
      case 124:
      case 38:
        return void this.readToken_pipe_amp(e6);
      case 94:
        return void this.readToken_caret();
      case 43:
      case 45:
        return void this.readToken_plus_min(e6);
      case 60:
      case 62:
        return void this.readToken_lt_gt(e6);
      case 61:
      case 33:
        return void this.readToken_eq_excl(e6);
      case 126:
        return void this.finishOp(bn.tilde, 1);
      case 64:
        return ++this.state.pos, void this.finishToken(bn.at);
      case 35:
        return void this.readToken_numberSign();
      case 92:
        return void this.readWord();
      default:
        if (Jn(e6))
          return void this.readWord(e6);
    }
    throw this.raise(this.state.pos, Rn.InvalidOrUnexpectedToken, String.fromCodePoint(e6));
  }
  finishOp(e6, t2) {
    const s2 = this.input.slice(this.state.pos, this.state.pos + t2);
    this.state.pos += t2, this.finishToken(e6, s2);
  }
  readRegexp() {
    const e6 = this.state.start + 1;
    let t2, s2, { pos: r2 } = this.state;
    for (; ; ++r2) {
      if (r2 >= this.length)
        throw this.raise(e6, Rn.UnterminatedRegExp);
      const i3 = this.input.charCodeAt(r2);
      if (wn(i3))
        throw this.raise(e6, Rn.UnterminatedRegExp);
      if (t2)
        t2 = false;
      else {
        if (i3 === 91)
          s2 = true;
        else if (i3 === 93 && s2)
          s2 = false;
        else if (i3 === 47 && !s2)
          break;
        t2 = i3 === 92;
      }
    }
    const i2 = this.input.slice(e6, r2);
    ++r2;
    let a2 = "";
    for (; r2 < this.length; ) {
      const e7 = this.codePointAtPos(r2), t3 = String.fromCharCode(e7);
      if (fo.has(e7))
        a2.includes(t3) && this.raise(r2 + 1, Rn.DuplicateRegExpFlags);
      else {
        if (!Yn(e7) && e7 !== 92)
          break;
        this.raise(r2 + 1, Rn.MalformedRegExpFlags);
      }
      ++r2, a2 += t3;
    }
    this.state.pos = r2, this.finishToken(bn.regexp, { pattern: i2, flags: a2 });
  }
  readInt(e6, t2, s2, r2 = true) {
    const i2 = this.state.pos, a2 = e6 === 16 ? yo.hex : yo.decBinOct, n2 = e6 === 16 ? Ao.hex : e6 === 10 ? Ao.dec : e6 === 8 ? Ao.oct : Ao.bin;
    let o2 = false, u2 = 0;
    for (let i3 = 0, h2 = t2 == null ? 1 / 0 : t2; i3 < h2; ++i3) {
      const t3 = this.input.charCodeAt(this.state.pos);
      let h3;
      if (t3 !== 95) {
        if (h3 = t3 >= 97 ? t3 - 97 + 10 : t3 >= 65 ? t3 - 65 + 10 : mo(t3) ? t3 - 48 : 1 / 0, h3 >= e6)
          if (this.options.errorRecovery && h3 <= 9)
            h3 = 0, this.raise(this.state.start + i3 + 2, Rn.InvalidDigit, e6);
          else {
            if (!s2)
              break;
            h3 = 0, o2 = true;
          }
        ++this.state.pos, u2 = u2 * e6 + h3;
      } else {
        const e7 = this.input.charCodeAt(this.state.pos - 1), t4 = this.input.charCodeAt(this.state.pos + 1);
        (n2.indexOf(t4) === -1 || a2.indexOf(e7) > -1 || a2.indexOf(t4) > -1 || Number.isNaN(t4)) && this.raise(this.state.pos, Rn.UnexpectedNumericSeparator), r2 || this.raise(this.state.pos, Rn.NumericSeparatorInEscapeSequence), ++this.state.pos;
      }
    }
    return this.state.pos === i2 || t2 != null && this.state.pos - i2 !== t2 || o2 ? null : u2;
  }
  readRadixNumber(e6) {
    const t2 = this.state.pos;
    let s2 = false;
    this.state.pos += 2;
    const r2 = this.readInt(e6);
    r2 == null && this.raise(this.state.start + 2, Rn.InvalidDigit, e6);
    const i2 = this.input.charCodeAt(this.state.pos);
    if (i2 === 110)
      ++this.state.pos, s2 = true;
    else if (i2 === 109)
      throw this.raise(t2, Rn.InvalidDecimal);
    if (Jn(this.codePointAtPos(this.state.pos)))
      throw this.raise(this.state.pos, Rn.NumberIdentifier);
    if (s2) {
      const e7 = this.input.slice(t2, this.state.pos).replace(/[_n]/g, "");
      this.finishToken(bn.bigint, e7);
    } else
      this.finishToken(bn.num, r2);
  }
  readNumber(e6) {
    const t2 = this.state.pos;
    let s2 = false, r2 = false, i2 = false, a2 = false, n2 = false;
    e6 || this.readInt(10) !== null || this.raise(t2, Rn.InvalidNumber);
    const o2 = this.state.pos - t2 >= 2 && this.input.charCodeAt(t2) === 48;
    if (o2) {
      const e7 = this.input.slice(t2, this.state.pos);
      if (this.recordStrictModeErrors(t2, Rn.StrictOctalLiteral), !this.state.strict) {
        const s3 = e7.indexOf("_");
        s3 > 0 && this.raise(s3 + t2, Rn.ZeroDigitNumericSeparator);
      }
      n2 = o2 && !/[89]/.test(e7);
    }
    let u2 = this.input.charCodeAt(this.state.pos);
    if (u2 !== 46 || n2 || (++this.state.pos, this.readInt(10), s2 = true, u2 = this.input.charCodeAt(this.state.pos)), u2 !== 69 && u2 !== 101 || n2 || (u2 = this.input.charCodeAt(++this.state.pos), u2 !== 43 && u2 !== 45 || ++this.state.pos, this.readInt(10) === null && this.raise(t2, Rn.InvalidOrMissingExponent), s2 = true, a2 = true, u2 = this.input.charCodeAt(this.state.pos)), u2 === 110 && ((s2 || o2) && this.raise(t2, Rn.InvalidBigIntLiteral), ++this.state.pos, r2 = true), u2 === 109 && (this.expectPlugin("decimal", this.state.pos), (a2 || o2) && this.raise(t2, Rn.InvalidDecimal), ++this.state.pos, i2 = true), Jn(this.codePointAtPos(this.state.pos)))
      throw this.raise(this.state.pos, Rn.NumberIdentifier);
    const h2 = this.input.slice(t2, this.state.pos).replace(/[_mn]/g, "");
    if (r2)
      return void this.finishToken(bn.bigint, h2);
    if (i2)
      return void this.finishToken(bn.decimal, h2);
    const c2 = n2 ? parseInt(h2, 8) : parseFloat(h2);
    this.finishToken(bn.num, c2);
  }
  readCodePoint(e6) {
    let t2;
    if (this.input.charCodeAt(this.state.pos) === 123) {
      const s2 = ++this.state.pos;
      if (t2 = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, e6), ++this.state.pos, t2 !== null && t2 > 1114111) {
        if (!e6)
          return null;
        this.raise(s2, Rn.InvalidCodePoint);
      }
    } else
      t2 = this.readHexChar(4, false, e6);
    return t2;
  }
  readString(e6) {
    let t2 = "", s2 = ++this.state.pos;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(this.state.start, Rn.UnterminatedString);
      const r2 = this.input.charCodeAt(this.state.pos);
      if (r2 === e6)
        break;
      if (r2 === 92)
        t2 += this.input.slice(s2, this.state.pos), t2 += this.readEscapedChar(false), s2 = this.state.pos;
      else if (r2 === 8232 || r2 === 8233)
        ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
      else {
        if (wn(r2))
          throw this.raise(this.state.start, Rn.UnterminatedString);
        ++this.state.pos;
      }
    }
    t2 += this.input.slice(s2, this.state.pos++), this.finishToken(bn.string, t2);
  }
  readTmplToken() {
    let e6 = "", t2 = this.state.pos, s2 = false;
    for (; ; ) {
      if (this.state.pos >= this.length)
        throw this.raise(this.state.start, Rn.UnterminatedTemplate);
      const r2 = this.input.charCodeAt(this.state.pos);
      if (r2 === 96 || r2 === 36 && this.input.charCodeAt(this.state.pos + 1) === 123)
        return this.state.pos === this.state.start && this.match(bn.template) ? r2 === 36 ? (this.state.pos += 2, void this.finishToken(bn.dollarBraceL)) : (++this.state.pos, void this.finishToken(bn.backQuote)) : (e6 += this.input.slice(t2, this.state.pos), void this.finishToken(bn.template, s2 ? null : e6));
      if (r2 === 92) {
        e6 += this.input.slice(t2, this.state.pos);
        const r3 = this.readEscapedChar(true);
        r3 === null ? s2 = true : e6 += r3, t2 = this.state.pos;
      } else if (wn(r2)) {
        switch (e6 += this.input.slice(t2, this.state.pos), ++this.state.pos, r2) {
          case 13:
            this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
          case 10:
            e6 += "\n";
            break;
          default:
            e6 += String.fromCharCode(r2);
        }
        ++this.state.curLine, this.state.lineStart = this.state.pos, t2 = this.state.pos;
      } else
        ++this.state.pos;
    }
  }
  recordStrictModeErrors(e6, t2) {
    this.state.strict && !this.state.strictErrors.has(e6) ? this.raise(e6, t2) : this.state.strictErrors.set(e6, t2);
  }
  readEscapedChar(e6) {
    const t2 = !e6, s2 = this.input.charCodeAt(++this.state.pos);
    switch (++this.state.pos, s2) {
      case 110:
        return "\n";
      case 114:
        return "\r";
      case 120: {
        const e7 = this.readHexChar(2, false, t2);
        return e7 === null ? null : String.fromCharCode(e7);
      }
      case 117: {
        const e7 = this.readCodePoint(t2);
        return e7 === null ? null : String.fromCodePoint(e7);
      }
      case 116:
        return "	";
      case 98:
        return "\b";
      case 118:
        return "\v";
      case 102:
        return "\f";
      case 13:
        this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
      case 10:
        this.state.lineStart = this.state.pos, ++this.state.curLine;
      case 8232:
      case 8233:
        return "";
      case 56:
      case 57:
        if (e6)
          return null;
        this.recordStrictModeErrors(this.state.pos - 1, Rn.StrictNumericEscape);
      default:
        if (s2 >= 48 && s2 <= 55) {
          const t3 = this.state.pos - 1;
          let s3 = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], r2 = parseInt(s3, 8);
          r2 > 255 && (s3 = s3.slice(0, -1), r2 = parseInt(s3, 8)), this.state.pos += s3.length - 1;
          const i2 = this.input.charCodeAt(this.state.pos);
          if (s3 !== "0" || i2 === 56 || i2 === 57) {
            if (e6)
              return null;
            this.recordStrictModeErrors(t3, Rn.StrictNumericEscape);
          }
          return String.fromCharCode(r2);
        }
        return String.fromCharCode(s2);
    }
  }
  readHexChar(e6, t2, s2) {
    const r2 = this.state.pos, i2 = this.readInt(16, e6, t2, false);
    return i2 === null && (s2 ? this.raise(r2, Rn.InvalidEscapeSequence) : this.state.pos = r2 - 1), i2;
  }
  readWord1(e6) {
    this.state.containsEsc = false;
    let t2 = "";
    const s2 = this.state.pos;
    let r2 = this.state.pos;
    for (e6 !== void 0 && (this.state.pos += e6 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
      const e7 = this.codePointAtPos(this.state.pos);
      if (Yn(e7))
        this.state.pos += e7 <= 65535 ? 1 : 2;
      else {
        if (e7 !== 92)
          break;
        {
          this.state.containsEsc = true, t2 += this.input.slice(r2, this.state.pos);
          const e8 = this.state.pos, i2 = this.state.pos === s2 ? Jn : Yn;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, Rn.MissingUnicodeEscape), r2 = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          const a2 = this.readCodePoint(true);
          a2 !== null && (i2(a2) || this.raise(e8, Rn.EscapedCharNotAnIdentifier), t2 += String.fromCodePoint(a2)), r2 = this.state.pos;
        }
      }
    }
    return t2 + this.input.slice(r2, this.state.pos);
  }
  readWord(e6) {
    const t2 = this.readWord1(e6), s2 = xn.get(t2) || bn.name;
    this.finishToken(s2, t2);
  }
  checkKeywordEscapes() {
    const e6 = this.state.type.keyword;
    e6 && this.state.containsEsc && this.raise(this.state.start, Rn.InvalidEscapedReservedWord, e6);
  }
  updateContext(e6) {
    var t2, s2;
    (t2 = (s2 = this.state.type).updateContext) == null || t2.call(s2, this.state.context);
  }
} {
  addExtra(e6, t2, s2) {
    if (!e6)
      return;
    (e6.extra = e6.extra || {})[t2] = s2;
  }
  isRelational(e6) {
    return this.match(bn.relational) && this.state.value === e6;
  }
  expectRelational(e6) {
    this.isRelational(e6) ? this.next() : this.unexpected(null, bn.relational);
  }
  isContextual(e6) {
    return this.match(bn.name) && this.state.value === e6 && !this.state.containsEsc;
  }
  isUnparsedContextual(e6, t2) {
    const s2 = e6 + t2.length;
    if (this.input.slice(e6, s2) === t2) {
      const e7 = this.input.charCodeAt(s2);
      return !(Yn(e7) || (64512 & e7) == 55296);
    }
    return false;
  }
  isLookaheadContextual(e6) {
    const t2 = this.nextTokenStart();
    return this.isUnparsedContextual(t2, e6);
  }
  eatContextual(e6) {
    return this.isContextual(e6) && this.eat(bn.name);
  }
  expectContextual(e6, t2) {
    this.eatContextual(e6) || this.unexpected(null, t2);
  }
  canInsertSemicolon() {
    return this.match(bn.eof) || this.match(bn.braceR) || this.hasPrecedingLineBreak();
  }
  hasPrecedingLineBreak() {
    return Pn.test(this.input.slice(this.state.lastTokEnd, this.state.start));
  }
  hasFollowingLineBreak() {
    return Bn.lastIndex = this.state.end, Bn.test(this.input);
  }
  isLineTerminator() {
    return this.eat(bn.semi) || this.canInsertSemicolon();
  }
  semicolon(e6 = true) {
    (e6 ? this.isLineTerminator() : this.eat(bn.semi)) || this.raise(this.state.lastTokEnd, Rn.MissingSemicolon);
  }
  expect(e6, t2) {
    this.eat(e6) || this.unexpected(t2, e6);
  }
  assertNoSpace(e6 = "Unexpected space.") {
    this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, { code: Mn.SyntaxError, reasonCode: "UnexpectedSpace", template: e6 });
  }
  unexpected(e6, t2 = { code: Mn.SyntaxError, reasonCode: "UnexpectedToken", template: "Unexpected token" }) {
    throw t2 instanceof Cn && (t2 = { code: Mn.SyntaxError, reasonCode: "UnexpectedToken", template: `Unexpected token, expected "${t2.label}"` }), this.raise(e6 != null ? e6 : this.state.start, t2);
  }
  expectPlugin(e6, t2) {
    if (!this.hasPlugin(e6))
      throw this.raiseWithData(t2 != null ? t2 : this.state.start, { missingPlugin: [e6] }, `This experimental syntax requires enabling the parser plugin: '${e6}'`);
    return true;
  }
  expectOnePlugin(e6, t2) {
    if (!e6.some((e7) => this.hasPlugin(e7)))
      throw this.raiseWithData(t2 != null ? t2 : this.state.start, { missingPlugin: e6 }, `This experimental syntax requires enabling one of the following parser plugin(s): '${e6.join(", ")}'`);
  }
  tryParse(e6, t2 = this.state.clone()) {
    const s2 = { node: null };
    try {
      const r2 = e6((e7 = null) => {
        throw s2.node = e7, s2;
      });
      if (this.state.errors.length > t2.errors.length) {
        const e7 = this.state;
        return this.state = t2, this.state.tokensLength = e7.tokensLength, { node: r2, error: e7.errors[t2.errors.length], thrown: false, aborted: false, failState: e7 };
      }
      return { node: r2, error: null, thrown: false, aborted: false, failState: null };
    } catch (e7) {
      const r2 = this.state;
      if (this.state = t2, e7 instanceof SyntaxError)
        return { node: null, error: e7, thrown: true, aborted: false, failState: r2 };
      if (e7 === s2)
        return { node: s2.node, error: null, thrown: false, aborted: true, failState: r2 };
      throw e7;
    }
  }
  checkExpressionErrors(e6, t2) {
    if (!e6)
      return false;
    const { shorthandAssign: s2, doubleProto: r2, optionalParameters: i2 } = e6;
    if (!t2)
      return s2 >= 0 || r2 >= 0 || i2 >= 0;
    s2 >= 0 && this.unexpected(s2), r2 >= 0 && this.raise(r2, Rn.DuplicateProto), i2 >= 0 && this.unexpected(i2);
  }
  isLiteralPropertyName() {
    return this.match(bn.name) || !!this.state.type.keyword || this.match(bn.string) || this.match(bn.num) || this.match(bn.bigint) || this.match(bn.decimal);
  }
  isPrivateName(e6) {
    return e6.type === "PrivateName";
  }
  getPrivateNameSV(e6) {
    return e6.id.name;
  }
  hasPropertyAsPrivateName(e6) {
    return (e6.type === "MemberExpression" || e6.type === "OptionalMemberExpression") && this.isPrivateName(e6.property);
  }
  isOptionalChain(e6) {
    return e6.type === "OptionalMemberExpression" || e6.type === "OptionalCallExpression";
  }
  isObjectProperty(e6) {
    return e6.type === "ObjectProperty";
  }
  isObjectMethod(e6) {
    return e6.type === "ObjectMethod";
  }
  initializeScopes(e6 = this.options.sourceType === "module") {
    const t2 = this.state.labels;
    this.state.labels = [];
    const s2 = this.exportedIdentifiers;
    this.exportedIdentifiers = new Set();
    const r2 = this.inModule;
    this.inModule = e6;
    const i2 = this.scope, a2 = this.getScopeHandler();
    this.scope = new a2(this.raise.bind(this), this.inModule);
    const n2 = this.prodParam;
    this.prodParam = new To();
    const o2 = this.classScope;
    this.classScope = new xo(this.raise.bind(this));
    const u2 = this.expressionScope;
    return this.expressionScope = new bo(this.raise.bind(this)), () => {
      this.state.labels = t2, this.exportedIdentifiers = s2, this.inModule = r2, this.scope = i2, this.prodParam = n2, this.classScope = o2, this.expressionScope = u2;
    };
  }
  enterInitialScopes() {
    let e6 = 0;
    this.inModule && (e6 |= 2), this.scope.enter(1), this.prodParam.enter(e6);
  }
} {
  startNode() {
    return new Bo(this, this.state.start, this.state.startLoc);
  }
  startNodeAt(e6, t2) {
    return new Bo(this, e6, t2);
  }
  startNodeAtNode(e6) {
    return this.startNodeAt(e6.start, e6.loc.start);
  }
  finishNode(e6, t2) {
    return this.finishNodeAt(e6, t2, this.state.lastTokEnd, this.state.lastTokEndLoc);
  }
  finishNodeAt(e6, t2, s2, r2) {
    return e6.type = t2, e6.end = s2, e6.loc.end = r2, this.options.ranges && (e6.range[1] = s2), this.options.attachComment && this.processComment(e6), e6;
  }
  resetStartLocation(e6, t2, s2) {
    e6.start = t2, e6.loc.start = s2, this.options.ranges && (e6.range[0] = t2);
  }
  resetEndLocation(e6, t2 = this.state.lastTokEnd, s2 = this.state.lastTokEndLoc) {
    e6.end = t2, e6.loc.end = s2, this.options.ranges && (e6.range[1] = t2);
  }
  resetStartLocationFromNode(e6, t2) {
    this.resetStartLocation(e6, t2.start, t2.loc.start);
  }
} {
  toAssignable(e6, t2 = false) {
    var s2, r2;
    let i2;
    switch ((e6.type === "ParenthesizedExpression" || (s2 = e6.extra) != null && s2.parenthesized) && (i2 = nu(e6), t2 ? i2.type === "Identifier" ? this.expressionScope.recordParenthesizedIdentifierError(e6.start, Rn.InvalidParenthesizedAssignment) : i2.type !== "MemberExpression" && this.raise(e6.start, Rn.InvalidParenthesizedAssignment) : this.raise(e6.start, Rn.InvalidParenthesizedAssignment)), e6.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        e6.type = "ObjectPattern";
        for (let s3 = 0, r3 = e6.properties.length, i3 = r3 - 1; s3 < r3; s3++) {
          var a2;
          const r4 = e6.properties[s3], n2 = s3 === i3;
          this.toAssignableObjectExpressionProp(r4, n2, t2), n2 && r4.type === "RestElement" && (a2 = e6.extra) != null && a2.trailingComma && this.raiseRestNotLast(e6.extra.trailingComma);
        }
        break;
      case "ObjectProperty":
        this.toAssignable(e6.value, t2);
        break;
      case "SpreadElement": {
        this.checkToRestConversion(e6), e6.type = "RestElement";
        const s3 = e6.argument;
        this.toAssignable(s3, t2);
        break;
      }
      case "ArrayExpression":
        e6.type = "ArrayPattern", this.toAssignableList(e6.elements, (r2 = e6.extra) == null ? void 0 : r2.trailingComma, t2);
        break;
      case "AssignmentExpression":
        e6.operator !== "=" && this.raise(e6.left.end, Rn.MissingEqInAssignment), e6.type = "AssignmentPattern", delete e6.operator, this.toAssignable(e6.left, t2);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(i2, t2);
    }
    return e6;
  }
  toAssignableObjectExpressionProp(e6, t2, s2) {
    if (e6.type === "ObjectMethod") {
      const t3 = e6.kind === "get" || e6.kind === "set" ? Rn.PatternHasAccessor : Rn.PatternHasMethod;
      this.raise(e6.key.start, t3);
    } else
      e6.type !== "SpreadElement" || t2 ? this.toAssignable(e6, s2) : this.raiseRestNotLast(e6.start);
  }
  toAssignableList(e6, t2, s2) {
    let r2 = e6.length;
    if (r2) {
      const i2 = e6[r2 - 1];
      if ((i2 == null ? void 0 : i2.type) === "RestElement")
        --r2;
      else if ((i2 == null ? void 0 : i2.type) === "SpreadElement") {
        i2.type = "RestElement";
        let e7 = i2.argument;
        this.toAssignable(e7, s2), e7 = nu(e7), e7.type !== "Identifier" && e7.type !== "MemberExpression" && e7.type !== "ArrayPattern" && e7.type !== "ObjectPattern" && this.unexpected(e7.start), t2 && this.raiseTrailingCommaAfterRest(t2), --r2;
      }
    }
    for (let t3 = 0; t3 < r2; t3++) {
      const r3 = e6[t3];
      r3 && (this.toAssignable(r3, s2), r3.type === "RestElement" && this.raiseRestNotLast(r3.start));
    }
    return e6;
  }
  isAssignable(e6, t2) {
    switch (e6.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        return true;
      case "ObjectExpression": {
        const t3 = e6.properties.length - 1;
        return e6.properties.every((e7, s2) => e7.type !== "ObjectMethod" && (s2 === t3 || e7.type !== "SpreadElement") && this.isAssignable(e7));
      }
      case "ObjectProperty":
        return this.isAssignable(e6.value);
      case "SpreadElement":
        return this.isAssignable(e6.argument);
      case "ArrayExpression":
        return e6.elements.every((e7) => e7 === null || this.isAssignable(e7));
      case "AssignmentExpression":
        return e6.operator === "=";
      case "ParenthesizedExpression":
        return this.isAssignable(e6.expression);
      case "MemberExpression":
      case "OptionalMemberExpression":
        return !t2;
      default:
        return false;
    }
  }
  toReferencedList(e6, t2) {
    return e6;
  }
  toReferencedListDeep(e6, t2) {
    this.toReferencedList(e6, t2);
    for (const t3 of e6)
      (t3 == null ? void 0 : t3.type) === "ArrayExpression" && this.toReferencedListDeep(t3.elements);
  }
  parseSpread(e6, t2) {
    const s2 = this.startNode();
    return this.next(), s2.argument = this.parseMaybeAssignAllowIn(e6, void 0, t2), this.finishNode(s2, "SpreadElement");
  }
  parseRestBinding() {
    const e6 = this.startNode();
    return this.next(), e6.argument = this.parseBindingAtom(), this.finishNode(e6, "RestElement");
  }
  parseBindingAtom() {
    switch (this.state.type) {
      case bn.bracketL: {
        const e6 = this.startNode();
        return this.next(), e6.elements = this.parseBindingList(bn.bracketR, 93, true), this.finishNode(e6, "ArrayPattern");
      }
      case bn.braceL:
        return this.parseObjectLike(bn.braceR, true);
    }
    return this.parseIdentifier();
  }
  parseBindingList(e6, t2, s2, r2) {
    const i2 = [];
    let a2 = true;
    for (; !this.eat(e6); )
      if (a2 ? a2 = false : this.expect(bn.comma), s2 && this.match(bn.comma))
        i2.push(null);
      else {
        if (this.eat(e6))
          break;
        if (this.match(bn.ellipsis)) {
          i2.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(t2), this.expect(e6);
          break;
        }
        {
          const e7 = [];
          for (this.match(bn.at) && this.hasPlugin("decorators") && this.raise(this.state.start, Rn.UnsupportedParameterDecorator); this.match(bn.at); )
            e7.push(this.parseDecorator());
          i2.push(this.parseAssignableListItem(r2, e7));
        }
      }
    return i2;
  }
  parseAssignableListItem(e6, t2) {
    const s2 = this.parseMaybeDefault();
    this.parseAssignableListItemTypes(s2);
    const r2 = this.parseMaybeDefault(s2.start, s2.loc.start, s2);
    return t2.length && (s2.decorators = t2), r2;
  }
  parseAssignableListItemTypes(e6) {
    return e6;
  }
  parseMaybeDefault(e6, t2, s2) {
    var r2, i2, a2;
    if (t2 = (r2 = t2) != null ? r2 : this.state.startLoc, e6 = (i2 = e6) != null ? i2 : this.state.start, s2 = (a2 = s2) != null ? a2 : this.parseBindingAtom(), !this.eat(bn.eq))
      return s2;
    const n2 = this.startNodeAt(e6, t2);
    return n2.left = s2, n2.right = this.parseMaybeAssignAllowIn(), this.finishNode(n2, "AssignmentPattern");
  }
  checkLVal(e6, t2, s2 = 64, r2, i2, a2 = false) {
    switch (e6.type) {
      case "Identifier": {
        const { name: t3 } = e6;
        this.state.strict && (a2 ? no(t3, this.inModule) : ao(t3)) && this.raise(e6.start, s2 === 64 ? Rn.StrictEvalArguments : Rn.StrictEvalArgumentsBinding, t3), r2 && (r2.has(t3) ? this.raise(e6.start, Rn.ParamDupe) : r2.add(t3)), i2 && t3 === "let" && this.raise(e6.start, Rn.LetInLexicalBinding), 64 & s2 || this.scope.declareName(t3, s2, e6.start);
        break;
      }
      case "MemberExpression":
        s2 !== 64 && this.raise(e6.start, Rn.InvalidPropertyBindingPattern);
        break;
      case "ObjectPattern":
        for (let t3 of e6.properties) {
          if (this.isObjectProperty(t3))
            t3 = t3.value;
          else if (this.isObjectMethod(t3))
            continue;
          this.checkLVal(t3, "object destructuring pattern", s2, r2, i2);
        }
        break;
      case "ArrayPattern":
        for (const t3 of e6.elements)
          t3 && this.checkLVal(t3, "array destructuring pattern", s2, r2, i2);
        break;
      case "AssignmentPattern":
        this.checkLVal(e6.left, "assignment pattern", s2, r2);
        break;
      case "RestElement":
        this.checkLVal(e6.argument, "rest element", s2, r2);
        break;
      case "ParenthesizedExpression":
        this.checkLVal(e6.expression, "parenthesized expression", s2, r2);
        break;
      default:
        this.raise(e6.start, s2 === 64 ? Rn.InvalidLhs : Rn.InvalidLhsBinding, t2);
    }
  }
  checkToRestConversion(e6) {
    e6.argument.type !== "Identifier" && e6.argument.type !== "MemberExpression" && this.raise(e6.argument.start, Rn.InvalidRestAssignmentPattern);
  }
  checkCommaAfterRest(e6) {
    this.match(bn.comma) && (this.lookaheadCharCode() === e6 ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start));
  }
  raiseRestNotLast(e6) {
    throw this.raise(e6, Rn.ElementAfterRest);
  }
  raiseTrailingCommaAfterRest(e6) {
    this.raise(e6, Rn.RestTrailingComma);
  }
} {
  checkProto(e6, t2, s2, r2) {
    if (e6.type === "SpreadElement" || this.isObjectMethod(e6) || e6.computed || e6.shorthand)
      return;
    const i2 = e6.key;
    if ((i2.type === "Identifier" ? i2.name : i2.value) === "__proto__") {
      if (t2)
        return void this.raise(i2.start, Rn.RecordNoProto);
      s2.used && (r2 ? r2.doubleProto === -1 && (r2.doubleProto = i2.start) : this.raise(i2.start, Rn.DuplicateProto)), s2.used = true;
    }
  }
  shouldExitDescending(e6, t2) {
    return e6.type === "ArrowFunctionExpression" && e6.start === t2;
  }
  getExpression() {
    this.enterInitialScopes(), this.nextToken();
    const e6 = this.parseExpression();
    return this.match(bn.eof) || this.unexpected(), this.finalizeRemainingComments(), e6.comments = this.state.comments, e6.errors = this.state.errors, this.options.tokens && (e6.tokens = this.tokens), e6;
  }
  parseExpression(e6, t2) {
    return e6 ? this.disallowInAnd(() => this.parseExpressionBase(t2)) : this.allowInAnd(() => this.parseExpressionBase(t2));
  }
  parseExpressionBase(e6) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.parseMaybeAssign(e6);
    if (this.match(bn.comma)) {
      const i2 = this.startNodeAt(t2, s2);
      for (i2.expressions = [r2]; this.eat(bn.comma); )
        i2.expressions.push(this.parseMaybeAssign(e6));
      return this.toReferencedList(i2.expressions), this.finishNode(i2, "SequenceExpression");
    }
    return r2;
  }
  parseMaybeAssignDisallowIn(e6, t2) {
    return this.disallowInAnd(() => this.parseMaybeAssign(e6, t2));
  }
  parseMaybeAssignAllowIn(e6, t2) {
    return this.allowInAnd(() => this.parseMaybeAssign(e6, t2));
  }
  setOptionalParametersError(e6, t2) {
    var s2;
    e6.optionalParameters = (s2 = t2 == null ? void 0 : t2.pos) != null ? s2 : this.state.start;
  }
  parseMaybeAssign(e6, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc;
    if (this.isContextual("yield") && this.prodParam.hasYield) {
      let e7 = this.parseYield();
      return t2 && (e7 = t2.call(this, e7, s2, r2)), e7;
    }
    let i2;
    e6 ? i2 = false : (e6 = new So(), i2 = true), (this.match(bn.parenL) || this.match(bn.name)) && (this.state.potentialArrowAt = this.state.start);
    let a2 = this.parseMaybeConditional(e6);
    if (t2 && (a2 = t2.call(this, a2, s2, r2)), this.state.type.isAssign) {
      const t3 = this.startNodeAt(s2, r2), i3 = this.state.value;
      t3.operator = i3;
      if (a2.type === "BinaryExpression" && a2.operator === "|>" && this.getPluginOption("pipelineOperator", "proposal") === "hack")
        throw this.raise(this.state.start, Rn.PipeBodyIsTighter, i3);
      return this.match(bn.eq) ? (t3.left = this.toAssignable(a2, true), e6.doubleProto = -1) : t3.left = a2, e6.shorthandAssign >= t3.left.start && (e6.shorthandAssign = -1), this.checkLVal(a2, "assignment expression"), this.next(), t3.right = this.parseMaybeAssign(), this.finishNode(t3, "AssignmentExpression");
    }
    return i2 && this.checkExpressionErrors(e6, true), a2;
  }
  parseMaybeConditional(e6) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseExprOps(e6);
    return this.shouldExitDescending(i2, r2) ? i2 : this.parseConditional(i2, t2, s2, e6);
  }
  parseConditional(e6, t2, s2, r2) {
    if (this.eat(bn.question)) {
      const r3 = this.startNodeAt(t2, s2);
      return r3.test = e6, r3.consequent = this.parseMaybeAssignAllowIn(), this.expect(bn.colon), r3.alternate = this.parseMaybeAssign(), this.finishNode(r3, "ConditionalExpression");
    }
    return e6;
  }
  parseMaybeUnaryOrPrivate(e6) {
    return this.match(bn.privateName) ? this.parsePrivateName() : this.parseMaybeUnary(e6);
  }
  parseExprOps(e6) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseMaybeUnaryOrPrivate(e6);
    return this.shouldExitDescending(i2, r2) ? i2 : this.parseExprOp(i2, t2, s2, -1);
  }
  parseExprOp(e6, t2, s2, r2) {
    if (this.isPrivateName(e6)) {
      const t3 = this.getPrivateNameSV(e6), { start: s3 } = e6;
      (r2 >= bn._in.binop || !this.prodParam.hasIn || !this.match(bn._in)) && this.raise(s3, Rn.PrivateInExpectedIn, t3), this.classScope.usePrivateName(t3, s3);
    }
    let i2 = this.state.type.binop;
    if (i2 != null && (this.prodParam.hasIn || !this.match(bn._in)) && i2 > r2) {
      const a2 = this.state.type;
      if (a2 === bn.pipeline) {
        if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
          return e6;
        this.checkPipelineAtInfixOperator(e6, t2);
      }
      const n2 = this.startNodeAt(t2, s2);
      n2.left = e6, n2.operator = this.state.value;
      const o2 = a2 === bn.logicalOR || a2 === bn.logicalAND, u2 = a2 === bn.nullishCoalescing;
      if (u2 && (i2 = bn.logicalAND.binop), this.next(), a2 === bn.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal" && this.match(bn.name) && this.state.value === "await" && this.prodParam.hasAwait)
        throw this.raise(this.state.start, Rn.UnexpectedAwaitAfterPipelineBody);
      n2.right = this.parseExprOpRightExpr(a2, i2), this.finishNode(n2, o2 || u2 ? "LogicalExpression" : "BinaryExpression");
      const h2 = this.state.type;
      if (u2 && (h2 === bn.logicalOR || h2 === bn.logicalAND) || o2 && h2 === bn.nullishCoalescing)
        throw this.raise(this.state.start, Rn.MixingCoalesceWithLogical);
      return this.parseExprOp(n2, t2, s2, r2);
    }
    return e6;
  }
  parseExprOpRightExpr(e6, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc;
    switch (e6) {
      case bn.pipeline:
        switch (this.getPluginOption("pipelineOperator", "proposal")) {
          case "hack":
            return this.withTopicBindingContext(() => {
              const r3 = this.parseHackPipeBody(e6, t2);
              return this.checkHackPipeBodyEarlyErrors(s2), r3;
            });
          case "smart":
            return this.withTopicBindingContext(() => {
              const i2 = this.parseHackPipeBody(e6, t2);
              return this.parseSmartPipelineBodyInStyle(i2, s2, r2);
            });
          case "fsharp":
            return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t2));
        }
      default:
        return this.parseExprOpBaseRightExpr(e6, t2);
    }
  }
  parseExprOpBaseRightExpr(e6, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc;
    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s2, r2, e6.rightAssociative ? t2 - 1 : t2);
  }
  parseHackPipeBody(e6, t2) {
    if (this.prodParam.hasYield && this.isContextual("yield"))
      throw this.raise(this.state.start, Rn.PipeBodyIsTighter, this.state.value);
    return this.parseExprOpBaseRightExpr(e6, t2);
  }
  checkExponentialAfterUnary(e6) {
    this.match(bn.exponent) && this.raise(e6.argument.start, Rn.UnexpectedTokenUnaryExponentiation);
  }
  parseMaybeUnary(e6, t2) {
    const s2 = this.state.start, r2 = this.state.startLoc, i2 = this.isContextual("await");
    if (i2 && this.isAwaitAllowed()) {
      this.next();
      const e7 = this.parseAwait(s2, r2);
      return t2 || this.checkExponentialAfterUnary(e7), e7;
    }
    const a2 = this.match(bn.incDec), n2 = this.startNode();
    if (this.state.type.prefix) {
      n2.operator = this.state.value, n2.prefix = true, this.match(bn._throw) && this.expectPlugin("throwExpressions");
      const s3 = this.match(bn._delete);
      if (this.next(), n2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e6, true), this.state.strict && s3) {
        const e7 = n2.argument;
        e7.type === "Identifier" ? this.raise(n2.start, Rn.StrictDelete) : this.hasPropertyAsPrivateName(e7) && this.raise(n2.start, Rn.DeletePrivateField);
      }
      if (!a2)
        return t2 || this.checkExponentialAfterUnary(n2), this.finishNode(n2, "UnaryExpression");
    }
    const o2 = this.parseUpdate(n2, a2, e6);
    if (i2) {
      if ((this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(bn.modulo)) && !this.isAmbiguousAwait())
        return this.raiseOverwrite(s2, Rn.AwaitNotInAsyncContext), this.parseAwait(s2, r2);
    }
    return o2;
  }
  parseUpdate(e6, t2, s2) {
    if (t2)
      return this.checkLVal(e6.argument, "prefix operation"), this.finishNode(e6, "UpdateExpression");
    const r2 = this.state.start, i2 = this.state.startLoc;
    let a2 = this.parseExprSubscripts(s2);
    if (this.checkExpressionErrors(s2, false))
      return a2;
    for (; this.state.type.postfix && !this.canInsertSemicolon(); ) {
      const e7 = this.startNodeAt(r2, i2);
      e7.operator = this.state.value, e7.prefix = false, e7.argument = a2, this.checkLVal(a2, "postfix operation"), this.next(), a2 = this.finishNode(e7, "UpdateExpression");
    }
    return a2;
  }
  parseExprSubscripts(e6) {
    const t2 = this.state.start, s2 = this.state.startLoc, r2 = this.state.potentialArrowAt, i2 = this.parseExprAtom(e6);
    return this.shouldExitDescending(i2, r2) ? i2 : this.parseSubscripts(i2, t2, s2);
  }
  parseSubscripts(e6, t2, s2, r2) {
    const i2 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(e6), stop: false };
    do {
      e6 = this.parseSubscript(e6, t2, s2, r2, i2), i2.maybeAsyncArrow = false;
    } while (!i2.stop);
    return e6;
  }
  parseSubscript(e6, t2, s2, r2, i2) {
    if (!r2 && this.eat(bn.doubleColon))
      return this.parseBind(e6, t2, s2, r2, i2);
    if (this.match(bn.backQuote))
      return this.parseTaggedTemplateExpression(e6, t2, s2, i2);
    let a2 = false;
    if (this.match(bn.questionDot)) {
      if (r2 && this.lookaheadCharCode() === 40)
        return i2.stop = true, e6;
      i2.optionalChainMember = a2 = true, this.next();
    }
    if (!r2 && this.match(bn.parenL))
      return this.parseCoverCallAndAsyncArrowHead(e6, t2, s2, i2, a2);
    {
      const r3 = this.eat(bn.bracketL);
      return r3 || a2 || this.eat(bn.dot) ? this.parseMember(e6, t2, s2, i2, r3, a2) : (i2.stop = true, e6);
    }
  }
  parseMember(e6, t2, s2, r2, i2, a2) {
    const n2 = this.startNodeAt(t2, s2);
    n2.object = e6, n2.computed = i2;
    const o2 = !i2 && this.match(bn.privateName) && this.state.value, u2 = i2 ? this.parseExpression() : o2 ? this.parsePrivateName() : this.parseIdentifier(true);
    return o2 !== false && (n2.object.type === "Super" && this.raise(t2, Rn.SuperPrivateField), this.classScope.usePrivateName(o2, u2.start)), n2.property = u2, i2 && this.expect(bn.bracketR), r2.optionalChainMember ? (n2.optional = a2, this.finishNode(n2, "OptionalMemberExpression")) : this.finishNode(n2, "MemberExpression");
  }
  parseBind(e6, t2, s2, r2, i2) {
    const a2 = this.startNodeAt(t2, s2);
    return a2.object = e6, a2.callee = this.parseNoCallExpr(), i2.stop = true, this.parseSubscripts(this.finishNode(a2, "BindExpression"), t2, s2, r2);
  }
  parseCoverCallAndAsyncArrowHead(e6, t2, s2, r2, i2) {
    const a2 = this.state.maybeInArrowParameters;
    let n2 = null;
    this.state.maybeInArrowParameters = true, this.next();
    let o2 = this.startNodeAt(t2, s2);
    return o2.callee = e6, r2.maybeAsyncArrow && (this.expressionScope.enter(new go(2)), n2 = new So()), r2.optionalChainMember && (o2.optional = i2), o2.arguments = i2 ? this.parseCallExpressionArguments(bn.parenR) : this.parseCallExpressionArguments(bn.parenR, e6.type === "Import", e6.type !== "Super", o2, n2), this.finishCallExpression(o2, r2.optionalChainMember), r2.maybeAsyncArrow && this.shouldParseAsyncArrow() && !i2 ? (r2.stop = true, this.expressionScope.validateAsPattern(), this.expressionScope.exit(), o2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t2, s2), o2)) : (r2.maybeAsyncArrow && (this.checkExpressionErrors(n2, true), this.expressionScope.exit()), this.toReferencedArguments(o2)), this.state.maybeInArrowParameters = a2, o2;
  }
  toReferencedArguments(e6, t2) {
    this.toReferencedListDeep(e6.arguments, t2);
  }
  parseTaggedTemplateExpression(e6, t2, s2, r2) {
    const i2 = this.startNodeAt(t2, s2);
    return i2.tag = e6, i2.quasi = this.parseTemplate(true), r2.optionalChainMember && this.raise(t2, Rn.OptionalChainingNoTemplate), this.finishNode(i2, "TaggedTemplateExpression");
  }
  atPossibleAsyncArrow(e6) {
    return e6.type === "Identifier" && e6.name === "async" && this.state.lastTokEnd === e6.end && !this.canInsertSemicolon() && e6.end - e6.start == 5 && e6.start === this.state.potentialArrowAt;
  }
  finishCallExpression(e6, t2) {
    if (e6.callee.type === "Import")
      if (e6.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), e6.arguments.length === 0 || e6.arguments.length > 2)
        this.raise(e6.start, Rn.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
      else
        for (const t3 of e6.arguments)
          t3.type === "SpreadElement" && this.raise(t3.start, Rn.ImportCallSpreadArgument);
    return this.finishNode(e6, t2 ? "OptionalCallExpression" : "CallExpression");
  }
  parseCallExpressionArguments(e6, t2, s2, r2, i2) {
    const a2 = [];
    let n2 = true;
    const o2 = this.state.inFSharpPipelineDirectBody;
    for (this.state.inFSharpPipelineDirectBody = false; !this.eat(e6); ) {
      if (n2)
        n2 = false;
      else if (this.expect(bn.comma), this.match(e6)) {
        !t2 || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(this.state.lastTokStart, Rn.ImportCallArgumentTrailingComma), r2 && this.addExtra(r2, "trailingComma", this.state.lastTokStart), this.next();
        break;
      }
      a2.push(this.parseExprListItem(false, i2, s2));
    }
    return this.state.inFSharpPipelineDirectBody = o2, a2;
  }
  shouldParseAsyncArrow() {
    return this.match(bn.arrow) && !this.canInsertSemicolon();
  }
  parseAsyncArrowFromCallExpression(e6, t2) {
    var s2;
    return this.resetPreviousNodeTrailingComments(t2), this.expect(bn.arrow), this.parseArrowExpression(e6, t2.arguments, true, (s2 = t2.extra) == null ? void 0 : s2.trailingComma), Ln(e6, t2.innerComments), Ln(e6, t2.callee.trailingComments), e6;
  }
  parseNoCallExpr() {
    const e6 = this.state.start, t2 = this.state.startLoc;
    return this.parseSubscripts(this.parseExprAtom(), e6, t2, true);
  }
  parseExprAtom(e6) {
    let t2;
    switch (this.state.type) {
      case bn._super:
        return this.parseSuper();
      case bn._import:
        return t2 = this.startNode(), this.next(), this.match(bn.dot) ? this.parseImportMetaProperty(t2) : (this.match(bn.parenL) || this.raise(this.state.lastTokStart, Rn.UnsupportedImport), this.finishNode(t2, "Import"));
      case bn._this:
        return t2 = this.startNode(), this.next(), this.finishNode(t2, "ThisExpression");
      case bn.name: {
        if (this.isContextual("module") && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
          return this.parseModuleExpression();
        const e7 = this.state.potentialArrowAt === this.state.start, t3 = this.state.containsEsc, s2 = this.parseIdentifier();
        if (!t3 && s2.name === "async" && !this.canInsertSemicolon()) {
          if (this.match(bn._function))
            return this.resetPreviousNodeTrailingComments(s2), this.next(), this.parseFunction(this.startNodeAtNode(s2), void 0, true);
          if (this.match(bn.name))
            return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(s2)) : s2;
          if (this.match(bn._do))
            return this.resetPreviousNodeTrailingComments(s2), this.parseDo(this.startNodeAtNode(s2), true);
        }
        return e7 && this.match(bn.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(s2), [s2], false)) : s2;
      }
      case bn._do:
        return this.parseDo(this.startNode(), false);
      case bn.slash:
      case bn.slashAssign:
        return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
      case bn.num:
        return this.parseNumericLiteral(this.state.value);
      case bn.bigint:
        return this.parseBigIntLiteral(this.state.value);
      case bn.decimal:
        return this.parseDecimalLiteral(this.state.value);
      case bn.string:
        return this.parseStringLiteral(this.state.value);
      case bn._null:
        return this.parseNullLiteral();
      case bn._true:
        return this.parseBooleanLiteral(true);
      case bn._false:
        return this.parseBooleanLiteral(false);
      case bn.parenL: {
        const e7 = this.state.potentialArrowAt === this.state.start;
        return this.parseParenAndDistinguishExpression(e7);
      }
      case bn.bracketBarL:
      case bn.bracketHashL:
        return this.parseArrayLike(this.state.type === bn.bracketBarL ? bn.bracketBarR : bn.bracketR, false, true, e6);
      case bn.bracketL:
        return this.parseArrayLike(bn.bracketR, true, false, e6);
      case bn.braceBarL:
      case bn.braceHashL:
        return this.parseObjectLike(this.state.type === bn.braceBarL ? bn.braceBarR : bn.braceR, false, true, e6);
      case bn.braceL:
        return this.parseObjectLike(bn.braceR, false, false, e6);
      case bn._function:
        return this.parseFunctionOrFunctionSent();
      case bn.at:
        this.parseDecorators();
      case bn._class:
        return t2 = this.startNode(), this.takeDecorators(t2), this.parseClass(t2, false);
      case bn._new:
        return this.parseNewOrNewTarget();
      case bn.backQuote:
        return this.parseTemplate(false);
      case bn.doubleColon: {
        t2 = this.startNode(), this.next(), t2.object = null;
        const e7 = t2.callee = this.parseNoCallExpr();
        if (e7.type === "MemberExpression")
          return this.finishNode(t2, "BindExpression");
        throw this.raise(e7.start, Rn.UnsupportedBind);
      }
      case bn.privateName:
        return this.raise(this.state.start, Rn.PrivateInExpectedIn, this.state.value), this.parsePrivateName();
      case bn.moduloAssign:
        if (this.getPluginOption("pipelineOperator", "proposal") !== "hack" || this.getPluginOption("pipelineOperator", "topicToken") !== "%")
          throw this.unexpected();
        this.state.value = "%", this.state.type = bn.modulo, this.state.pos--, this.state.end--, this.state.endLoc.column--;
      case bn.modulo:
      case bn.hash: {
        const e7 = this.getPluginOption("pipelineOperator", "proposal");
        if (e7) {
          t2 = this.startNode();
          const s2 = this.state.start, r2 = this.state.type;
          return this.next(), this.finishTopicReference(t2, s2, e7, r2);
        }
      }
      case bn.relational:
        if (this.state.value === "<") {
          const e7 = this.input.codePointAt(this.nextTokenStart());
          (Jn(e7) || e7 === 62) && this.expectOnePlugin(["jsx", "flow", "typescript"]);
        }
      default:
        throw this.unexpected();
    }
  }
  finishTopicReference(e6, t2, s2, r2) {
    if (this.testTopicReferenceConfiguration(s2, t2, r2)) {
      let r3;
      return r3 = s2 === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference", this.topicReferenceIsAllowedInCurrentContext() || (s2 === "smart" ? this.raise(t2, Rn.PrimaryTopicNotAllowed) : this.raise(t2, Rn.PipeTopicUnbound)), this.registerTopicReference(), this.finishNode(e6, r3);
    }
    throw this.raise(t2, Rn.PipeTopicUnconfiguredToken, r2.label);
  }
  testTopicReferenceConfiguration(e6, t2, s2) {
    switch (e6) {
      case "hack": {
        const e7 = this.getPluginOption("pipelineOperator", "topicToken");
        return s2.label === e7;
      }
      case "smart":
        return s2 === bn.hash;
      default:
        throw this.raise(t2, Rn.PipeTopicRequiresHackPipes);
    }
  }
  parseAsyncArrowUnaryFunction(e6) {
    this.prodParam.enter(wo(true, this.prodParam.hasYield));
    const t2 = [this.parseIdentifier()];
    return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(this.state.pos, Rn.LineTerminatorBeforeArrow), this.expect(bn.arrow), this.parseArrowExpression(e6, t2, true), e6;
  }
  parseDo(e6, t2) {
    this.expectPlugin("doExpressions"), t2 && this.expectPlugin("asyncDoExpressions"), e6.async = t2, this.next();
    const s2 = this.state.labels;
    return this.state.labels = [], t2 ? (this.prodParam.enter(2), e6.body = this.parseBlock(), this.prodParam.exit()) : e6.body = this.parseBlock(), this.state.labels = s2, this.finishNode(e6, "DoExpression");
  }
  parseSuper() {
    const e6 = this.startNode();
    return this.next(), !this.match(bn.parenL) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(e6.start, Rn.UnexpectedSuper) : this.raise(e6.start, Rn.SuperNotAllowed), this.match(bn.parenL) || this.match(bn.bracketL) || this.match(bn.dot) || this.raise(e6.start, Rn.UnsupportedSuper), this.finishNode(e6, "Super");
  }
  parseMaybePrivateName(e6) {
    return this.match(bn.privateName) ? (e6 || this.raise(this.state.start + 1, Rn.UnexpectedPrivateField), this.parsePrivateName()) : this.parseIdentifier(true);
  }
  parsePrivateName() {
    const e6 = this.startNode(), t2 = this.startNodeAt(this.state.start + 1, new In(this.state.curLine, this.state.start + 1 - this.state.lineStart)), s2 = this.state.value;
    return this.next(), e6.id = this.createIdentifier(t2, s2), this.finishNode(e6, "PrivateName");
  }
  parseFunctionOrFunctionSent() {
    const e6 = this.startNode();
    if (this.next(), this.prodParam.hasYield && this.match(bn.dot)) {
      const t2 = this.createIdentifier(this.startNodeAtNode(e6), "function");
      return this.next(), this.parseMetaProperty(e6, t2, "sent");
    }
    return this.parseFunction(e6);
  }
  parseMetaProperty(e6, t2, s2) {
    e6.meta = t2, t2.name === "function" && s2 === "sent" && (this.isContextual(s2) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected());
    const r2 = this.state.containsEsc;
    return e6.property = this.parseIdentifier(true), (e6.property.name !== s2 || r2) && this.raise(e6.property.start, Rn.UnsupportedMetaProperty, t2.name, s2), this.finishNode(e6, "MetaProperty");
  }
  parseImportMetaProperty(e6) {
    const t2 = this.createIdentifier(this.startNodeAtNode(e6), "import");
    return this.next(), this.isContextual("meta") && (this.inModule || this.raise(t2.start, jn.ImportMetaOutsideModule), this.sawUnambiguousESM = true), this.parseMetaProperty(e6, t2, "meta");
  }
  parseLiteralAtNode(e6, t2, s2) {
    return this.addExtra(s2, "rawValue", e6), this.addExtra(s2, "raw", this.input.slice(s2.start, this.state.end)), s2.value = e6, this.next(), this.finishNode(s2, t2);
  }
  parseLiteral(e6, t2) {
    const s2 = this.startNode();
    return this.parseLiteralAtNode(e6, t2, s2);
  }
  parseStringLiteral(e6) {
    return this.parseLiteral(e6, "StringLiteral");
  }
  parseNumericLiteral(e6) {
    return this.parseLiteral(e6, "NumericLiteral");
  }
  parseBigIntLiteral(e6) {
    return this.parseLiteral(e6, "BigIntLiteral");
  }
  parseDecimalLiteral(e6) {
    return this.parseLiteral(e6, "DecimalLiteral");
  }
  parseRegExpLiteral(e6) {
    const t2 = this.parseLiteral(e6.value, "RegExpLiteral");
    return t2.pattern = e6.pattern, t2.flags = e6.flags, t2;
  }
  parseBooleanLiteral(e6) {
    const t2 = this.startNode();
    return t2.value = e6, this.next(), this.finishNode(t2, "BooleanLiteral");
  }
  parseNullLiteral() {
    const e6 = this.startNode();
    return this.next(), this.finishNode(e6, "NullLiteral");
  }
  parseParenAndDistinguishExpression(e6) {
    const t2 = this.state.start, s2 = this.state.startLoc;
    let r2;
    this.next(), this.expressionScope.enter(new go(1));
    const i2 = this.state.maybeInArrowParameters, a2 = this.state.inFSharpPipelineDirectBody;
    this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
    const n2 = this.state.start, o2 = this.state.startLoc, u2 = [], h2 = new So();
    let c2, p2, l2 = true;
    for (; !this.match(bn.parenR); ) {
      if (l2)
        l2 = false;
      else if (this.expect(bn.comma, h2.optionalParameters === -1 ? null : h2.optionalParameters), this.match(bn.parenR)) {
        p2 = this.state.start;
        break;
      }
      if (this.match(bn.ellipsis)) {
        const e7 = this.state.start, t3 = this.state.startLoc;
        c2 = this.state.start, u2.push(this.parseParenItem(this.parseRestBinding(), e7, t3)), this.checkCommaAfterRest(41);
        break;
      }
      u2.push(this.parseMaybeAssignAllowIn(h2, this.parseParenItem));
    }
    const d2 = this.state.lastTokEnd, D2 = this.state.lastTokEndLoc;
    this.expect(bn.parenR), this.state.maybeInArrowParameters = i2, this.state.inFSharpPipelineDirectBody = a2;
    let m2 = this.startNodeAt(t2, s2);
    if (e6 && this.shouldParseArrow(u2) && (m2 = this.parseArrow(m2)))
      return this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(m2, u2, false), m2;
    if (this.expressionScope.exit(), u2.length || this.unexpected(this.state.lastTokStart), p2 && this.unexpected(p2), c2 && this.unexpected(c2), this.checkExpressionErrors(h2, true), this.toReferencedListDeep(u2, true), u2.length > 1 ? (r2 = this.startNodeAt(n2, o2), r2.expressions = u2, this.finishNode(r2, "SequenceExpression"), r2.end = d2, r2.loc.end = D2) : r2 = u2[0], !this.options.createParenthesizedExpressions)
      return this.addExtra(r2, "parenthesized", true), this.addExtra(r2, "parenStart", t2), r2;
    const f2 = this.startNodeAt(t2, s2);
    return f2.expression = r2, this.finishNode(f2, "ParenthesizedExpression"), f2;
  }
  shouldParseArrow(e6) {
    return !this.canInsertSemicolon();
  }
  parseArrow(e6) {
    if (this.eat(bn.arrow))
      return e6;
  }
  parseParenItem(e6, t2, s2) {
    return e6;
  }
  parseNewOrNewTarget() {
    const e6 = this.startNode();
    if (this.next(), this.match(bn.dot)) {
      const t2 = this.createIdentifier(this.startNodeAtNode(e6), "new");
      this.next();
      const s2 = this.parseMetaProperty(e6, t2, "target");
      return this.scope.inNonArrowFunction || this.scope.inClass || this.raise(s2.start, Rn.UnexpectedNewTarget), s2;
    }
    return this.parseNew(e6);
  }
  parseNew(e6) {
    return e6.callee = this.parseNoCallExpr(), e6.callee.type === "Import" ? this.raise(e6.callee.start, Rn.ImportCallNotNewExpression) : this.isOptionalChain(e6.callee) ? this.raise(this.state.lastTokEnd, Rn.OptionalChainingNoNew) : this.eat(bn.questionDot) && this.raise(this.state.start, Rn.OptionalChainingNoNew), this.parseNewArguments(e6), this.finishNode(e6, "NewExpression");
  }
  parseNewArguments(e6) {
    if (this.eat(bn.parenL)) {
      const t2 = this.parseExprList(bn.parenR);
      this.toReferencedList(t2), e6.arguments = t2;
    } else
      e6.arguments = [];
  }
  parseTemplateElement(e6) {
    const t2 = this.startNode();
    return this.state.value === null && (e6 || this.raise(this.state.start + 1, Rn.InvalidEscapeSequenceTemplate)), t2.value = { raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"), cooked: this.state.value }, this.next(), t2.tail = this.match(bn.backQuote), this.finishNode(t2, "TemplateElement");
  }
  parseTemplate(e6) {
    const t2 = this.startNode();
    this.next(), t2.expressions = [];
    let s2 = this.parseTemplateElement(e6);
    for (t2.quasis = [s2]; !s2.tail; )
      this.expect(bn.dollarBraceL), t2.expressions.push(this.parseTemplateSubstitution()), this.expect(bn.braceR), t2.quasis.push(s2 = this.parseTemplateElement(e6));
    return this.next(), this.finishNode(t2, "TemplateLiteral");
  }
  parseTemplateSubstitution() {
    return this.parseExpression();
  }
  parseObjectLike(e6, t2, s2, r2) {
    s2 && this.expectPlugin("recordAndTuple");
    const i2 = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;
    const a2 = Object.create(null);
    let n2 = true;
    const o2 = this.startNode();
    for (o2.properties = [], this.next(); !this.match(e6); ) {
      if (n2)
        n2 = false;
      else if (this.expect(bn.comma), this.match(e6)) {
        this.addExtra(o2, "trailingComma", this.state.lastTokStart);
        break;
      }
      const i3 = this.parsePropertyDefinition(t2, r2);
      t2 || this.checkProto(i3, s2, a2, r2), s2 && !this.isObjectProperty(i3) && i3.type !== "SpreadElement" && this.raise(i3.start, Rn.InvalidRecordProperty), i3.shorthand && this.addExtra(i3, "shorthand", true), o2.properties.push(i3);
    }
    this.next(), this.state.inFSharpPipelineDirectBody = i2;
    let u2 = "ObjectExpression";
    return t2 ? u2 = "ObjectPattern" : s2 && (u2 = "RecordExpression"), this.finishNode(o2, u2);
  }
  maybeAsyncOrAccessorProp(e6) {
    return !e6.computed && e6.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(bn.bracketL) || this.match(bn.star));
  }
  parsePropertyDefinition(e6, t2) {
    let s2 = [];
    if (this.match(bn.at))
      for (this.hasPlugin("decorators") && this.raise(this.state.start, Rn.UnsupportedPropertyDecorator); this.match(bn.at); )
        s2.push(this.parseDecorator());
    const r2 = this.startNode();
    let i2, a2, n2 = false, o2 = false, u2 = false;
    if (this.match(bn.ellipsis))
      return s2.length && this.unexpected(), e6 ? (this.next(), r2.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(r2, "RestElement")) : this.parseSpread();
    s2.length && (r2.decorators = s2, s2 = []), r2.method = false, (e6 || t2) && (i2 = this.state.start, a2 = this.state.startLoc), e6 || (n2 = this.eat(bn.star));
    const h2 = this.state.containsEsc, c2 = this.parsePropertyName(r2, false);
    if (!e6 && !n2 && !h2 && this.maybeAsyncOrAccessorProp(r2)) {
      const e7 = c2.name;
      e7 !== "async" || this.hasPrecedingLineBreak() || (o2 = true, this.resetPreviousNodeTrailingComments(c2), n2 = this.eat(bn.star), this.parsePropertyName(r2, false)), e7 !== "get" && e7 !== "set" || (u2 = true, this.resetPreviousNodeTrailingComments(c2), r2.kind = e7, this.match(bn.star) && (n2 = true, this.raise(this.state.pos, Rn.AccessorIsGenerator, e7), this.next()), this.parsePropertyName(r2, false));
    }
    return this.parseObjPropValue(r2, i2, a2, n2, o2, e6, u2, t2), r2;
  }
  getGetterSetterExpectedParamCount(e6) {
    return e6.kind === "get" ? 0 : 1;
  }
  getObjectOrClassMethodParams(e6) {
    return e6.params;
  }
  checkGetterSetterParams(e6) {
    var t2;
    const s2 = this.getGetterSetterExpectedParamCount(e6), r2 = this.getObjectOrClassMethodParams(e6), i2 = e6.start;
    r2.length !== s2 && (e6.kind === "get" ? this.raise(i2, Rn.BadGetterArity) : this.raise(i2, Rn.BadSetterArity)), e6.kind === "set" && ((t2 = r2[r2.length - 1]) == null ? void 0 : t2.type) === "RestElement" && this.raise(i2, Rn.BadSetterRestParameter);
  }
  parseObjectMethod(e6, t2, s2, r2, i2) {
    return i2 ? (this.parseMethod(e6, t2, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(e6), e6) : s2 || t2 || this.match(bn.parenL) ? (r2 && this.unexpected(), e6.kind = "method", e6.method = true, this.parseMethod(e6, t2, s2, false, false, "ObjectMethod")) : void 0;
  }
  parseObjectProperty(e6, t2, s2, r2, i2) {
    return e6.shorthand = false, this.eat(bn.colon) ? (e6.value = r2 ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(i2), this.finishNode(e6, "ObjectProperty")) : e6.computed || e6.key.type !== "Identifier" ? void 0 : (this.checkReservedWord(e6.key.name, e6.key.start, true, false), r2 ? e6.value = this.parseMaybeDefault(t2, s2, Io(e6.key)) : this.match(bn.eq) && i2 ? (i2.shorthandAssign === -1 && (i2.shorthandAssign = this.state.start), e6.value = this.parseMaybeDefault(t2, s2, Io(e6.key))) : e6.value = Io(e6.key), e6.shorthand = true, this.finishNode(e6, "ObjectProperty"));
  }
  parseObjPropValue(e6, t2, s2, r2, i2, a2, n2, o2) {
    const u2 = this.parseObjectMethod(e6, r2, i2, a2, n2) || this.parseObjectProperty(e6, t2, s2, a2, o2);
    return u2 || this.unexpected(), u2;
  }
  parsePropertyName(e6, t2) {
    if (this.eat(bn.bracketL))
      e6.computed = true, e6.key = this.parseMaybeAssignAllowIn(), this.expect(bn.bracketR);
    else {
      const s2 = this.state.inPropertyName;
      this.state.inPropertyName = true;
      const r2 = this.state.type;
      e6.key = r2 === bn.num || r2 === bn.string || r2 === bn.bigint || r2 === bn.decimal ? this.parseExprAtom() : this.parseMaybePrivateName(t2), r2 !== bn.privateName && (e6.computed = false), this.state.inPropertyName = s2;
    }
    return e6.key;
  }
  initFunction(e6, t2) {
    e6.id = null, e6.generator = false, e6.async = !!t2;
  }
  parseMethod(e6, t2, s2, r2, i2, a2, n2 = false) {
    this.initFunction(e6, s2), e6.generator = !!t2;
    const o2 = r2;
    return this.scope.enter(18 | (n2 ? 64 : 0) | (i2 ? 32 : 0)), this.prodParam.enter(wo(s2, e6.generator)), this.parseFunctionParams(e6, o2), this.parseFunctionBodyAndFinish(e6, a2, true), this.prodParam.exit(), this.scope.exit(), e6;
  }
  parseArrayLike(e6, t2, s2, r2) {
    s2 && this.expectPlugin("recordAndTuple");
    const i2 = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = false;
    const a2 = this.startNode();
    return this.next(), a2.elements = this.parseExprList(e6, !s2, r2, a2), this.state.inFSharpPipelineDirectBody = i2, this.finishNode(a2, s2 ? "TupleExpression" : "ArrayExpression");
  }
  parseArrowExpression(e6, t2, s2, r2) {
    this.scope.enter(6);
    let i2 = wo(s2, false);
    !this.match(bn.bracketL) && this.prodParam.hasIn && (i2 |= 8), this.prodParam.enter(i2), this.initFunction(e6, s2);
    const a2 = this.state.maybeInArrowParameters;
    return t2 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(e6, t2, r2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(e6, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a2, this.finishNode(e6, "ArrowFunctionExpression");
  }
  setArrowFunctionParameters(e6, t2, s2) {
    e6.params = this.toAssignableList(t2, s2, false);
  }
  parseFunctionBodyAndFinish(e6, t2, s2 = false) {
    this.parseFunctionBody(e6, false, s2), this.finishNode(e6, t2);
  }
  parseFunctionBody(e6, t2, s2 = false) {
    const r2 = t2 && !this.match(bn.braceL);
    if (this.expressionScope.enter(Po()), r2)
      e6.body = this.parseMaybeAssign(), this.checkParams(e6, false, t2, false);
    else {
      const r3 = this.state.strict, i2 = this.state.labels;
      this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), e6.body = this.parseBlock(true, false, (i3) => {
        const a2 = !this.isSimpleParamList(e6.params);
        if (i3 && a2) {
          const t3 = e6.kind !== "method" && e6.kind !== "constructor" || !e6.key ? e6.start : e6.key.end;
          this.raise(t3, Rn.IllegalLanguageModeDirective);
        }
        const n2 = !r3 && this.state.strict;
        this.checkParams(e6, !(this.state.strict || t2 || s2 || a2), t2, n2), this.state.strict && e6.id && this.checkLVal(e6.id, "function name", 65, void 0, void 0, n2);
      }), this.prodParam.exit(), this.expressionScope.exit(), this.state.labels = i2;
    }
  }
  isSimpleParamList(e6) {
    for (let t2 = 0, s2 = e6.length; t2 < s2; t2++)
      if (e6[t2].type !== "Identifier")
        return false;
    return true;
  }
  checkParams(e6, t2, s2, r2 = true) {
    const i2 = new Set();
    for (const s3 of e6.params)
      this.checkLVal(s3, "function parameter list", 5, t2 ? null : i2, void 0, r2);
  }
  parseExprList(e6, t2, s2, r2) {
    const i2 = [];
    let a2 = true;
    for (; !this.eat(e6); ) {
      if (a2)
        a2 = false;
      else if (this.expect(bn.comma), this.match(e6)) {
        r2 && this.addExtra(r2, "trailingComma", this.state.lastTokStart), this.next();
        break;
      }
      i2.push(this.parseExprListItem(t2, s2));
    }
    return i2;
  }
  parseExprListItem(e6, t2, s2) {
    let r2;
    if (this.match(bn.comma))
      e6 || this.raise(this.state.pos, Rn.UnexpectedToken, ","), r2 = null;
    else if (this.match(bn.ellipsis)) {
      const e7 = this.state.start, s3 = this.state.startLoc;
      r2 = this.parseParenItem(this.parseSpread(t2), e7, s3);
    } else if (this.match(bn.question)) {
      this.expectPlugin("partialApplication"), s2 || this.raise(this.state.start, Rn.UnexpectedArgumentPlaceholder);
      const e7 = this.startNode();
      this.next(), r2 = this.finishNode(e7, "ArgumentPlaceholder");
    } else
      r2 = this.parseMaybeAssignAllowIn(t2, this.parseParenItem);
    return r2;
  }
  parseIdentifier(e6) {
    const t2 = this.startNode(), s2 = this.parseIdentifierName(t2.start, e6);
    return this.createIdentifier(t2, s2);
  }
  createIdentifier(e6, t2) {
    return e6.name = t2, e6.loc.identifierName = t2, this.finishNode(e6, "Identifier");
  }
  parseIdentifierName(e6, t2) {
    let s2;
    const { start: r2, type: i2 } = this.state;
    if (i2 === bn.name)
      s2 = this.state.value;
    else {
      if (!i2.keyword)
        throw this.unexpected();
      s2 = i2.keyword;
    }
    return t2 ? this.state.type = bn.name : this.checkReservedWord(s2, r2, !!i2.keyword, false), this.next(), s2;
  }
  checkReservedWord(e6, t2, s2, r2) {
    if (e6.length > 10)
      return;
    if (!function(e7) {
      return uo.has(e7);
    }(e6))
      return;
    if (e6 === "yield") {
      if (this.prodParam.hasYield)
        return void this.raise(t2, Rn.YieldBindingIdentifier);
    } else if (e6 === "await") {
      if (this.prodParam.hasAwait)
        return void this.raise(t2, Rn.AwaitBindingIdentifier);
      if (this.scope.inStaticBlock)
        return void this.raise(t2, Rn.AwaitBindingIdentifierInStaticBlock);
      this.expressionScope.recordAsyncArrowParametersError(t2, Rn.AwaitBindingIdentifier);
    } else if (e6 === "arguments" && this.scope.inClassAndNotInNonArrowFunction)
      return void this.raise(t2, Rn.ArgumentsInClass);
    if (s2 && oo(e6))
      return void this.raise(t2, Rn.UnexpectedKeyword, e6);
    (this.state.strict ? r2 ? no : io : ro)(e6, this.inModule) && this.raise(t2, Rn.UnexpectedReservedWord, e6);
  }
  isAwaitAllowed() {
    return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
  }
  parseAwait(e6, t2) {
    const s2 = this.startNodeAt(e6, t2);
    return this.expressionScope.recordParameterInitializerError(s2.start, Rn.AwaitExpressionFormalParameter), this.eat(bn.star) && this.raise(s2.start, Rn.ObsoleteAwaitStar), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (s2.argument = this.parseMaybeUnary(null, true)), this.finishNode(s2, "AwaitExpression");
  }
  isAmbiguousAwait() {
    return this.hasPrecedingLineBreak() || this.match(bn.plusMin) || this.match(bn.parenL) || this.match(bn.bracketL) || this.match(bn.backQuote) || this.match(bn.regexp) || this.match(bn.slash) || this.hasPlugin("v8intrinsic") && this.match(bn.modulo);
  }
  parseYield() {
    const e6 = this.startNode();
    this.expressionScope.recordParameterInitializerError(e6.start, Rn.YieldInParameter), this.next();
    let t2 = false, s2 = null;
    if (!this.hasPrecedingLineBreak())
      switch (t2 = this.eat(bn.star), this.state.type) {
        case bn.semi:
        case bn.eof:
        case bn.braceR:
        case bn.parenR:
        case bn.bracketR:
        case bn.braceBarR:
        case bn.colon:
        case bn.comma:
          if (!t2)
            break;
        default:
          s2 = this.parseMaybeAssign();
      }
    return e6.delegate = t2, e6.argument = s2, this.finishNode(e6, "YieldExpression");
  }
  checkPipelineAtInfixOperator(e6, t2) {
    this.getPluginOption("pipelineOperator", "proposal") === "smart" && e6.type === "SequenceExpression" && this.raise(t2, Rn.PipelineHeadSequenceExpression);
  }
  checkHackPipeBodyEarlyErrors(e6) {
    if (this.match(bn.arrow))
      throw this.raise(this.state.start, Rn.PipeBodyIsTighter, bn.arrow.label);
    this.topicReferenceWasUsedInCurrentContext() || this.raise(e6, Rn.PipeTopicUnused);
  }
  parseSmartPipelineBodyInStyle(e6, t2, s2) {
    const r2 = this.startNodeAt(t2, s2);
    return this.isSimpleReference(e6) ? (r2.callee = e6, this.finishNode(r2, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(t2), r2.expression = e6, this.finishNode(r2, "PipelineTopicExpression"));
  }
  isSimpleReference(e6) {
    switch (e6.type) {
      case "MemberExpression":
        return !e6.computed && this.isSimpleReference(e6.object);
      case "Identifier":
        return true;
      default:
        return false;
    }
  }
  checkSmartPipeTopicBodyEarlyErrors(e6) {
    if (this.match(bn.arrow))
      throw this.raise(this.state.start, Rn.PipelineBodyNoArrow);
    this.topicReferenceWasUsedInCurrentContext() || this.raise(e6, Rn.PipelineTopicUnused);
  }
  withTopicBindingContext(e6) {
    const t2 = this.state.topicContext;
    this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
    try {
      return e6();
    } finally {
      this.state.topicContext = t2;
    }
  }
  withSmartMixTopicForbiddingContext(e6) {
    if (this.getPluginOption("pipelineOperator", "proposal") !== "smart")
      return e6();
    {
      const t2 = this.state.topicContext;
      this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
      try {
        return e6();
      } finally {
        this.state.topicContext = t2;
      }
    }
  }
  withSoloAwaitPermittingContext(e6) {
    const t2 = this.state.soloAwait;
    this.state.soloAwait = true;
    try {
      return e6();
    } finally {
      this.state.soloAwait = t2;
    }
  }
  allowInAnd(e6) {
    const t2 = this.prodParam.currentFlags();
    if (8 & ~t2) {
      this.prodParam.enter(8 | t2);
      try {
        return e6();
      } finally {
        this.prodParam.exit();
      }
    }
    return e6();
  }
  disallowInAnd(e6) {
    const t2 = this.prodParam.currentFlags();
    if (8 & t2) {
      this.prodParam.enter(-9 & t2);
      try {
        return e6();
      } finally {
        this.prodParam.exit();
      }
    }
    return e6();
  }
  registerTopicReference() {
    this.state.topicContext.maxTopicIndex = 0;
  }
  topicReferenceIsAllowedInCurrentContext() {
    return this.state.topicContext.maxNumOfResolvableTopics >= 1;
  }
  topicReferenceWasUsedInCurrentContext() {
    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
  }
  parseFSharpPipelineBody(e6) {
    const t2 = this.state.start, s2 = this.state.startLoc;
    this.state.potentialArrowAt = this.state.start;
    const r2 = this.state.inFSharpPipelineDirectBody;
    this.state.inFSharpPipelineDirectBody = true;
    const i2 = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t2, s2, e6);
    return this.state.inFSharpPipelineDirectBody = r2, i2;
  }
  parseModuleExpression() {
    this.expectPlugin("moduleBlocks");
    const e6 = this.startNode();
    this.next(), this.eat(bn.braceL);
    const t2 = this.initializeScopes(true);
    this.enterInitialScopes();
    const s2 = this.startNode();
    try {
      e6.body = this.parseProgram(s2, bn.braceR, "module");
    } finally {
      t2();
    }
    return this.eat(bn.braceR), this.finishNode(e6, "ModuleExpression");
  }
} {
  parseTopLevel(e6, t2) {
    return e6.program = this.parseProgram(t2), e6.comments = this.state.comments, this.options.tokens && (e6.tokens = function(e7) {
      for (let t3 = 0; t3 < e7.length; t3++) {
        const s2 = e7[t3];
        if (s2.type === bn.privateName) {
          const { loc: r2, start: i2, value: a2, end: n2 } = s2, o2 = i2 + 1, u2 = new In(r2.start.line, r2.start.column + 1);
          e7.splice(t3, 1, new Eo({ type: bn.hash, value: "#", start: i2, end: o2, startLoc: r2.start, endLoc: u2 }), new Eo({ type: bn.name, value: a2, start: o2, end: n2, startLoc: u2, endLoc: r2.end }));
        }
      }
      return e7;
    }(this.tokens)), this.finishNode(e6, "File");
  }
  parseProgram(e6, t2 = bn.eof, s2 = this.options.sourceType) {
    if (e6.sourceType = s2, e6.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e6, true, true, t2), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
      for (const [e7] of Array.from(this.scope.undefinedExports)) {
        const t3 = this.scope.undefinedExports.get(e7);
        this.raise(t3, Rn.ModuleExportUndefined, e7);
      }
    return this.finishNode(e6, "Program");
  }
  stmtToDirective(e6) {
    const t2 = e6;
    t2.type = "Directive", t2.value = t2.expression, delete t2.expression;
    const s2 = t2.value, r2 = this.input.slice(s2.start, s2.end), i2 = s2.value = r2.slice(1, -1);
    return this.addExtra(s2, "raw", r2), this.addExtra(s2, "rawValue", i2), s2.type = "DirectiveLiteral", t2;
  }
  parseInterpreterDirective() {
    if (!this.match(bn.interpreterDirective))
      return null;
    const e6 = this.startNode();
    return e6.value = this.state.value, this.next(), this.finishNode(e6, "InterpreterDirective");
  }
  isLet(e6) {
    return !!this.isContextual("let") && this.isLetKeyword(e6);
  }
  isLetKeyword(e6) {
    const t2 = this.nextTokenStart(), s2 = this.codePointAtPos(t2);
    if (s2 === 92 || s2 === 91)
      return true;
    if (e6)
      return false;
    if (s2 === 123)
      return true;
    if (Jn(s2)) {
      if (cu.lastIndex = t2, cu.test(this.input)) {
        const e7 = this.codePointAtPos(cu.lastIndex);
        if (!Yn(e7) && e7 !== 92)
          return false;
      }
      return true;
    }
    return false;
  }
  parseStatement(e6, t2) {
    return this.match(bn.at) && this.parseDecorators(true), this.parseStatementContent(e6, t2);
  }
  parseStatementContent(e6, t2) {
    let s2 = this.state.type;
    const r2 = this.startNode();
    let i2;
    switch (this.isLet(e6) && (s2 = bn._var, i2 = "let"), s2) {
      case bn._break:
      case bn._continue:
        return this.parseBreakContinueStatement(r2, s2.keyword);
      case bn._debugger:
        return this.parseDebuggerStatement(r2);
      case bn._do:
        return this.parseDoStatement(r2);
      case bn._for:
        return this.parseForStatement(r2);
      case bn._function:
        if (this.lookaheadCharCode() === 46)
          break;
        return e6 && (this.state.strict ? this.raise(this.state.start, Rn.StrictFunction) : e6 !== "if" && e6 !== "label" && this.raise(this.state.start, Rn.SloppyFunction)), this.parseFunctionStatement(r2, false, !e6);
      case bn._class:
        return e6 && this.unexpected(), this.parseClass(r2, true);
      case bn._if:
        return this.parseIfStatement(r2);
      case bn._return:
        return this.parseReturnStatement(r2);
      case bn._switch:
        return this.parseSwitchStatement(r2);
      case bn._throw:
        return this.parseThrowStatement(r2);
      case bn._try:
        return this.parseTryStatement(r2);
      case bn._const:
      case bn._var:
        return i2 = i2 || this.state.value, e6 && i2 !== "var" && this.raise(this.state.start, Rn.UnexpectedLexicalDeclaration), this.parseVarStatement(r2, i2);
      case bn._while:
        return this.parseWhileStatement(r2);
      case bn._with:
        return this.parseWithStatement(r2);
      case bn.braceL:
        return this.parseBlock();
      case bn.semi:
        return this.parseEmptyStatement(r2);
      case bn._import: {
        const e7 = this.lookaheadCharCode();
        if (e7 === 40 || e7 === 46)
          break;
      }
      case bn._export: {
        let e7;
        return this.options.allowImportExportEverywhere || t2 || this.raise(this.state.start, Rn.UnexpectedImportExport), this.next(), s2 === bn._import ? (e7 = this.parseImport(r2), e7.type !== "ImportDeclaration" || e7.importKind && e7.importKind !== "value" || (this.sawUnambiguousESM = true)) : (e7 = this.parseExport(r2), (e7.type !== "ExportNamedDeclaration" || e7.exportKind && e7.exportKind !== "value") && (e7.type !== "ExportAllDeclaration" || e7.exportKind && e7.exportKind !== "value") && e7.type !== "ExportDefaultDeclaration" || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(r2), e7;
      }
      default:
        if (this.isAsyncFunction())
          return e6 && this.raise(this.state.start, Rn.AsyncFunctionInSingleStatementContext), this.next(), this.parseFunctionStatement(r2, true, !e6);
    }
    const a2 = this.state.value, n2 = this.parseExpression();
    return s2 === bn.name && n2.type === "Identifier" && this.eat(bn.colon) ? this.parseLabeledStatement(r2, a2, n2, e6) : this.parseExpressionStatement(r2, n2);
  }
  assertModuleNodeAllowed(e6) {
    this.options.allowImportExportEverywhere || this.inModule || this.raise(e6.start, jn.ImportOutsideModule);
  }
  takeDecorators(e6) {
    const t2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
    t2.length && (e6.decorators = t2, this.resetStartLocationFromNode(e6, t2[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
  }
  canHaveLeadingDecorator() {
    return this.match(bn._class);
  }
  parseDecorators(e6) {
    const t2 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
    for (; this.match(bn.at); ) {
      const e7 = this.parseDecorator();
      t2.push(e7);
    }
    if (this.match(bn._export))
      e6 || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Rn.DecoratorExportClass);
    else if (!this.canHaveLeadingDecorator())
      throw this.raise(this.state.start, Rn.UnexpectedLeadingDecorator);
  }
  parseDecorator() {
    this.expectOnePlugin(["decorators-legacy", "decorators"]);
    const e6 = this.startNode();
    if (this.next(), this.hasPlugin("decorators")) {
      this.state.decoratorStack.push([]);
      const t2 = this.state.start, s2 = this.state.startLoc;
      let r2;
      if (this.eat(bn.parenL))
        r2 = this.parseExpression(), this.expect(bn.parenR);
      else
        for (r2 = this.parseIdentifier(false); this.eat(bn.dot); ) {
          const e7 = this.startNodeAt(t2, s2);
          e7.object = r2, e7.property = this.parseIdentifier(true), e7.computed = false, r2 = this.finishNode(e7, "MemberExpression");
        }
      e6.expression = this.parseMaybeDecoratorArguments(r2), this.state.decoratorStack.pop();
    } else
      e6.expression = this.parseExprSubscripts();
    return this.finishNode(e6, "Decorator");
  }
  parseMaybeDecoratorArguments(e6) {
    if (this.eat(bn.parenL)) {
      const t2 = this.startNodeAtNode(e6);
      return t2.callee = e6, t2.arguments = this.parseCallExpressionArguments(bn.parenR, false), this.toReferencedList(t2.arguments), this.finishNode(t2, "CallExpression");
    }
    return e6;
  }
  parseBreakContinueStatement(e6, t2) {
    const s2 = t2 === "break";
    return this.next(), this.isLineTerminator() ? e6.label = null : (e6.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e6, t2), this.finishNode(e6, s2 ? "BreakStatement" : "ContinueStatement");
  }
  verifyBreakContinue(e6, t2) {
    const s2 = t2 === "break";
    let r2;
    for (r2 = 0; r2 < this.state.labels.length; ++r2) {
      const t3 = this.state.labels[r2];
      if (e6.label == null || t3.name === e6.label.name) {
        if (t3.kind != null && (s2 || t3.kind === "loop"))
          break;
        if (e6.label && s2)
          break;
      }
    }
    r2 === this.state.labels.length && this.raise(e6.start, Rn.IllegalBreakContinue, t2);
  }
  parseDebuggerStatement(e6) {
    return this.next(), this.semicolon(), this.finishNode(e6, "DebuggerStatement");
  }
  parseHeaderExpression() {
    this.expect(bn.parenL);
    const e6 = this.parseExpression();
    return this.expect(bn.parenR), e6;
  }
  parseDoStatement(e6) {
    return this.next(), this.state.labels.push(ou), e6.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(bn._while), e6.test = this.parseHeaderExpression(), this.eat(bn.semi), this.finishNode(e6, "DoWhileStatement");
  }
  parseForStatement(e6) {
    this.next(), this.state.labels.push(ou);
    let t2 = -1;
    if (this.isAwaitAllowed() && this.eatContextual("await") && (t2 = this.state.lastTokStart), this.scope.enter(0), this.expect(bn.parenL), this.match(bn.semi))
      return t2 > -1 && this.unexpected(t2), this.parseFor(e6, null);
    const s2 = this.isContextual("let"), r2 = s2 && this.isLetKeyword();
    if (this.match(bn._var) || this.match(bn._const) || r2) {
      const s3 = this.startNode(), i3 = r2 ? "let" : this.state.value;
      return this.next(), this.parseVar(s3, true, i3), this.finishNode(s3, "VariableDeclaration"), (this.match(bn._in) || this.isContextual("of")) && s3.declarations.length === 1 ? this.parseForIn(e6, s3, t2) : (t2 > -1 && this.unexpected(t2), this.parseFor(e6, s3));
    }
    const i2 = this.match(bn.name) && !this.state.containsEsc, a2 = new So(), n2 = this.parseExpression(true, a2), o2 = this.isContextual("of");
    if (o2 && (s2 ? this.raise(n2.start, Rn.ForOfLet) : t2 === -1 && i2 && n2.type === "Identifier" && n2.name === "async" && this.raise(n2.start, Rn.ForOfAsync)), o2 || this.match(bn._in)) {
      this.toAssignable(n2, true);
      const s3 = o2 ? "for-of statement" : "for-in statement";
      return this.checkLVal(n2, s3), this.parseForIn(e6, n2, t2);
    }
    return this.checkExpressionErrors(a2, true), t2 > -1 && this.unexpected(t2), this.parseFor(e6, n2);
  }
  parseFunctionStatement(e6, t2, s2) {
    return this.next(), this.parseFunction(e6, 1 | (s2 ? 0 : 2), t2);
  }
  parseIfStatement(e6) {
    return this.next(), e6.test = this.parseHeaderExpression(), e6.consequent = this.parseStatement("if"), e6.alternate = this.eat(bn._else) ? this.parseStatement("if") : null, this.finishNode(e6, "IfStatement");
  }
  parseReturnStatement(e6) {
    return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, Rn.IllegalReturn), this.next(), this.isLineTerminator() ? e6.argument = null : (e6.argument = this.parseExpression(), this.semicolon()), this.finishNode(e6, "ReturnStatement");
  }
  parseSwitchStatement(e6) {
    this.next(), e6.discriminant = this.parseHeaderExpression();
    const t2 = e6.cases = [];
    let s2, r2;
    for (this.expect(bn.braceL), this.state.labels.push(uu), this.scope.enter(0); !this.match(bn.braceR); )
      if (this.match(bn._case) || this.match(bn._default)) {
        const e7 = this.match(bn._case);
        s2 && this.finishNode(s2, "SwitchCase"), t2.push(s2 = this.startNode()), s2.consequent = [], this.next(), e7 ? s2.test = this.parseExpression() : (r2 && this.raise(this.state.lastTokStart, Rn.MultipleDefaultsInSwitch), r2 = true, s2.test = null), this.expect(bn.colon);
      } else
        s2 ? s2.consequent.push(this.parseStatement(null)) : this.unexpected();
    return this.scope.exit(), s2 && this.finishNode(s2, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e6, "SwitchStatement");
  }
  parseThrowStatement(e6) {
    return this.next(), this.hasPrecedingLineBreak() && this.raise(this.state.lastTokEnd, Rn.NewlineAfterThrow), e6.argument = this.parseExpression(), this.semicolon(), this.finishNode(e6, "ThrowStatement");
  }
  parseCatchClauseParam() {
    const e6 = this.parseBindingAtom(), t2 = e6.type === "Identifier";
    return this.scope.enter(t2 ? 8 : 0), this.checkLVal(e6, "catch clause", 9), e6;
  }
  parseTryStatement(e6) {
    if (this.next(), e6.block = this.parseBlock(), e6.handler = null, this.match(bn._catch)) {
      const t2 = this.startNode();
      this.next(), this.match(bn.parenL) ? (this.expect(bn.parenL), t2.param = this.parseCatchClauseParam(), this.expect(bn.parenR)) : (t2.param = null, this.scope.enter(0)), t2.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), e6.handler = this.finishNode(t2, "CatchClause");
    }
    return e6.finalizer = this.eat(bn._finally) ? this.parseBlock() : null, e6.handler || e6.finalizer || this.raise(e6.start, Rn.NoCatchOrFinally), this.finishNode(e6, "TryStatement");
  }
  parseVarStatement(e6, t2) {
    return this.next(), this.parseVar(e6, false, t2), this.semicolon(), this.finishNode(e6, "VariableDeclaration");
  }
  parseWhileStatement(e6) {
    return this.next(), e6.test = this.parseHeaderExpression(), this.state.labels.push(ou), e6.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(e6, "WhileStatement");
  }
  parseWithStatement(e6) {
    return this.state.strict && this.raise(this.state.start, Rn.StrictWith), this.next(), e6.object = this.parseHeaderExpression(), e6.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(e6, "WithStatement");
  }
  parseEmptyStatement(e6) {
    return this.next(), this.finishNode(e6, "EmptyStatement");
  }
  parseLabeledStatement(e6, t2, s2, r2) {
    for (const e7 of this.state.labels)
      e7.name === t2 && this.raise(s2.start, Rn.LabelRedeclaration, t2);
    const i2 = this.state.type.isLoop ? "loop" : this.match(bn._switch) ? "switch" : null;
    for (let t3 = this.state.labels.length - 1; t3 >= 0; t3--) {
      const s3 = this.state.labels[t3];
      if (s3.statementStart !== e6.start)
        break;
      s3.statementStart = this.state.start, s3.kind = i2;
    }
    return this.state.labels.push({ name: t2, kind: i2, statementStart: this.state.start }), e6.body = this.parseStatement(r2 ? r2.indexOf("label") === -1 ? r2 + "label" : r2 : "label"), this.state.labels.pop(), e6.label = s2, this.finishNode(e6, "LabeledStatement");
  }
  parseExpressionStatement(e6, t2) {
    return e6.expression = t2, this.semicolon(), this.finishNode(e6, "ExpressionStatement");
  }
  parseBlock(e6 = false, t2 = true, s2) {
    const r2 = this.startNode();
    return e6 && this.state.strictErrors.clear(), this.expect(bn.braceL), t2 && this.scope.enter(0), this.parseBlockBody(r2, e6, false, bn.braceR, s2), t2 && this.scope.exit(), this.finishNode(r2, "BlockStatement");
  }
  isValidDirective(e6) {
    return e6.type === "ExpressionStatement" && e6.expression.type === "StringLiteral" && !e6.expression.extra.parenthesized;
  }
  parseBlockBody(e6, t2, s2, r2, i2) {
    const a2 = e6.body = [], n2 = e6.directives = [];
    this.parseBlockOrModuleBlockBody(a2, t2 ? n2 : void 0, s2, r2, i2);
  }
  parseBlockOrModuleBlockBody(e6, t2, s2, r2, i2) {
    const a2 = this.state.strict;
    let n2 = false, o2 = false;
    for (; !this.match(r2); ) {
      const r3 = this.parseStatement(null, s2);
      if (t2 && !o2) {
        if (this.isValidDirective(r3)) {
          const e7 = this.stmtToDirective(r3);
          t2.push(e7), n2 || e7.value.value !== "use strict" || (n2 = true, this.setStrict(true));
          continue;
        }
        o2 = true, this.state.strictErrors.clear();
      }
      e6.push(r3);
    }
    i2 && i2.call(this, n2), a2 || this.setStrict(false), this.next();
  }
  parseFor(e6, t2) {
    return e6.init = t2, this.semicolon(false), e6.test = this.match(bn.semi) ? null : this.parseExpression(), this.semicolon(false), e6.update = this.match(bn.parenR) ? null : this.parseExpression(), this.expect(bn.parenR), e6.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e6, "ForStatement");
  }
  parseForIn(e6, t2, s2) {
    const r2 = this.match(bn._in);
    return this.next(), r2 ? s2 > -1 && this.unexpected(s2) : e6.await = s2 > -1, t2.type !== "VariableDeclaration" || t2.declarations[0].init == null || r2 && !this.state.strict && t2.kind === "var" && t2.declarations[0].id.type === "Identifier" ? t2.type === "AssignmentPattern" && this.raise(t2.start, Rn.InvalidLhs, "for-loop") : this.raise(t2.start, Rn.ForInOfLoopInitializer, r2 ? "for-in" : "for-of"), e6.left = t2, e6.right = r2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(bn.parenR), e6.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e6, r2 ? "ForInStatement" : "ForOfStatement");
  }
  parseVar(e6, t2, s2) {
    const r2 = e6.declarations = [], i2 = this.hasPlugin("typescript");
    for (e6.kind = s2; ; ) {
      const e7 = this.startNode();
      if (this.parseVarId(e7, s2), this.eat(bn.eq) ? e7.init = t2 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : (s2 !== "const" || this.match(bn._in) || this.isContextual("of") ? e7.id.type === "Identifier" || t2 && (this.match(bn._in) || this.isContextual("of")) || this.raise(this.state.lastTokEnd, Rn.DeclarationMissingInitializer, "Complex binding patterns") : i2 || this.raise(this.state.lastTokEnd, Rn.DeclarationMissingInitializer, "Const declarations"), e7.init = null), r2.push(this.finishNode(e7, "VariableDeclarator")), !this.eat(bn.comma))
        break;
    }
    return e6;
  }
  parseVarId(e6, t2) {
    e6.id = this.parseBindingAtom(), this.checkLVal(e6.id, "variable declaration", t2 === "var" ? 5 : 9, void 0, t2 !== "var");
  }
  parseFunction(e6, t2 = 0, s2 = false) {
    const r2 = 1 & t2, i2 = 2 & t2, a2 = !(!r2 || 4 & t2);
    this.initFunction(e6, s2), this.match(bn.star) && i2 && this.raise(this.state.start, Rn.GeneratorInSingleStatementContext), e6.generator = this.eat(bn.star), r2 && (e6.id = this.parseFunctionId(a2));
    const n2 = this.state.maybeInArrowParameters;
    return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(wo(s2, e6.generator)), r2 || (e6.id = this.parseFunctionId()), this.parseFunctionParams(e6, false), this.withSmartMixTopicForbiddingContext(() => {
      this.parseFunctionBodyAndFinish(e6, r2 ? "FunctionDeclaration" : "FunctionExpression");
    }), this.prodParam.exit(), this.scope.exit(), r2 && !i2 && this.registerFunctionStatementId(e6), this.state.maybeInArrowParameters = n2, e6;
  }
  parseFunctionId(e6) {
    return e6 || this.match(bn.name) ? this.parseIdentifier() : null;
  }
  parseFunctionParams(e6, t2) {
    this.expect(bn.parenL), this.expressionScope.enter(new Fo(3)), e6.params = this.parseBindingList(bn.parenR, 41, false, t2), this.expressionScope.exit();
  }
  registerFunctionStatementId(e6) {
    e6.id && this.scope.declareName(e6.id.name, this.state.strict || e6.generator || e6.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, e6.id.start);
  }
  parseClass(e6, t2, s2) {
    this.next(), this.takeDecorators(e6);
    const r2 = this.state.strict;
    return this.state.strict = true, this.parseClassId(e6, t2, s2), this.parseClassSuper(e6), e6.body = this.parseClassBody(!!e6.superClass, r2), this.finishNode(e6, t2 ? "ClassDeclaration" : "ClassExpression");
  }
  isClassProperty() {
    return this.match(bn.eq) || this.match(bn.semi) || this.match(bn.braceR);
  }
  isClassMethod() {
    return this.match(bn.parenL);
  }
  isNonstaticConstructor(e6) {
    return !(e6.computed || e6.static || e6.key.name !== "constructor" && e6.key.value !== "constructor");
  }
  parseClassBody(e6, t2) {
    this.classScope.enter();
    const s2 = { hadConstructor: false, hadSuperClass: e6 };
    let r2 = [];
    const i2 = this.startNode();
    if (i2.body = [], this.expect(bn.braceL), this.withSmartMixTopicForbiddingContext(() => {
      for (; !this.match(bn.braceR); ) {
        if (this.eat(bn.semi)) {
          if (r2.length > 0)
            throw this.raise(this.state.lastTokEnd, Rn.DecoratorSemicolon);
          continue;
        }
        if (this.match(bn.at)) {
          r2.push(this.parseDecorator());
          continue;
        }
        const e7 = this.startNode();
        r2.length && (e7.decorators = r2, this.resetStartLocationFromNode(e7, r2[0]), r2 = []), this.parseClassMember(i2, e7, s2), e7.kind === "constructor" && e7.decorators && e7.decorators.length > 0 && this.raise(e7.start, Rn.DecoratorConstructor);
      }
    }), this.state.strict = t2, this.next(), r2.length)
      throw this.raise(this.state.start, Rn.TrailingDecorator);
    return this.classScope.exit(), this.finishNode(i2, "ClassBody");
  }
  parseClassMemberFromModifier(e6, t2) {
    const s2 = this.parseIdentifier(true);
    if (this.isClassMethod()) {
      const r2 = t2;
      return r2.kind = "method", r2.computed = false, r2.key = s2, r2.static = false, this.pushClassMethod(e6, r2, false, false, false, false), true;
    }
    if (this.isClassProperty()) {
      const r2 = t2;
      return r2.computed = false, r2.key = s2, r2.static = false, e6.body.push(this.parseClassProperty(r2)), true;
    }
    return this.resetPreviousNodeTrailingComments(s2), false;
  }
  parseClassMember(e6, t2, s2) {
    const r2 = this.isContextual("static");
    if (r2) {
      if (this.parseClassMemberFromModifier(e6, t2))
        return;
      if (this.eat(bn.braceL))
        return void this.parseClassStaticBlock(e6, t2);
    }
    this.parseClassMemberWithIsStatic(e6, t2, s2, r2);
  }
  parseClassMemberWithIsStatic(e6, t2, s2, r2) {
    const i2 = t2, a2 = t2, n2 = t2, o2 = t2, u2 = i2, h2 = i2;
    if (t2.static = r2, this.eat(bn.star)) {
      u2.kind = "method";
      const t3 = this.match(bn.privateName);
      return this.parseClassElementName(u2), t3 ? void this.pushClassPrivateMethod(e6, a2, true, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn.ConstructorIsGenerator), void this.pushClassMethod(e6, i2, true, false, false, false));
    }
    const c2 = this.match(bn.name) && !this.state.containsEsc, p2 = this.match(bn.privateName), l2 = this.parseClassElementName(t2), d2 = this.state.start;
    if (this.parsePostMemberNameModifiers(h2), this.isClassMethod()) {
      if (u2.kind = "method", p2)
        return void this.pushClassPrivateMethod(e6, a2, false, false);
      const r3 = this.isNonstaticConstructor(i2);
      let n3 = false;
      r3 && (i2.kind = "constructor", s2.hadConstructor && !this.hasPlugin("typescript") && this.raise(l2.start, Rn.DuplicateConstructor), r3 && this.hasPlugin("typescript") && t2.override && this.raise(l2.start, Rn.OverrideOnConstructor), s2.hadConstructor = true, n3 = s2.hadSuperClass), this.pushClassMethod(e6, i2, false, false, r3, n3);
    } else if (this.isClassProperty())
      p2 ? this.pushClassPrivateProperty(e6, o2) : this.pushClassProperty(e6, n2);
    else if (c2 && l2.name === "async" && !this.isLineTerminator()) {
      this.resetPreviousNodeTrailingComments(l2);
      const t3 = this.eat(bn.star);
      h2.optional && this.unexpected(d2), u2.kind = "method";
      const s3 = this.match(bn.privateName);
      this.parseClassElementName(u2), this.parsePostMemberNameModifiers(h2), s3 ? this.pushClassPrivateMethod(e6, a2, t3, true) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn.ConstructorIsAsync), this.pushClassMethod(e6, i2, t3, true, false, false));
    } else if (!c2 || l2.name !== "get" && l2.name !== "set" || this.match(bn.star) && this.isLineTerminator())
      this.isLineTerminator() ? p2 ? this.pushClassPrivateProperty(e6, o2) : this.pushClassProperty(e6, n2) : this.unexpected();
    else {
      this.resetPreviousNodeTrailingComments(l2), u2.kind = l2.name;
      const t3 = this.match(bn.privateName);
      this.parseClassElementName(i2), t3 ? this.pushClassPrivateMethod(e6, a2, false, false) : (this.isNonstaticConstructor(i2) && this.raise(i2.key.start, Rn.ConstructorIsAccessor), this.pushClassMethod(e6, i2, false, false, false, false)), this.checkGetterSetterParams(i2);
    }
  }
  parseClassElementName(e6) {
    const { type: t2, value: s2, start: r2 } = this.state;
    return t2 !== bn.name && t2 !== bn.string || !e6.static || s2 !== "prototype" || this.raise(r2, Rn.StaticPrototype), t2 === bn.privateName && s2 === "constructor" && this.raise(r2, Rn.ConstructorClassPrivateField), this.parsePropertyName(e6, true);
  }
  parseClassStaticBlock(e6, t2) {
    var s2;
    this.expectPlugin("classStaticBlock", t2.start), this.scope.enter(208);
    const r2 = this.state.labels;
    this.state.labels = [], this.prodParam.enter(0);
    const i2 = t2.body = [];
    this.parseBlockOrModuleBlockBody(i2, void 0, false, bn.braceR), this.prodParam.exit(), this.scope.exit(), this.state.labels = r2, e6.body.push(this.finishNode(t2, "StaticBlock")), (s2 = t2.decorators) != null && s2.length && this.raise(t2.start, Rn.DecoratorStaticBlock);
  }
  pushClassProperty(e6, t2) {
    t2.computed || t2.key.name !== "constructor" && t2.key.value !== "constructor" || this.raise(t2.key.start, Rn.ConstructorClassField), e6.body.push(this.parseClassProperty(t2));
  }
  pushClassPrivateProperty(e6, t2) {
    const s2 = this.parseClassPrivateProperty(t2);
    e6.body.push(s2), this.classScope.declarePrivateName(this.getPrivateNameSV(s2.key), 0, s2.key.start);
  }
  pushClassMethod(e6, t2, s2, r2, i2, a2) {
    e6.body.push(this.parseMethod(t2, s2, r2, i2, a2, "ClassMethod", true));
  }
  pushClassPrivateMethod(e6, t2, s2, r2) {
    const i2 = this.parseMethod(t2, s2, r2, false, false, "ClassPrivateMethod", true);
    e6.body.push(i2);
    const a2 = i2.kind === "get" ? i2.static ? 6 : 2 : i2.kind === "set" ? i2.static ? 5 : 1 : 0;
    this.classScope.declarePrivateName(this.getPrivateNameSV(i2.key), a2, i2.key.start);
  }
  parsePostMemberNameModifiers(e6) {
  }
  parseClassPrivateProperty(e6) {
    return this.parseInitializer(e6), this.semicolon(), this.finishNode(e6, "ClassPrivateProperty");
  }
  parseClassProperty(e6) {
    return this.parseInitializer(e6), this.semicolon(), this.finishNode(e6, "ClassProperty");
  }
  parseInitializer(e6) {
    this.scope.enter(80), this.expressionScope.enter(Po()), this.prodParam.enter(0), e6.value = this.eat(bn.eq) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
  }
  parseClassId(e6, t2, s2, r2 = 139) {
    this.match(bn.name) ? (e6.id = this.parseIdentifier(), t2 && this.checkLVal(e6.id, "class name", r2)) : s2 || !t2 ? e6.id = null : this.unexpected(null, Rn.MissingClassName);
  }
  parseClassSuper(e6) {
    e6.superClass = this.eat(bn._extends) ? this.parseExprSubscripts() : null;
  }
  parseExport(e6) {
    const t2 = this.maybeParseExportDefaultSpecifier(e6), s2 = !t2 || this.eat(bn.comma), r2 = s2 && this.eatExportStar(e6), i2 = r2 && this.maybeParseExportNamespaceSpecifier(e6), a2 = s2 && (!i2 || this.eat(bn.comma)), n2 = t2 || r2;
    if (r2 && !i2)
      return t2 && this.unexpected(), this.parseExportFrom(e6, true), this.finishNode(e6, "ExportAllDeclaration");
    const o2 = this.maybeParseExportNamedSpecifiers(e6);
    if (t2 && s2 && !r2 && !o2 || i2 && a2 && !o2)
      throw this.unexpected(null, bn.braceL);
    let u2;
    if (n2 || o2 ? (u2 = false, this.parseExportFrom(e6, n2)) : u2 = this.maybeParseExportDeclaration(e6), n2 || o2 || u2)
      return this.checkExport(e6, true, false, !!e6.source), this.finishNode(e6, "ExportNamedDeclaration");
    if (this.eat(bn._default))
      return e6.declaration = this.parseExportDefaultExpression(), this.checkExport(e6, true, true), this.finishNode(e6, "ExportDefaultDeclaration");
    throw this.unexpected(null, bn.braceL);
  }
  eatExportStar(e6) {
    return this.eat(bn.star);
  }
  maybeParseExportDefaultSpecifier(e6) {
    if (this.isExportDefaultSpecifier()) {
      this.expectPlugin("exportDefaultFrom");
      const t2 = this.startNode();
      return t2.exported = this.parseIdentifier(true), e6.specifiers = [this.finishNode(t2, "ExportDefaultSpecifier")], true;
    }
    return false;
  }
  maybeParseExportNamespaceSpecifier(e6) {
    if (this.isContextual("as")) {
      e6.specifiers || (e6.specifiers = []);
      const t2 = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
      return this.next(), t2.exported = this.parseModuleExportName(), e6.specifiers.push(this.finishNode(t2, "ExportNamespaceSpecifier")), true;
    }
    return false;
  }
  maybeParseExportNamedSpecifiers(e6) {
    return !!this.match(bn.braceL) && (e6.specifiers || (e6.specifiers = []), e6.specifiers.push(...this.parseExportSpecifiers()), e6.source = null, e6.declaration = null, true);
  }
  maybeParseExportDeclaration(e6) {
    return !!this.shouldParseExportDeclaration() && (e6.specifiers = [], e6.source = null, e6.declaration = this.parseExportDeclaration(e6), true);
  }
  isAsyncFunction() {
    if (!this.isContextual("async"))
      return false;
    const e6 = this.nextTokenStart();
    return !Pn.test(this.input.slice(this.state.pos, e6)) && this.isUnparsedContextual(e6, "function");
  }
  parseExportDefaultExpression() {
    const e6 = this.startNode(), t2 = this.isAsyncFunction();
    if (this.match(bn._function) || t2)
      return this.next(), t2 && this.next(), this.parseFunction(e6, 5, t2);
    if (this.match(bn._class))
      return this.parseClass(e6, true, true);
    if (this.match(bn.at))
      return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, Rn.DecoratorBeforeExport), this.parseDecorators(false), this.parseClass(e6, true, true);
    if (this.match(bn._const) || this.match(bn._var) || this.isLet())
      throw this.raise(this.state.start, Rn.UnsupportedDefaultExport);
    {
      const e7 = this.parseMaybeAssignAllowIn();
      return this.semicolon(), e7;
    }
  }
  parseExportDeclaration(e6) {
    return this.parseStatement(null);
  }
  isExportDefaultSpecifier() {
    if (this.match(bn.name)) {
      const e7 = this.state.value;
      if (e7 === "async" && !this.state.containsEsc || e7 === "let")
        return false;
      if ((e7 === "type" || e7 === "interface") && !this.state.containsEsc) {
        const e8 = this.lookahead();
        if (e8.type === bn.name && e8.value !== "from" || e8.type === bn.braceL)
          return this.expectOnePlugin(["flow", "typescript"]), false;
      }
    } else if (!this.match(bn._default))
      return false;
    const e6 = this.nextTokenStart(), t2 = this.isUnparsedContextual(e6, "from");
    if (this.input.charCodeAt(e6) === 44 || this.match(bn.name) && t2)
      return true;
    if (this.match(bn._default) && t2) {
      const t3 = this.input.charCodeAt(this.nextTokenStartSince(e6 + 4));
      return t3 === 34 || t3 === 39;
    }
    return false;
  }
  parseExportFrom(e6, t2) {
    if (this.eatContextual("from")) {
      e6.source = this.parseImportSource(), this.checkExport(e6);
      const t3 = this.maybeParseImportAssertions();
      t3 && (e6.assertions = t3);
    } else
      t2 ? this.unexpected() : e6.source = null;
    this.semicolon();
  }
  shouldParseExportDeclaration() {
    if (this.match(bn.at) && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
      if (!this.getPluginOption("decorators", "decoratorsBeforeExport"))
        return true;
      this.unexpected(this.state.start, Rn.DecoratorBeforeExport);
    }
    return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
  }
  checkExport(e6, t2, s2, r2) {
    if (t2) {
      if (s2) {
        if (this.checkDuplicateExports(e6, "default"), this.hasPlugin("exportDefaultFrom")) {
          var i2;
          const t3 = e6.declaration;
          t3.type !== "Identifier" || t3.name !== "from" || t3.end - t3.start != 4 || (i2 = t3.extra) != null && i2.parenthesized || this.raise(t3.start, Rn.ExportDefaultFromAsIdentifier);
        }
      } else if (e6.specifiers && e6.specifiers.length)
        for (const t3 of e6.specifiers) {
          const { exported: e7 } = t3, s3 = e7.type === "Identifier" ? e7.name : e7.value;
          if (this.checkDuplicateExports(t3, s3), !r2 && t3.local) {
            const { local: e8 } = t3;
            e8.type !== "Identifier" ? this.raise(t3.start, Rn.ExportBindingIsString, e8.value, s3) : (this.checkReservedWord(e8.name, e8.start, true, false), this.scope.checkLocalExport(e8));
          }
        }
      else if (e6.declaration) {
        if (e6.declaration.type === "FunctionDeclaration" || e6.declaration.type === "ClassDeclaration") {
          const t3 = e6.declaration.id;
          if (!t3)
            throw new Error("Assertion failure");
          this.checkDuplicateExports(e6, t3.name);
        } else if (e6.declaration.type === "VariableDeclaration")
          for (const t3 of e6.declaration.declarations)
            this.checkDeclaration(t3.id);
      }
    }
    if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
      throw this.raise(e6.start, Rn.UnsupportedDecoratorExport);
  }
  checkDeclaration(e6) {
    if (e6.type === "Identifier")
      this.checkDuplicateExports(e6, e6.name);
    else if (e6.type === "ObjectPattern")
      for (const t2 of e6.properties)
        this.checkDeclaration(t2);
    else if (e6.type === "ArrayPattern")
      for (const t2 of e6.elements)
        t2 && this.checkDeclaration(t2);
    else
      e6.type === "ObjectProperty" ? this.checkDeclaration(e6.value) : e6.type === "RestElement" ? this.checkDeclaration(e6.argument) : e6.type === "AssignmentPattern" && this.checkDeclaration(e6.left);
  }
  checkDuplicateExports(e6, t2) {
    this.exportedIdentifiers.has(t2) && this.raise(e6.start, t2 === "default" ? Rn.DuplicateDefaultExport : Rn.DuplicateExport, t2), this.exportedIdentifiers.add(t2);
  }
  parseExportSpecifiers() {
    const e6 = [];
    let t2 = true;
    for (this.expect(bn.braceL); !this.eat(bn.braceR); ) {
      if (t2)
        t2 = false;
      else if (this.expect(bn.comma), this.eat(bn.braceR))
        break;
      const s2 = this.startNode(), r2 = this.match(bn.string), i2 = this.parseModuleExportName();
      s2.local = i2, this.eatContextual("as") ? s2.exported = this.parseModuleExportName() : s2.exported = r2 ? vo(i2) : Io(i2), e6.push(this.finishNode(s2, "ExportSpecifier"));
    }
    return e6;
  }
  parseModuleExportName() {
    if (this.match(bn.string)) {
      const e6 = this.parseStringLiteral(this.state.value), t2 = e6.value.match(hu);
      return t2 && this.raise(e6.start, Rn.ModuleExportNameHasLoneSurrogate, t2[0].charCodeAt(0).toString(16)), e6;
    }
    return this.parseIdentifier(true);
  }
  parseImport(e6) {
    if (e6.specifiers = [], !this.match(bn.string)) {
      const t3 = !this.maybeParseDefaultImportSpecifier(e6) || this.eat(bn.comma), s2 = t3 && this.maybeParseStarImportSpecifier(e6);
      t3 && !s2 && this.parseNamedImportSpecifiers(e6), this.expectContextual("from");
    }
    e6.source = this.parseImportSource();
    const t2 = this.maybeParseImportAssertions();
    if (t2)
      e6.assertions = t2;
    else {
      const t3 = this.maybeParseModuleAttributes();
      t3 && (e6.attributes = t3);
    }
    return this.semicolon(), this.finishNode(e6, "ImportDeclaration");
  }
  parseImportSource() {
    return this.match(bn.string) || this.unexpected(), this.parseExprAtom();
  }
  shouldParseDefaultImport(e6) {
    return this.match(bn.name);
  }
  parseImportSpecifierLocal(e6, t2, s2, r2) {
    t2.local = this.parseIdentifier(), this.checkLVal(t2.local, r2, 9), e6.specifiers.push(this.finishNode(t2, s2));
  }
  parseAssertEntries() {
    const e6 = [], t2 = new Set();
    do {
      if (this.match(bn.braceR))
        break;
      const s2 = this.startNode(), r2 = this.state.value;
      if (t2.has(r2) && this.raise(this.state.start, Rn.ModuleAttributesWithDuplicateKeys, r2), t2.add(r2), this.match(bn.string) ? s2.key = this.parseStringLiteral(r2) : s2.key = this.parseIdentifier(true), this.expect(bn.colon), !this.match(bn.string))
        throw this.unexpected(this.state.start, Rn.ModuleAttributeInvalidValue);
      s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), e6.push(s2);
    } while (this.eat(bn.comma));
    return e6;
  }
  maybeParseModuleAttributes() {
    if (!this.match(bn._with) || this.hasPrecedingLineBreak())
      return this.hasPlugin("moduleAttributes") ? [] : null;
    this.expectPlugin("moduleAttributes"), this.next();
    const e6 = [], t2 = new Set();
    do {
      const s2 = this.startNode();
      if (s2.key = this.parseIdentifier(true), s2.key.name !== "type" && this.raise(s2.key.start, Rn.ModuleAttributeDifferentFromType, s2.key.name), t2.has(s2.key.name) && this.raise(s2.key.start, Rn.ModuleAttributesWithDuplicateKeys, s2.key.name), t2.add(s2.key.name), this.expect(bn.colon), !this.match(bn.string))
        throw this.unexpected(this.state.start, Rn.ModuleAttributeInvalidValue);
      s2.value = this.parseStringLiteral(this.state.value), this.finishNode(s2, "ImportAttribute"), e6.push(s2);
    } while (this.eat(bn.comma));
    return e6;
  }
  maybeParseImportAssertions() {
    if (!this.isContextual("assert") || this.hasPrecedingLineBreak())
      return this.hasPlugin("importAssertions") ? [] : null;
    this.expectPlugin("importAssertions"), this.next(), this.eat(bn.braceL);
    const e6 = this.parseAssertEntries();
    return this.eat(bn.braceR), e6;
  }
  maybeParseDefaultImportSpecifier(e6) {
    return !!this.shouldParseDefaultImport(e6) && (this.parseImportSpecifierLocal(e6, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), true);
  }
  maybeParseStarImportSpecifier(e6) {
    if (this.match(bn.star)) {
      const t2 = this.startNode();
      return this.next(), this.expectContextual("as"), this.parseImportSpecifierLocal(e6, t2, "ImportNamespaceSpecifier", "import namespace specifier"), true;
    }
    return false;
  }
  parseNamedImportSpecifiers(e6) {
    let t2 = true;
    for (this.expect(bn.braceL); !this.eat(bn.braceR); ) {
      if (t2)
        t2 = false;
      else {
        if (this.eat(bn.colon))
          throw this.raise(this.state.start, Rn.DestructureNamedImport);
        if (this.expect(bn.comma), this.eat(bn.braceR))
          break;
      }
      this.parseImportSpecifier(e6);
    }
  }
  parseImportSpecifier(e6) {
    const t2 = this.startNode(), s2 = this.match(bn.string);
    if (t2.imported = this.parseModuleExportName(), this.eatContextual("as"))
      t2.local = this.parseIdentifier();
    else {
      const { imported: e7 } = t2;
      if (s2)
        throw this.raise(t2.start, Rn.ImportBindingIsString, e7.value);
      this.checkReservedWord(e7.name, t2.start, true, true), t2.local = Io(e7);
    }
    this.checkLVal(t2.local, "import specifier", 9), e6.specifiers.push(this.finishNode(t2, "ImportSpecifier"));
  }
  isThisParam(e6) {
    return e6.type === "Identifier" && e6.name === "this";
  }
} {
  constructor(e6, t2) {
    super(e6 = function(e7) {
      const t3 = {};
      for (const s2 of Object.keys(au))
        t3[s2] = e7 && e7[s2] != null ? e7[s2] : au[s2];
      return t3;
    }(e6), t2), this.options = e6, this.initializeScopes(), this.plugins = function(e7) {
      const t3 = new Map();
      for (const s2 of e7) {
        const [e8, r2] = Array.isArray(s2) ? s2 : [s2, {}];
        t3.has(e8) || t3.set(e8, r2 || {});
      }
      return t3;
    }(this.options.plugins), this.filename = e6.sourceFilename;
  }
  getScopeHandler() {
    return co;
  }
  parse() {
    this.enterInitialScopes();
    const e6 = this.startNode(), t2 = this.startNode();
    return this.nextToken(), e6.errors = null, this.parseTopLevel(e6, t2), e6.errors = this.state.errors, e6;
  }
};
function lu(e6, t2) {
  let s2 = pu;
  return e6 != null && e6.plugins && (!function(e7) {
    if (Qo(e7, "decorators")) {
      if (Qo(e7, "decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      const t3 = Zo(e7, "decorators", "decoratorsBeforeExport");
      if (t3 == null)
        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
      if (typeof t3 != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
    }
    if (Qo(e7, "flow") && Qo(e7, "typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (Qo(e7, "placeholders") && Qo(e7, "v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (Qo(e7, "pipelineOperator")) {
      const t3 = Zo(e7, "pipelineOperator", "proposal");
      if (!eu.includes(t3)) {
        const e8 = eu.map((e9) => `"${e9}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${e8}.`);
      }
      const s3 = Qo(e7, "recordAndTuple") && Zo(e7, "recordAndTuple", "syntaxType") === "hash";
      if (t3 === "hack") {
        if (Qo(e7, "placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (Qo(e7, "v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        const t4 = Zo(e7, "pipelineOperator", "topicToken");
        if (!tu.includes(t4)) {
          const e8 = tu.map((e9) => `"${e9}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${e8}.`);
        }
        if (t4 === "#" && s3)
          throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
      } else if (t3 === "smart" && s3)
        throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
    }
    if (Qo(e7, "moduleAttributes")) {
      if (Qo(e7, "importAssertions"))
        throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
      if (Zo(e7, "moduleAttributes", "version") !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
    }
    if (Qo(e7, "recordAndTuple") && !su.includes(Zo(e7, "recordAndTuple", "syntaxType")))
      throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + su.map((e8) => `'${e8}'`).join(", "));
    if (Qo(e7, "asyncDoExpressions") && !Qo(e7, "doExpressions")) {
      const e8 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw e8.missingPlugins = "doExpressions", e8;
    }
  }(e6.plugins), s2 = function(e7) {
    const t3 = iu.filter((t4) => Qo(e7, t4)), s3 = t3.join("/");
    let r2 = du[s3];
    if (!r2) {
      r2 = pu;
      for (const e8 of t3)
        r2 = ru[e8](r2);
      du[s3] = r2;
    }
    return r2;
  }(e6.plugins)), new s2(e6, t2);
}
var du = {};
var Du = function(e6, t2) {
  var s2;
  if (((s2 = t2) == null ? void 0 : s2.sourceType) !== "unambiguous")
    return lu(t2, e6).parse();
  t2 = Object.assign({}, t2);
  try {
    t2.sourceType = "module";
    const s3 = lu(t2, e6), r2 = s3.parse();
    if (s3.sawUnambiguousESM)
      return r2;
    if (s3.ambiguousScriptDifferentAst)
      try {
        return t2.sourceType = "script", lu(t2, e6).parse();
      } catch (e7) {
      }
    else
      r2.program.sourceType = "script";
    return r2;
  } catch (s3) {
    try {
      return t2.sourceType = "script", lu(t2, e6).parse();
    } catch (e7) {
    }
    throw s3;
  }
};
var mu = function(e6, t2) {
  const s2 = lu(t2, e6);
  return s2.options.strictMode && (s2.state.strict = true), s2.getExpression();
};
var fu = bn;
var yu = Object.defineProperty({ parse: Du, parseExpression: mu, tokTypes: fu }, "__esModule", { value: true });
var { isNonEmptyArray: Au } = tr;
function Eu(e6 = {}) {
  const { allowComments: t2 = true } = e6;
  return function(e7) {
    const { parseExpression: s2 } = yu;
    let r2;
    try {
      r2 = s2(e7, { tokens: true, ranges: true });
    } catch (e8) {
      throw ni(e8);
    }
    if (!t2 && Au(r2.comments))
      throw Cu(r2.comments[0], "Comment");
    return xu(r2), r2;
  };
}
function Cu(e6, t2) {
  const [s2, r2] = [e6.loc.start, e6.loc.end].map(({ line: e7, column: t3 }) => ({ line: e7, column: t3 + 1 }));
  return ai(`${t2} is not allowed in JSON.`, { start: s2, end: r2 });
}
function xu(e6) {
  switch (e6.type) {
    case "ArrayExpression":
      for (const t2 of e6.elements)
        t2 !== null && xu(t2);
      return;
    case "ObjectExpression":
      for (const t2 of e6.properties)
        xu(t2);
      return;
    case "ObjectProperty":
      if (e6.computed)
        throw Cu(e6.key, "Computed key");
      if (e6.shorthand)
        throw Cu(e6.key, "Shorthand property");
      return e6.key.type !== "Identifier" && xu(e6.key), void xu(e6.value);
    case "UnaryExpression": {
      const { operator: t2, argument: s2 } = e6;
      if (t2 !== "+" && t2 !== "-")
        throw Cu(e6, `Operator '${e6.operator}'`);
      if (s2.type === "NumericLiteral" || s2.type === "Identifier" && (s2.name === "Infinity" || s2.name === "NaN"))
        return;
      throw Cu(s2, `Operator '${t2}' before '${s2.type}'`);
    }
    case "Identifier":
      if (e6.name !== "Infinity" && e6.name !== "NaN" && e6.name !== "undefined")
        throw Cu(e6, `Identifier '${e6.name}'`);
      return;
    case "TemplateLiteral":
      if (Au(e6.expressions))
        throw Cu(e6.expressions[0], "'TemplateLiteral' with expression");
      for (const t2 of e6.quasis)
        xu(t2);
      return;
    case "NullLiteral":
    case "BooleanLiteral":
    case "NumericLiteral":
    case "StringLiteral":
    case "TemplateElement":
      return;
    default:
      throw Cu(e6, `'${e6.type}'`);
  }
}
var Fu = Eu();
var gu = { json: ii({ parse: Fu, hasPragma: () => true }), json5: ii(Fu), "json-stringify": ii({ parse: Eu({ allowComments: false }), astFormat: "estree-json" }) };
var { getNextNonSpaceNonCommentCharacterIndexWithStartIndex: bu, getShebang: Pu } = tr;
var Tu = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", ["decorators", { decoratorsBeforeExport: false }], "importAssertions", "decimal", "classStaticBlock", "moduleBlocks", "asyncDoExpressions"], tokens: true, ranges: true };
var wu = ["recordAndTuple", { syntaxType: "hash" }];
var Su = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]];
var Bu = (e6, t2 = Tu) => Object.assign(Object.assign({}, t2), {}, { plugins: [...t2.plugins, ...e6] });
var Nu = /@(?:no)?flow\b/;
function Iu(e6, ...t2) {
  return (s2, r2, i2 = {}) => {
    if ((i2.parser === "babel" || i2.parser === "__babel_estree") && function(e7, t3) {
      if (t3.filepath && t3.filepath.endsWith(".js.flow"))
        return true;
      const s3 = Pu(e7);
      s3 && (e7 = e7.slice(s3.length));
      const r3 = bu(e7, 0);
      return r3 !== false && (e7 = e7.slice(0, r3)), Nu.test(e7);
    }(s2, i2))
      return i2.parser = "babel-flow", ku(s2, r2, i2);
    let a2 = t2;
    i2.__babelSourceType === "script" && (a2 = a2.map((e7) => Object.assign(Object.assign({}, e7), {}, { sourceType: "script" }))), /#[[{]/.test(s2) && (a2 = a2.map((e7) => Bu([wu], e7)));
    const n2 = /%[A-Z]/.test(s2);
    if (s2.includes("|>")) {
      const e7 = n2 ? [...Su, "v8intrinsic"] : Su;
      a2 = e7.flatMap((e8) => a2.map((t3) => Bu([e8], t3)));
    } else
      n2 && (a2 = a2.map((e7) => Bu(["v8intrinsic"], e7)));
    const { result: o2, error: u2 } = Je(...a2.map((t3) => () => function(e7, t4, s3) {
      const r3 = (0, yu[e7])(t4, s3), i3 = r3.errors.find((e8) => !Ru.has(e8.reasonCode));
      if (i3)
        throw i3;
      return r3;
    }(e6, s2, t3)));
    if (!o2)
      throw ni(u2);
    return En(o2, Object.assign(Object.assign({}, i2), {}, { originalText: s2 }));
  };
}
var vu = Iu("parse", Bu(["jsx", "flow"]));
var ku = Iu("parse", Bu(["jsx", ["flow", { all: true, enums: true }]]));
var Lu = Iu("parse", Bu(["jsx", "typescript"]), Bu(["typescript"]));
var Ou = Iu("parse", Bu(["jsx", "flow", "estree"]));
var Mu = Iu("parseExpression", Bu(["jsx"]));
var Ru = new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "UnexpectedParameterModifier", "MixedLabeledAndUnlabeledElements", "InvalidTupleMemberLabel", "NonClassMethodPropertyHasAbstractModifer", "ReadonlyForMethodSignature", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "InvalidModifierOnTypeMember", "DuplicateAccessibilityModifier", "IndexSignatureHasDeclare", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "UnsupportedPropertyDecorator", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]);
var ju = ii(vu);
var _u = ii(Mu);
var Uu = { parsers: Object.assign(Object.assign({ babel: ju, "babel-flow": ii(ku), "babel-ts": ii(Lu) }, gu), {}, { __js_expression: _u, __vue_expression: _u, __vue_event_binding: ju, __babel_estree: ii(Ou) }) };
var parser_babel_default = Uu;

// dep:prettier_esm_parser-babel
var prettier_esm_parser_babel_default = parser_babel_default;
export {
  prettier_esm_parser_babel_default as default
};
//# sourceMappingURL=prettier_esm_parser-babel.js.map
