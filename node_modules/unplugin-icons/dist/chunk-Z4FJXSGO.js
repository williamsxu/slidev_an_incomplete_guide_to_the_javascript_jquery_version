"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkPZ3KAP26js = require('./chunk-PZ3KAP26.js');



var _chunkGMAU6NZDjs = require('./chunk-GMAU6NZD.js');

// src/core/loader.ts
var _jsontools = require('@iconify/json-tools'); var _jsontools2 = _interopRequireDefault(_jsontools);

// src/core/compilers/jsx.ts
var JSXCompiler = async (svg, collection, icon, options) => {
  const svgr = _chunkGMAU6NZDjs.__require.call(void 0, "@svgr/core").default;
  let res = await svgr(svg, { icon: true }, { componentName: _chunkPZ3KAP26js.camelize.call(void 0, `${collection}-${icon}`) });
  if (options.jsx === "preact")
    res = res.replace('import * as React from "react";', "");
  return res;
};

// src/core/compilers/none.ts
var NoneCompiler = (svg) => {
  return svg;
};

// src/core/compilers/raw.ts
var RawCompiler = (svg) => {
  return `export default ${JSON.stringify(svg)}`;
};

// src/core/compilers/solid.ts
var SolidCompiler = (svg) => {
  return `
import { template, spread } from "solid-js/web";

const _tmpl$ = template(\`${svg}\`, 0);
export default (props = {}) => {
    const _el$ = _tmpl$.cloneNode(true);
    spread(_el$, props, true);
    return _el$;
};
  `;
};

// src/core/compilers/svelte.ts
var SvelteCompiler = (svg) => {
  const openTagEnd = svg.indexOf(">", svg.indexOf("<svg "));
  const closeTagStart = svg.lastIndexOf("</svg");
  const openTag = `${svg.slice(0, openTagEnd)} {...$$props}>`;
  const content = `{@html \`${escapeSvelte(svg.slice(openTagEnd, closeTagStart))}\`}`;
  const closeTag = svg.slice(closeTagStart);
  return `${openTag}${content}${closeTag}`;
};
function escapeSvelte(str) {
  return str.replace(/{/g, "&#123;").replace(/}/g, "&#125;").replace(/`/g, "&#96;").replace(/\\([trn])/g, " ");
}

// src/core/compilers/vue2.ts
var Vue2Compiler = async (svg, collection, icon) => {
  const { compile } = await Promise.resolve().then(() => _chunkGMAU6NZDjs.__toModule.call(void 0, _chunkGMAU6NZDjs.__require.call(void 0, "vue-template-compiler")));
  const transpile = (await Promise.resolve().then(() => _chunkGMAU6NZDjs.__toModule.call(void 0, _chunkGMAU6NZDjs.__require.call(void 0, "vue-template-es2015-compiler")))).default;
  const { render } = compile(svg);
  const toFunction = (code2) => {
    return `function () {${code2}}`;
  };
  let code = transpile(`var __render__ = ${toFunction(render)}
`, {});
  code = code.replace(/\s__(render|staticRenderFns)__\s/g, " $1 ");
  code += `
/* vite-plugin-components disabled */
export default {
  render: render,
  name: '${collection}-${icon}',
}
`;
  return code;
};

// src/core/compilers/vue3.ts
var Vue3Compiler = async (svg, collection, icon) => {
  const { compileTemplate } = await Promise.resolve().then(() => _chunkGMAU6NZDjs.__toModule.call(void 0, _chunkGMAU6NZDjs.__require.call(void 0, "@vue/compiler-sfc")));
  let { code } = compileTemplate({
    source: svg,
    id: `${collection}:${icon}`,
    filename: `${collection}-${icon}.vue`
  });
  code = code.replace(/^export /g, "");
  code += `

export default { name: '${collection}-${icon}', render }`;
  code += "\n/* vite-plugin-components disabled */";
  return code;
};

// src/core/compilers/web-components.ts
var WebComponentsCompiler = (svg, collection, icon, { webComponents: options }) => {
  let id = `${collection}-${icon}`;
  if (options.iconPrefix)
    id = `${options.iconPrefix}-${id}`;
  const name = _chunkPZ3KAP26js.camelize.call(void 0, id);
  return `
export default class ${name} extends HTMLElement {
  constructor() {
    super()
    this.innerHTML = ${JSON.stringify(svg)}
  }
}
${options.autoDefine ? `customElements.define('${id}', ${name})` : ""}
`;
};

// src/core/compilers/index.ts
var compilers = {
  "vue2": Vue2Compiler,
  "vue3": Vue3Compiler,
  "solid": SolidCompiler,
  "svelte": SvelteCompiler,
  "jsx": JSXCompiler,
  "none": NoneCompiler,
  "raw": RawCompiler,
  "web-components": WebComponentsCompiler
};

// src/core/loader.ts
var URL_PREFIXES = ["/~icons/", "~icons/", "virtual:icons/", "virtual/icons/"];
var iconPathRE = new RegExp(`${URL_PREFIXES.map((v) => `^${v}`).join("|")}`);
var { SVG, Collection } = _jsontools2.default;
function isIconPath(path) {
  return iconPathRE.test(path);
}
function normalizeIconPath(path) {
  return path.replace(iconPathRE, URL_PREFIXES[0]);
}
function resolveIconsPath(path) {
  if (!isIconPath(path))
    return null;
  path = path.replace(iconPathRE, "");
  const query = {};
  const queryIndex = path.indexOf("?");
  if (queryIndex !== -1) {
    const queryRaw = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
    new URLSearchParams(queryRaw).forEach((value, key) => {
      query[value] = key;
    });
  }
  path = path.replace(/\.\w+$/, "");
  const [collection, icon] = path.split("/");
  return {
    collection,
    icon,
    query
  };
}
var _collections = {};
var _idTransforms = [
  (str) => str,
  (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
  (str) => str.replace(/([a-z])(\d+)/g, "$1-$2")
];
function getCollection(name) {
  if (!_collections[name]) {
    const collection = new Collection();
    collection.loadIconifyCollection(name);
    _collections[name] = collection;
  }
  return _collections[name];
}
function getBuiltinIcon(collection, icon) {
  const icons = getCollection(collection);
  if (!icons)
    return null;
  let data;
  for (const trans of _idTransforms) {
    data = icons.getIconData(trans(icon));
    if (data)
      return data;
  }
  return null;
}
async function getIcon(collection, icon, options) {
  const { scale } = options;
  const custom = options.customCollections[collection];
  if (custom) {
    let result;
    if (typeof custom === "function") {
      result = await custom(icon);
    } else {
      const inline = custom[icon];
      result = typeof inline === "function" ? await inline() : inline;
    }
    if (result) {
      if (!result.startsWith("<svg "))
        console.warn(`Custom icon "${icon}" in "${collection}" is not a valid SVG`);
      return result.replace("<svg ", `<svg height="${scale}em" width="${scale}em" `);
    }
  }
  const iconData = getBuiltinIcon(collection, icon);
  const svg = new SVG(iconData);
  const svgText = svg.getSVG({
    height: `${scale}em`,
    width: `${scale}em`
  });
  return svgText;
}
async function generateComponent({ collection, icon }, options) {
  let svg = await getIcon(collection, icon, options);
  if (!svg)
    throw new Error(`Icon \`${collection}:${icon}\` not found`);
  const { defaultStyle, defaultClass } = options;
  if (defaultClass)
    svg = svg.replace("<svg ", `<svg class="${defaultClass}" `);
  if (defaultStyle)
    svg = svg.replace("<svg ", `<svg style="${defaultStyle}" `);
  const compiler = compilers[options.compiler];
  if (!compiler)
    throw new Error(`Unknown compiler: ${options.compiler}`);
  return compiler(svg, collection, icon, options);
}
async function generateComponentFromPath(path, options) {
  const resolved = resolveIconsPath(path);
  if (!resolved)
    return null;
  return generateComponent(resolved, options);
}






exports.isIconPath = isIconPath; exports.normalizeIconPath = normalizeIconPath; exports.getBuiltinIcon = getBuiltinIcon; exports.generateComponentFromPath = generateComponentFromPath;
