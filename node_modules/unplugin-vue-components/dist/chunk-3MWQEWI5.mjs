import {
  DISABLE_COMMENT,
  LibraryResolver,
  getNameFromFilePath,
  matchGlobs,
  parseId,
  pascalCase,
  require_dist,
  resolveAlias,
  shouldTransform,
  stringifyComponentImport
} from "./chunk-CO5G4WEO.mjs";
import {
  __require,
  __spreadProps,
  __spreadValues,
  __toModule
} from "./chunk-PJJOEYQ7.mjs";

// src/core/unplugin.ts
import { createUnplugin } from "unplugin";
import { createFilter } from "@rollup/pluginutils";
import chokidar from "chokidar";

// src/core/context.ts
var import_utils5 = __toModule(require_dist());
import { relative as relative2 } from "path";
import Debug4 from "debug";

// src/core/options.ts
var import_utils = __toModule(require_dist());
import { join, resolve } from "path";
import hasPkg from "has-pkg";
var defaultOptions = {
  dirs: "src/components",
  extensions: "vue",
  deep: true,
  dts: hasPkg("typescript"),
  directoryAsNamespace: false,
  globalNamespaces: [],
  libraries: [],
  resolvers: [],
  importPathTransform: (v) => v,
  allowOverrides: false
};
function resolveOptions(options, root) {
  const resolved = Object.assign({}, defaultOptions, options);
  resolved.libraries = (0, import_utils.toArray)(resolved.libraries).map((i) => typeof i === "string" ? { name: i } : i);
  resolved.resolvers = (0, import_utils.toArray)(resolved.resolvers);
  resolved.resolvers.push(...resolved.libraries.map((lib) => LibraryResolver(lib)));
  resolved.extensions = (0, import_utils.toArray)(resolved.extensions);
  if (resolved.globs) {
    resolved.globs = (0, import_utils.toArray)(resolved.globs).map((glob) => (0, import_utils.slash)(resolve(root, glob)));
  } else {
    const extsGlob = resolved.extensions.length === 1 ? resolved.extensions : `{${resolved.extensions.join(",")}}`;
    resolved.dirs = (0, import_utils.toArray)(resolved.dirs);
    resolved.resolvedDirs = resolved.dirs.map((i) => (0, import_utils.slash)(resolve(root, i)));
    resolved.globs = resolved.resolvedDirs.map((i) => resolved.deep ? (0, import_utils.slash)(join(i, `**/*.${extsGlob}`)) : (0, import_utils.slash)(join(i, `*.${extsGlob}`)));
    if (!resolved.extensions.length)
      throw new Error("[unplugin-vue-components] `extensions` option is required to search for components");
  }
  resolved.dts = !options.dts ? false : resolve(root, typeof options.dts === "string" ? options.dts : "components.d.ts");
  resolved.root = root;
  resolved.transformer = options.transformer || getVueVersion() || "vue3";
  return resolved;
}
function getVueVersion() {
  var _a;
  try {
    const vue = __require("vue");
    const version = ((_a = vue == null ? void 0 : vue.default) == null ? void 0 : _a.version) || (vue == null ? void 0 : vue.version) || "3";
    return version.startsWith("2.") ? "vue2" : "vue3";
  } catch {
    return null;
  }
}

// src/core/fs/glob.ts
import fg from "fast-glob";
import Debug from "debug";
var debug = Debug("unplugin-vue-components:glob");
function searchComponents(ctx) {
  var _a;
  debug(`started with: [${ctx.options.globs.join(", ")}]`);
  const root = ctx.root;
  const files = fg.sync(ctx.options.globs, {
    ignore: ["node_modules"],
    onlyFiles: true,
    cwd: root,
    absolute: true
  });
  if (!files.length && !((_a = ctx.options.resolvers) == null ? void 0 : _a.length))
    console.warn("[unplugin-vue-components] no components found");
  debug(`${files.length} components found.`);
  ctx.addComponents(files);
}

// src/core/declaration.ts
var import_utils2 = __toModule(require_dist());
import { dirname, relative } from "path";
import { promises as fs, existsSync } from "fs";
function parseDeclaration(code) {
  return Object.fromEntries(Array.from(code.matchAll(/(?<!\/\/)\s+\s+['"]?(.+?)['"]?:\s(.+?)\n/g)).map((i) => [i[1], i[2]]));
}
async function generateDeclaration(ctx, root, filepath) {
  const imports = Object.fromEntries(Object.values(__spreadValues(__spreadValues({}, ctx.componentNameMap), ctx.componentCustomMap)).map(({ path, name, importName }) => {
    if (!name)
      return void 0;
    const related = (0, import_utils2.slash)(path).startsWith("/") ? `./${relative(dirname(filepath), path)}` : path;
    let entry = `typeof import('${(0, import_utils2.slash)(related)}')`;
    if (importName)
      entry += `['${importName}']`;
    else
      entry += "['default']";
    return [name, entry];
  }).filter(import_utils2.notNullish));
  if (!Object.keys(imports).length)
    return;
  const originalImports = existsSync(filepath) ? parseDeclaration(await fs.readFile(filepath, "utf-8")) : {};
  const lines = Object.entries(__spreadValues(__spreadValues({}, originalImports), imports)).sort((a, b) => a[0].localeCompare(b[0])).map(([name, v]) => {
    if (!/^\w+$/.test(name))
      name = `'${name}'`;
    return `${name}: ${v}`;
  });
  const code = `// generated by unplugin-vue-components
// We suggest you to commit this file into source control
// Read more: https://github.com/vuejs/vue-next/pull/3399

declare module 'vue' {
  export interface GlobalComponents {
    ${lines.join("\n    ")}
  }
}

export { }
`;
  await fs.writeFile(filepath, code, "utf-8");
}

// src/core/transforms/vue2.ts
import Debug2 from "debug";
import MagicString from "magic-string";
var debug2 = Debug2("unplugin-vue-components:transform:vue2");
function Vue2Transformer(ctx) {
  return (code, id, path, query) => {
    ctx.searchGlob();
    const sfcPath = ctx.normalizePath(path);
    debug2(sfcPath);
    const head = [];
    let no = 0;
    const componentPaths = [];
    const s = new MagicString(code);
    for (const match of code.matchAll(/_c\([\s\n\t]*['"](.+?)["']([,)])/g)) {
      const [full, matchedName, append] = match;
      if (match.index != null && matchedName && !matchedName.startsWith("_")) {
        const start = match.index;
        const end = start + full.length;
        debug2(`| ${matchedName}`);
        const name = pascalCase(matchedName);
        componentPaths.push(name);
        const component = ctx.findComponent(name, [sfcPath], matchedName);
        if (component) {
          const var_name = `__unplugin_components_${no}`;
          head.push(stringifyComponentImport(__spreadProps(__spreadValues({}, component), { name: var_name }), ctx));
          no += 1;
          s.overwrite(start, end, `_c(${var_name}${append}`);
        }
      }
    }
    debug2(`^ (${no})`);
    ctx.updateUsageMap(sfcPath, componentPaths);
    if (!head.length)
      return null;
    s.prepend(`${DISABLE_COMMENT}${head.join(";")};`);
    const result = { code: s.toString() };
    if (ctx.sourcemap)
      result.map = s.generateMap({ source: id, includeContent: true });
    return result;
  };
}

// src/core/transforms/vue3.ts
import Debug3 from "debug";
import MagicString2 from "magic-string";
var debug3 = Debug3("unplugin-vue-components:transform:vue3");
function Vue3Transformer(ctx) {
  return (code, id, path, query) => {
    ctx.searchGlob();
    const sfcPath = ctx.normalizePath(path);
    debug3(sfcPath);
    const head = [];
    let no = 0;
    const componentPaths = [];
    const s = new MagicString2(code);
    for (const match of code.matchAll(/_resolveComponent\("(.+?)"\)/g)) {
      const matchedName = match[1];
      if (match.index != null && matchedName && !matchedName.startsWith("_")) {
        const start = match.index;
        const end = start + match[0].length;
        debug3(`| ${matchedName}`);
        const name = pascalCase(matchedName);
        componentPaths.push(name);
        const component = ctx.findComponent(name, [sfcPath], matchedName);
        if (component) {
          const var_name = `__unplugin_components_${no}`;
          head.push(stringifyComponentImport(__spreadProps(__spreadValues({}, component), { name: var_name }), ctx));
          no += 1;
          s.overwrite(start, end, var_name);
        }
      }
    }
    debug3(`^ (${no})`);
    ctx.updateUsageMap(sfcPath, componentPaths);
    if (!head.length)
      return null;
    s.prepend(`${DISABLE_COMMENT}${head.join(";")};`);
    const result = { code: s.toString() };
    if (ctx.sourcemap)
      result.map = s.generateMap({ source: id, includeContent: true });
    return result;
  };
}

// src/core/context.ts
var debug4 = {
  components: Debug4("unplugin-vue-components:context:components"),
  search: Debug4("unplugin-vue-components:context:search"),
  hmr: Debug4("unplugin-vue-components:context:hmr"),
  decleration: Debug4("unplugin-vue-components:decleration"),
  env: Debug4("unplugin-vue-components:env")
};
var Context = class {
  constructor(rawOptions) {
    this.rawOptions = rawOptions;
    this.transformer = void 0;
    this._componentPaths = new Set();
    this._componentNameMap = {};
    this._componentUsageMap = {};
    this._componentCustomMap = {};
    this.root = process.cwd();
    this.sourcemap = true;
    this.alias = {};
    this._searched = false;
    this.options = resolveOptions(rawOptions, this.root);
    this.generateDeclaration = (0, import_utils5.throttle)(500, false, this.generateDeclaration.bind(this));
    this.setTransformer(this.options.transformer);
  }
  setRoot(root) {
    if (this.root === root)
      return;
    debug4.env("root", root);
    this.root = root;
    this.options = resolveOptions(this.rawOptions, this.root);
  }
  setTransformer(name) {
    debug4.env("transformer", name);
    this.transformer = name === "vue2" ? Vue2Transformer(this) : Vue3Transformer(this);
  }
  transform(code, id) {
    const { path, query } = parseId(id);
    return this.transformer(code, id, path, query);
  }
  setupViteServer(server) {
    if (this._server === server)
      return;
    this._server = server;
    this.setupWather(server.watcher);
  }
  setupWather(watcher) {
    const { globs } = this.options;
    watcher.on("unlink", (path) => {
      if (!matchGlobs(path, globs))
        return;
      this.removeComponents(path);
      this.onUpdate(path);
    });
    watcher.on("add", (path) => {
      if (!matchGlobs(path, globs))
        return;
      this.addComponents(path);
      this.onUpdate(path);
    });
  }
  updateUsageMap(path, paths) {
    if (!this._componentUsageMap[path])
      this._componentUsageMap[path] = new Set();
    paths.forEach((p) => {
      this._componentUsageMap[path].add(p);
    });
  }
  addComponents(paths) {
    debug4.components("add", paths);
    const size = this._componentPaths.size;
    (0, import_utils5.toArray)(paths).forEach((p) => this._componentPaths.add(p));
    if (this._componentPaths.size !== size) {
      this.updateComponentNameMap();
      return true;
    }
    return false;
  }
  addCustomComponents(info) {
    if (info.name)
      this._componentCustomMap[info.name] = info;
  }
  removeComponents(paths) {
    debug4.components("remove", paths);
    const size = this._componentPaths.size;
    (0, import_utils5.toArray)(paths).forEach((p) => this._componentPaths.delete(p));
    if (this._componentPaths.size !== size) {
      this.updateComponentNameMap();
      return true;
    }
    return false;
  }
  onUpdate(path) {
    this.generateDeclaration();
    if (!this._server)
      return;
    const payload = {
      type: "update",
      updates: []
    };
    const timestamp = +new Date();
    const name = pascalCase(getNameFromFilePath(path, this.options));
    Object.entries(this._componentUsageMap).forEach(([key, values]) => {
      if (values.has(name)) {
        const r = `/${(0, import_utils5.slash)(relative2(this.root, key))}`;
        payload.updates.push({
          acceptedPath: r,
          path: r,
          timestamp,
          type: "js-update"
        });
      }
    });
    if (payload.updates.length)
      this._server.ws.send(payload);
  }
  updateComponentNameMap() {
    this._componentNameMap = {};
    Array.from(this._componentPaths).forEach((path) => {
      const name = pascalCase(getNameFromFilePath(path, this.options));
      if (this._componentNameMap[name] && !this.options.allowOverrides) {
        console.warn(`[unplugin-vue-components] component "${name}"(${path}) has naming conflicts with other components, ignored.`);
        return;
      }
      this._componentNameMap[name] = {
        name,
        path
      };
    });
  }
  findComponent(name, excludePaths = [], rawName) {
    let info = this._componentNameMap[name];
    if (info && !excludePaths.includes(info.path) && !excludePaths.includes(info.path.slice(1)))
      return info;
    for (const resolver of this.options.resolvers) {
      const result = resolver(name);
      if (result) {
        if (typeof result === "string") {
          info = {
            name,
            path: result
          };
          this.addCustomComponents(info);
          return info;
        } else {
          info = __spreadValues({
            name
          }, result);
          this.addCustomComponents(info);
          return info;
        }
      }
    }
    return void 0;
  }
  findComponents(names, excludePaths = []) {
    return names.map((name) => this.findComponent(name, excludePaths)).filter(Boolean);
  }
  normalizePath(path) {
    var _a, _b, _c;
    return resolveAlias(path, ((_b = (_a = this.viteConfig) == null ? void 0 : _a.resolve) == null ? void 0 : _b.alias) || ((_c = this.viteConfig) == null ? void 0 : _c.alias) || []);
  }
  relative(path) {
    if (path.startsWith("/") && !path.startsWith(this.root))
      return (0, import_utils5.slash)(path.slice(1));
    return (0, import_utils5.slash)(relative2(this.root, path));
  }
  searchGlob() {
    if (this._searched)
      return;
    searchComponents(this);
    debug4.search(this._componentNameMap);
    this._searched = true;
  }
  generateDeclaration() {
    if (!this.options.dts)
      return;
    debug4.decleration("generating");
    generateDeclaration(this, this.options.root, this.options.dts);
  }
  get componentNameMap() {
    return this._componentNameMap;
  }
  get componentCustomMap() {
    return this._componentCustomMap;
  }
};

// src/core/unplugin.ts
var unplugin_default = createUnplugin((options = {}) => {
  const filter = createFilter(options.include || [/\.vue$/, /\.vue\?vue/], options.exclude || [/node_modules/, /\.git/, /\.nuxt/]);
  const ctx = new Context(options);
  return {
    name: "unplugin-vue-components",
    enforce: "post",
    transformInclude(id) {
      return filter(id);
    },
    async transform(code, id) {
      if (!shouldTransform(code))
        return null;
      try {
        const result = await ctx.transform(code, id);
        ctx.generateDeclaration();
        return result;
      } catch (e) {
        this.error(e);
      }
    },
    vite: {
      configResolved(config) {
        ctx.setRoot(config.root);
        ctx.sourcemap = config.build.sourcemap;
        if (config.plugins.find((i) => i.name === "vite-plugin-vue2"))
          ctx.setTransformer("vue2");
        if (options.dts) {
          ctx.searchGlob();
          ctx.generateDeclaration();
        }
        if (config.build.watch && config.command === "build")
          ctx.setupWather(chokidar.watch(ctx.options.globs));
      },
      configureServer(server) {
        ctx.setupViteServer(server);
      }
    }
  };
});

export {
  unplugin_default
};
