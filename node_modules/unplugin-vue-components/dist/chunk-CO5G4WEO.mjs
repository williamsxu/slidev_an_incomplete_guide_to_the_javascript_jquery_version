import {
  __commonJS,
  __require,
  __toModule
} from "./chunk-PJJOEYQ7.mjs";

// node_modules/.pnpm/@antfu+utils@0.3.0/node_modules/@antfu/utils/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/@antfu+utils@0.3.0/node_modules/@antfu/utils/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function clamp(n, min, max) {
      return Math.min(max, Math.max(min, n));
    }
    function sum(...args) {
      return flattenArrayable(args).reduce((a, b) => a + b, 0);
    }
    function toArray2(array) {
      array = array || [];
      if (Array.isArray(array))
        return array;
      return [array];
    }
    function flattenArrayable(array) {
      return toArray2(array).flat(1);
    }
    function mergeArrayable(...args) {
      return args.flatMap((i) => toArray2(i));
    }
    function partition(array, ...filters) {
      const result = new Array(filters.length + 1).fill(null).map(() => []);
      array.forEach((e, idx, arr) => {
        let i = 0;
        for (const filter of filters) {
          if (filter(e, idx, arr)) {
            result[i].push(e);
            return;
          }
          i += 1;
        }
        result[i].push(e);
      });
      return result;
    }
    function uniq(array) {
      return Array.from(new Set(array));
    }
    function last(array) {
      return at(array, -1);
    }
    function remove(array, value) {
      if (!array)
        return false;
      const index = array.indexOf(value);
      if (index >= 0) {
        array.splice(index, 1);
        return true;
      }
      return false;
    }
    function at(array, index) {
      const len = array.length;
      if (!len)
        return void 0;
      if (index < 0)
        index += len;
      return array[index];
    }
    function range(...args) {
      let start, stop, step;
      if (args.length === 1) {
        start = 0;
        step = 1;
        [stop] = args;
      } else {
        [start, stop, step = 1] = args;
      }
      const arr = [];
      let current = start;
      while (current < stop) {
        arr.push(current);
        current += step || 1;
      }
      return arr;
    }
    function move(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
      return arr;
    }
    function clampArrayRange(n, arr) {
      return clamp(n, 0, arr.length - 1);
    }
    var assert = (condition, message) => {
      if (!condition)
        throw new Error(message);
    };
    var toString2 = (v) => Object.prototype.toString.call(v);
    var noop = () => {
    };
    function notNullish(v) {
      return v != null;
    }
    function noNull(v) {
      return v !== null;
    }
    function notUndefined(v) {
      return v !== void 0;
    }
    function isTruthy(v) {
      return Boolean(v);
    }
    var isBrowser = typeof window !== "undefined";
    var isDef = (val) => typeof val !== "undefined";
    var isBoolean = (val) => typeof val === "boolean";
    var isFunction = (val) => typeof val === "function";
    var isNumber = (val) => typeof val === "number";
    var isString = (val) => typeof val === "string";
    var isObject = (val) => toString.call(val) === "[object Object]";
    var isWindow = (val) => typeof window !== "undefined" && toString.call(val) === "[object Window]";
    function slash2(str) {
      return str.replace(/\\/g, "/");
    }
    function ensurePrefix(prefix, str) {
      if (!str.startsWith(prefix))
        return prefix + str;
      return str;
    }
    function template(str, ...args) {
      return str.replace(/{(\d+)}/g, (match, key) => {
        const index = Number(key);
        if (Number.isNaN(index))
          return match;
        return args[index];
      });
    }
    var timestamp = () => +Date.now();
    function batchInvoke(functions) {
      functions.forEach((fn) => fn && fn());
    }
    function invoke(fn) {
      return fn();
    }
    function tap(value, callback) {
      callback(value);
      return value;
    }
    function objectMap(obj, fn) {
      return Object.fromEntries(Object.entries(obj).map(([k, v]) => fn(k, v)).filter(notNullish));
    }
    function isKeyOf(obj, k) {
      return k in obj;
    }
    function objectKeys(obj) {
      return Object.keys(obj);
    }
    function objectEntries(obj) {
      return Object.entries(obj);
    }
    function deepMerge(target, ...sources) {
      if (!sources.length)
        return target;
      const source = sources.shift();
      if (source === void 0)
        return target;
      if (isMergableObject(target) && isMergableObject(source)) {
        objectKeys(source).forEach((key) => {
          if (isMergableObject(source[key])) {
            if (!target[key])
              target[key] = {};
            deepMerge(target[key], source[key]);
          } else {
            target[key] = source[key];
          }
        });
      }
      return deepMerge(target, ...sources);
    }
    function isMergableObject(item) {
      return isObject(item) && !Array.isArray(item);
    }
    function objectPick(obj, keys, omitUndefined = false) {
      return keys.reduce((n, k) => {
        if (k in obj) {
          if (!omitUndefined || !obj[k] === void 0)
            n[k] = obj[k];
        }
        return n;
      }, {});
    }
    function clearUndefined(obj) {
      Object.keys(obj).forEach((key) => obj[key] === void 0 ? delete obj[key] : {});
      return obj;
    }
    function hasOwnProperty(obj, v) {
      if (obj == null)
        return false;
      return Object.prototype.hasOwnProperty.call(obj, v);
    }
    function createSingletonPromise(fn) {
      let _promise;
      function wrapper() {
        if (!_promise)
          _promise = fn();
        return _promise;
      }
      wrapper.reset = async () => {
        const _prev = _promise;
        _promise = void 0;
        if (_prev)
          await _prev;
      };
      return wrapper;
    }
    function sleep(ms, callback) {
      return new Promise((resolve2) => setTimeout(async () => {
        await (callback == null ? void 0 : callback());
        resolve2();
      }, ms));
    }
    function createPromiseLock() {
      const locks = [];
      return {
        async run(fn) {
          const p = fn();
          locks.push(p);
          try {
            return await p;
          } finally {
            remove(locks, p);
          }
        },
        async wait() {
          await Promise.allSettled(locks);
        },
        isWaiting() {
          return Boolean(locks.length);
        },
        clear() {
          locks.length = 0;
        }
      };
    }
    function throttle(delay, noTrailing, callback, debounceMode) {
      var timeoutID;
      var cancelled = false;
      var lastExec = 0;
      function clearExistingTimeout() {
        if (timeoutID) {
          clearTimeout(timeoutID);
        }
      }
      function cancel() {
        clearExistingTimeout();
        cancelled = true;
      }
      if (typeof noTrailing !== "boolean") {
        debounceMode = callback;
        callback = noTrailing;
        noTrailing = void 0;
      }
      function wrapper() {
        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
          arguments_[_key] = arguments[_key];
        }
        var self = this;
        var elapsed = Date.now() - lastExec;
        if (cancelled) {
          return;
        }
        function exec() {
          lastExec = Date.now();
          callback.apply(self, arguments_);
        }
        function clear() {
          timeoutID = void 0;
        }
        if (debounceMode && !timeoutID) {
          exec();
        }
        clearExistingTimeout();
        if (debounceMode === void 0 && elapsed > delay) {
          exec();
        } else if (noTrailing !== true) {
          timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
        }
      }
      wrapper.cancel = cancel;
      return wrapper;
    }
    function debounce(delay, atBegin, callback) {
      return callback === void 0 ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
    }
    exports.assert = assert;
    exports.at = at;
    exports.batchInvoke = batchInvoke;
    exports.clamp = clamp;
    exports.clampArrayRange = clampArrayRange;
    exports.clearUndefined = clearUndefined;
    exports.createPromiseLock = createPromiseLock;
    exports.createSingletonPromise = createSingletonPromise;
    exports.debounce = debounce;
    exports.deepMerge = deepMerge;
    exports.ensurePrefix = ensurePrefix;
    exports.flattenArrayable = flattenArrayable;
    exports.hasOwnProperty = hasOwnProperty;
    exports.invoke = invoke;
    exports.isBoolean = isBoolean;
    exports.isBrowser = isBrowser;
    exports.isDef = isDef;
    exports.isFunction = isFunction;
    exports.isKeyOf = isKeyOf;
    exports.isNumber = isNumber;
    exports.isObject = isObject;
    exports.isString = isString;
    exports.isTruthy = isTruthy;
    exports.isWindow = isWindow;
    exports.last = last;
    exports.mergeArrayable = mergeArrayable;
    exports.move = move;
    exports.noNull = noNull;
    exports.noop = noop;
    exports.notNullish = notNullish;
    exports.notUndefined = notUndefined;
    exports.objectEntries = objectEntries;
    exports.objectKeys = objectKeys;
    exports.objectMap = objectMap;
    exports.objectPick = objectPick;
    exports.partition = partition;
    exports.range = range;
    exports.remove = remove;
    exports.slash = slash2;
    exports.sleep = sleep;
    exports.sum = sum;
    exports.tap = tap;
    exports.template = template;
    exports.throttle = throttle;
    exports.timestamp = timestamp;
    exports.toArray = toArray2;
    exports.toString = toString2;
    exports.uniq = uniq;
  }
});

// src/core/utils.ts
var import_utils = __toModule(require_dist());
import { parse } from "path";
import minimatch from "minimatch";
import resolve from "resolve";

// src/core/constants.ts
var DISABLE_COMMENT = "/* unplugin-vue-components disabled */";

// src/core/utils.ts
function pascalCase(str) {
  return capitalize(camelCase(str));
}
function camelCase(str) {
  return str.replace(/-(\w)/g, (_, c) => c ? c.toUpperCase() : "");
}
function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, " $1").trim();
  return result.split(" ").join("-").toLowerCase();
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function parseId(id) {
  const index = id.indexOf("?");
  if (index < 0) {
    return { path: id, query: {} };
  } else {
    const query = Object.fromEntries(new URLSearchParams(id.slice(index)));
    return {
      path: id.slice(0, index),
      query
    };
  }
}
function isEmpty(value) {
  if (!value || value === null || value === void 0 || Array.isArray(value) && Object.keys(value).length <= 0)
    return true;
  else
    return false;
}
function matchGlobs(filepath, globs) {
  for (const glob of globs) {
    if (minimatch((0, import_utils.slash)(filepath), glob))
      return true;
  }
  return false;
}
function stringifyImport(info) {
  if (typeof info === "string")
    return `import '${info}'`;
  if (!info.name)
    return `import '${info.path}'`;
  else if (info.importName)
    return `import { ${info.importName} as ${info.name} } from '${info.path}'`;
  else
    return `import ${info.name} from '${info.path}'`;
}
function stringifyComponentImport({ name, path, importName, sideEffects }, ctx) {
  if (ctx.options.importPathTransform) {
    const result = ctx.options.importPathTransform(path);
    if (result != null)
      path = result;
  }
  const imports = [
    stringifyImport({ name, path, importName })
  ];
  if (sideEffects)
    (0, import_utils.toArray)(sideEffects).forEach((i) => imports.push(stringifyImport(i)));
  return imports.join(";");
}
function getNameFromFilePath(filePath, options) {
  const { resolvedDirs, directoryAsNamespace, globalNamespaces } = options;
  const parsedFilePath = parse((0, import_utils.slash)(filePath));
  let strippedPath = "";
  for (const dir of resolvedDirs) {
    if (parsedFilePath.dir.startsWith(dir)) {
      strippedPath = parsedFilePath.dir.slice(dir.length);
      break;
    }
  }
  let folders = strippedPath.slice(1).split("/").filter(Boolean);
  let filename = parsedFilePath.name;
  if (filename === "index" && !directoryAsNamespace) {
    filename = `${folders.slice(-1)[0]}`;
    return filename;
  }
  if (directoryAsNamespace) {
    if (globalNamespaces.some((name) => folders.includes(name)))
      folders = folders.filter((f) => !globalNamespaces.includes(f));
    if (filename.toLowerCase() === "index")
      filename = "";
    if (!isEmpty(folders)) {
      filename = [...folders, filename].filter(Boolean).join("-");
    }
    return filename;
  }
  return filename;
}
function resolveAlias(filepath, alias = []) {
  const result = filepath;
  if (Array.isArray(alias)) {
    for (const { find, replacement } of alias)
      result.replace(find, replacement);
  }
  return result;
}
function getPkgVersion(pkgName, defaultVersion) {
  try {
    return __require(`${pkgName}/package.json`).version;
  } catch (err) {
    console.error(err);
    return defaultVersion;
  }
}
function shouldTransform(code) {
  if (code.includes(DISABLE_COMMENT))
    return false;
  return true;
}
function resolveImportPath(importName) {
  return resolve.sync(importName, {
    preserveSymlinks: false
  });
}

// src/core/helpers/libraryResolver.ts
import fs from "fs";
import { dirname, join } from "path";
import Debug from "debug";
var debug = Debug("unplugin-vue-components:helper:library");
function tryLoadVeturTags(name) {
  var _a;
  try {
    const pkgPath = resolveImportPath(`${name}/package.json`);
    if (!pkgPath)
      return;
    const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
    const tagsPath = (_a = pkg == null ? void 0 : pkg.vetur) == null ? void 0 : _a.tags;
    if (!tagsPath)
      return;
    const tags = JSON.parse(fs.readFileSync(join(dirname(pkgPath), tagsPath), "utf-8"));
    return Object.keys(tags).map((i) => camelCase(i));
  } catch (e) {
    console.error(e);
  }
}
function LibraryResolver(options) {
  const {
    name: libraryName,
    entries = tryLoadVeturTags(options.name),
    prefix = ""
  } = options;
  if (!entries) {
    console.warn(`[unplugin-vue-components] Failed to load Vetur tags from library "${libraryName}"`);
    return () => {
    };
  }
  debug(entries);
  const prefixKebab = kebabCase(prefix);
  const kebabEntries = entries.map((name) => ({ name, kebab: kebabCase(name) }));
  return (name) => {
    const kebab = kebabCase(name);
    let componentName = kebab;
    if (prefixKebab) {
      if (!kebab.startsWith(`${prefixKebab}-`))
        return;
      componentName = kebab.slice(prefixKebab.length + 1);
    }
    for (const entry of kebabEntries) {
      if (entry.kebab === componentName)
        return { path: libraryName, importName: entry.name };
    }
  };
}

export {
  require_dist,
  DISABLE_COMMENT,
  pascalCase,
  camelCase,
  kebabCase,
  parseId,
  matchGlobs,
  stringifyComponentImport,
  getNameFromFilePath,
  resolveAlias,
  getPkgVersion,
  shouldTransform,
  resolveImportPath,
  tryLoadVeturTags,
  LibraryResolver
};
